const e=[{text:"http详解（基于node)",link:"/backend/http#http详解-基于node",textType:"page",routeTitle:"backend",groupType:1},{text:"后端",link:"/backend/index#后端",textType:"page",routeTitle:"backend",groupType:1},{text:"mysql",link:"/backend/mysql#mysql",textType:"page",routeTitle:"backend",groupType:1},{text:"next",link:"/backend/nest#next",textType:"page",routeTitle:"backend",groupType:1},{text:"node",link:"/backend/node#node",textType:"page",routeTitle:"backend",groupType:1},{text:"使用PM2实现高效的应用监控与管理",link:"/backend/使用PM2实现高效的应用监控与管理#使用pm2实现高效的应用监控与管理",textType:"page",routeTitle:"backend",groupType:1},{text:"实时协作的艺术：构建高效共享白板系统",link:"/backend/实时协作的艺术：构建高效共享白板系统#实时协作的艺术-构建高效共享白板系统",textType:"page",routeTitle:"backend",groupType:1},{text:"ai业务",link:"/business/ai#ai业务",textType:"page",routeTitle:"business",groupType:2},{text:"编辑器",link:"/business/editor#编辑器",textType:"page",routeTitle:"business",groupType:2},{text:"lint",link:"/business/lint#lint",textType:"page",routeTitle:"business",groupType:2},{text:"参考",link:"/business/microfronend#参考",textType:"page",routeTitle:"business",groupType:2},{text:"端到端测试框架 Playwright 使用入门",link:"/business/playwright#端到端测试框架-playwright-使用入门",textType:"page",routeTitle:"business",groupType:2},{text:"Sentry部署与使用",link:"/business/sentry#sentry部署与使用",textType:"page",routeTitle:"business",groupType:2},{text:"SSL/TLS #",link:"/business/sentry#ssl-tls",textType:"page",routeTitle:"business",groupType:2},{text:"技术选型",link:"/business/techselect#技术选型",textType:"page",routeTitle:"business",groupType:2},{text:"whistle代理用法",link:"/business/whistle#whistle代理用法",textType:"page",routeTitle:"business",groupType:2},{text:"工作流程",link:"/business/workflow#工作流程",textType:"page",routeTitle:"business",groupType:2},{text:"前端常见业务",link:"/business/前端常见业务#前端常见业务",textType:"page",routeTitle:"business",groupType:2},{text:"工作流程",link:"/business/工作流程#工作流程",textType:"page",routeTitle:"business",groupType:2},{text:"技术选型",link:"/business/技术选型#技术选型",textType:"page",routeTitle:"business",groupType:2},{text:"部署",link:"/devops/deploy#部署",textType:"page",routeTitle:"devops",groupType:3},{text:"git入门",link:"/devops/git#git入门",textType:"page",routeTitle:"devops",groupType:3},{text:"运维",link:"/devops/index#运维",textType:"page",routeTitle:"devops",groupType:3},{text:"jenkins",link:"/devops/jenkins#jenkins",textType:"page",routeTitle:"devops",groupType:3},{text:"nginx",link:"/devops/nginx#nginx",textType:"page",routeTitle:"devops",groupType:3},{text:"shell",link:"/devops/shell#shell",textType:"page",routeTitle:"devops",groupType:3},{text:"包管理",link:"/devops/包管理#包管理",textType:"page",routeTitle:"devops",groupType:3},{text:"常用指令",link:"/devops/常用指令#常用指令",textType:"page",routeTitle:"devops",groupType:3},{text:"版本管理",link:"/devops/版本管理#版本管理",textType:"page",routeTitle:"devops",groupType:3},{text:"端口管理",link:"/devops/端口管理#端口管理",textType:"page",routeTitle:"devops",groupType:3},{text:"自动化部署",link:"/devops/自动化部署#自动化部署",textType:"page",routeTitle:"devops",groupType:3},{text:"进程管理",link:"/devops/进程原理#进程管理",textType:"page",routeTitle:"devops",groupType:3},{text:"whistle抓本地包",link:"/faq/index#whistle抓本地包",textType:"page",routeTitle:"faq",groupType:0},{text:"axios",link:"/frontend/axios#axios",textType:"page",routeTitle:"frontend",groupType:0},{text:"console",link:"/frontend/console#console",textType:"page",routeTitle:"frontend",groupType:0},{text:"cookie字段",link:"/frontend/cookie#cookie字段",textType:"page",routeTitle:"frontend",groupType:0},{text:"CSS",link:"/frontend/CSS#css",textType:"page",routeTitle:"frontend",groupType:0},{text:"dom",link:"/frontend/dom#dom",textType:"page",routeTitle:"frontend",groupType:0},{text:"fetch",link:"/frontend/fetch#fetch",textType:"page",routeTitle:"frontend",groupType:0},{text:"优质前端内容汇总",link:"/frontend/index#优质前端内容汇总",textType:"page",routeTitle:"frontend",groupType:0},{text:"#号简写",link:"/frontend/vue3_refs#号简写",textType:"page",routeTitle:"frontend",groupType:0},{text:"国内高速前端 Unpkg CDN 替代方案",link:"/frontend/国内高速前端 Unpkg CDN 替代方案#国内高速前端-unpkg-cdn-替代方案",textType:"page",routeTitle:"frontend",groupType:0},{text:"坐标位置",link:"/frontend/坐标位置#坐标位置",textType:"page",routeTitle:"frontend",groupType:0},{text:"CSS布局",link:"/frontend/布局#css布局",textType:"page",routeTitle:"frontend",groupType:0},{text:"常用注入 Script 方法",link:"/frontend/常用注入 Script 方法#常用注入-script-方法",textType:"page",routeTitle:"frontend",groupType:0},{text:"断点调试",link:"/frontend/断点调试#断点调试",textType:"page",routeTitle:"frontend",groupType:0},{text:"设计模式",link:"/frontend/设计模式#设计模式",textType:"page",routeTitle:"frontend",groupType:0},{text:"面试",link:"/interview/index#面试",textType:"page",routeTitle:"interview",groupType:0},{text:"字符串问号排序",link:"/interview/字符串问号排序#字符串问号排序",textType:"page",routeTitle:"interview",groupType:0},{text:"实现一个代理服务器",link:"/interview/实现一个代理服务器#实现一个代理服务器",textType:"page",routeTitle:"interview",groupType:0},{text:"找单独的数",link:"/interview/找单独的数#找单独的数",textType:"page",routeTitle:"interview",groupType:0},{text:"查找热点数据",link:"/interview/查找热点数据#查找热点数据",textType:"page",routeTitle:"interview",groupType:0},{text:"curl",link:"/tools/curl#curl",textType:"page",routeTitle:"tools",groupType:0},{text:"postman",link:"/tools/postman#postman",textType:"page",routeTitle:"tools",groupType:0},{text:"webStorm",link:"/tools/webstorm#webstorm",textType:"page",routeTitle:"tools",groupType:0},{text:"代码风格",link:"/tools/代码风格#代码风格",textType:"page",routeTitle:"tools",groupType:0},{text:"提效工具",link:"/tools/提效工具#提效工具",textType:"page",routeTitle:"tools",groupType:0},{text:"chrome开发工具",link:"/tools/谷歌开发者工具#chrome开发工具",textType:"page",routeTitle:"tools",groupType:0},{text:"技术总结",link:"/index#技术总结",textType:"page",routeTitle:"index",groupType:0},{text:"http协议历史",link:"/backend/http#http协议历史",textType:"title",routeTitle:"backend > http",groupType:1},{text:"HTTP/0.9 – 单行协议",link:"/backend/http#http-0-9-–-单行协议",textType:"title",routeTitle:"backend > http",groupType:1},{text:"HTTP/1.0 – 构建可扩展性",link:"/backend/http#http-1-0-–-构建可扩展性",textType:"title",routeTitle:"backend > http",groupType:1},{text:"HTTP/1.1 – 标准化的协议",link:"/backend/http#http-1-1-–-标准化的协议",textType:"title",routeTitle:"backend > http",groupType:1},{text:"http/2",link:"/backend/http#http-2",textType:"title",routeTitle:"backend > http",groupType:1},{text:"http/3",link:"/backend/http#http-3",textType:"title",routeTitle:"backend > http",groupType:1},{text:"http方法 restful",link:"/backend/http#http方法-restful",textType:"title",routeTitle:"backend > http",groupType:1},{text:"http状态吗",link:"/backend/http#http状态吗",textType:"title",routeTitle:"backend > http",groupType:1},{text:"header",link:"/backend/http#header",textType:"title",routeTitle:"backend > http",groupType:1},{text:"content-type",link:"/backend/http#content-type",textType:"title",routeTitle:"backend > http",groupType:1},{text:"跨域",link:"/backend/http#跨域",textType:"title",routeTitle:"backend > http",groupType:1},{text:"缓存",link:"/backend/http#缓存",textType:"title",routeTitle:"backend > http",groupType:1},{text:"重定向",link:"/backend/http#重定向",textType:"title",routeTitle:"backend > http",groupType:1},{text:"认证",link:"/backend/http#认证",textType:"title",routeTitle:"backend > http",groupType:1},{text:"https",link:"/backend/http#https",textType:"title",routeTitle:"backend > http",groupType:1},{text:"负载均衡",link:"/backend/http#负载均衡",textType:"title",routeTitle:"backend > http",groupType:1},{text:"http method",link:"/backend/http#http-method",textType:"title",routeTitle:"backend > http",groupType:1},{text:"http状态码",link:"/backend/http#http状态码",textType:"title",routeTitle:"backend > http",groupType:1},{text:"node默认的maxHeaderSize",link:"/backend/http#node默认的maxheadersize",textType:"title",routeTitle:"backend > http",groupType:1},{text:"http缓存",link:"/backend/http#http缓存",textType:"title",routeTitle:"backend > http",groupType:1},{text:"参考",link:"/backend/http#参考",textType:"title",routeTitle:"backend > http",groupType:1},{text:"常用命令",link:"/backend/mysql#常用命令",textType:"title",routeTitle:"backend > mysql",groupType:1},{text:"1. Next.js",link:"/backend/nest#_1-next-js",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"2. 诞生背景",link:"/backend/nest#_2-诞生背景",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"3. 安装",link:"/backend/nest#_3-安装",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"使用 create-next-app 创建新项目",link:"/backend/nest#使用-create-next-app-创建新项目",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"手动添加到现有的 React 项目",link:"/backend/nest#手动添加到现有的-react-项目",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"Next.js 的基本目录和工作结构",link:"/backend/nest#next-js-的基本目录和工作结构",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"最小工作流程",link:"/backend/nest#最小工作流程",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"4. 目录结构",link:"/backend/nest#_4-目录结构",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"顶层文件夹",link:"/backend/nest#顶层文件夹",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"顶层文件",link:"/backend/nest#顶层文件",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"Next.js",link:"/backend/nest#next-js",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"app 路由约定",link:"/backend/nest#app-路由约定",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"路由文件",link:"/backend/nest#路由文件",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"嵌套路由",link:"/backend/nest#嵌套路由",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"动态路由",link:"/backend/nest#动态路由",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"路由组和私有文件夹",link:"/backend/nest#路由组和私有文件夹",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"平行路由和拦截路由",link:"/backend/nest#平行路由和拦截路由",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"元数据文件约定",link:"/backend/nest#元数据文件约定",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"应用图标",link:"/backend/nest#应用图标",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"Open Graph 和 Twitter 图片",link:"/backend/nest#open-graph-和-twitter-图片",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"SEO",link:"/backend/nest#seo",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"pages 路由约定",link:"/backend/nest#pages-路由约定",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"特殊文件",link:"/backend/nest#特殊文件",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"路由",link:"/backend/nest#路由",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"文件夹约定",link:"/backend/nest#文件夹约定",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"文件约定",link:"/backend/nest#文件约定",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"动态路由",link:"/backend/nest#动态路由-1",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"文件夹约定",link:"/backend/nest#文件夹约定-1",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"文件约定",link:"/backend/nest#文件约定-1",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"5. 路由",link:"/backend/nest#_5-路由",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"pages 路由器（Pages Router）",link:"/backend/nest#pages-路由器-pages-router",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"app 路由器（App Router）",link:"/backend/nest#app-路由器-app-router",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"6. 示例",link:"/backend/nest#_6-示例",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"6.1 前后端接口声明&调用",link:"/backend/nest#_6-1-前后端接口声明-调用",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"1. 创建后端 API 接口",link:"/backend/nest#_1-创建后端-api-接口",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"2. 前端页面调用 API 接口",link:"/backend/nest#_2-前端页面调用-api-接口",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"6.2 登录场景",link:"/backend/nest#_6-2-登录场景",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"1. 创建登录 API 接口",link:"/backend/nest#_1-创建登录-api-接口",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"2. 创建前端登录页面",link:"/backend/nest#_2-创建前端登录页面",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"3. 登录态保持和退出登录机制",link:"/backend/nest#_3-登录态保持和退出登录机制",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"4. 登录后的鉴权",link:"/backend/nest#_4-登录后的鉴权",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"6.3 接口平台场景",link:"/backend/nest#_6-3-接口平台场景",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"步骤 1: 创建 API 路由",link:"/backend/nest#步骤-1-创建-api-路由",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"步骤 2: 设置 CORS",link:"/backend/nest#步骤-2-设置-cors",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"7. 部署",link:"/backend/nest#_7-部署",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"步骤 1: 构建应用",link:"/backend/nest#步骤-1-构建应用",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"步骤 2: 安装依赖",link:"/backend/nest#步骤-2-安装依赖",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"步骤 3: 启动应用",link:"/backend/nest#步骤-3-启动应用",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"步骤 4: 使用进程管理器（可选）",link:"/backend/nest#步骤-4-使用进程管理器-可选",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"步骤 5: 设置环境变量（可选）",link:"/backend/nest#步骤-5-设置环境变量-可选",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"步骤 6: 反向代理设置（可选）",link:"/backend/nest#步骤-6-反向代理设置-可选",textType:"title",routeTitle:"backend > nest",groupType:1},{text:"代码质量衡量标注",link:"/backend/node#代码质量衡量标注",textType:"title",routeTitle:"backend > node",groupType:1},{text:"高并发、高扩展、高可用",link:"/backend/node#高并发、高扩展、高可用",textType:"title",routeTitle:"backend > node",groupType:1},{text:"pwa 快应用 小程序对比",link:"/backend/node#pwa-快应用-小程序对比",textType:"title",routeTitle:"backend > node",groupType:1},{text:"对比",link:"/backend/node#对比",textType:"title",routeTitle:"backend > node",groupType:1},{text:"从商业角度看技术",link:"/backend/node#从商业角度看技术",textType:"title",routeTitle:"backend > node",groupType:1},{text:"参考",link:"/backend/node#参考",textType:"title",routeTitle:"backend > node",groupType:1},{text:"1. pm2",link:"/backend/使用PM2实现高效的应用监控与管理#_1-pm2",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"2. 诞生背景",link:"/backend/使用PM2实现高效的应用监控与管理#_2-诞生背景",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"2. 安装",link:"/backend/使用PM2实现高效的应用监控与管理#_2-安装",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"3. 常用命令",link:"/backend/使用PM2实现高效的应用监控与管理#_3-常用命令",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"4. 配置文件",link:"/backend/使用PM2实现高效的应用监控与管理#_4-配置文件",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"基本结构",link:"/backend/使用PM2实现高效的应用监控与管理#基本结构",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"主要字段解释",link:"/backend/使用PM2实现高效的应用监控与管理#主要字段解释",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"使用配置文件",link:"/backend/使用PM2实现高效的应用监控与管理#使用配置文件",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"5. CLI 实现配置文件效果",link:"/backend/使用PM2实现高效的应用监控与管理#_5-cli-实现配置文件效果",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"6. 监控",link:"/backend/使用PM2实现高效的应用监控与管理#_6-监控",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"使用 PM2监控命令行工具",link:"/backend/使用PM2实现高效的应用监控与管理#使用-pm2监控命令行工具",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"使用 PM2 Web 界面",link:"/backend/使用PM2实现高效的应用监控与管理#使用-pm2-web-界面",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"自定义指标",link:"/backend/使用PM2实现高效的应用监控与管理#自定义指标",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"7. 其它",link:"/backend/使用PM2实现高效的应用监控与管理#_7-其它",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"7.1 负载均衡下的会话管理",link:"/backend/使用PM2实现高效的应用监控与管理#_7-1-负载均衡下的会话管理",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"7.2 异常重启处理",link:"/backend/使用PM2实现高效的应用监控与管理#_7-2-异常重启处理",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"优雅的关闭处理",link:"/backend/使用PM2实现高效的应用监控与管理#优雅的关闭处理",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"恢复状态",link:"/backend/使用PM2实现高效的应用监控与管理#恢复状态",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"PM2特定策略",link:"/backend/使用PM2实现高效的应用监控与管理#pm2特定策略",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"7.3 SIGINT 信号超时处理",link:"/backend/使用PM2实现高效的应用监控与管理#_7-3-sigint-信号超时处理",textType:"title",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"1. 多人协同关键技术",link:"/backend/实时协作的艺术：构建高效共享白板系统#_1-多人协同关键技术",textType:"title",routeTitle:"backend > 实时协作的艺术：构建高效共享白板系统",groupType:1},{text:"2. 算法对比：OT VS CRDTs",link:"/backend/实时协作的艺术：构建高效共享白板系统#_2-算法对比-ot-vs-crdts",textType:"title",routeTitle:"backend > 实时协作的艺术：构建高效共享白板系统",groupType:1},{text:"3. 传输对比：WebSockets VS WebRTC",link:"/backend/实时协作的艺术：构建高效共享白板系统#_3-传输对比-websockets-vs-webrtc",textType:"title",routeTitle:"backend > 实时协作的艺术：构建高效共享白板系统",groupType:1},{text:"4. 简版实现",link:"/backend/实时协作的艺术：构建高效共享白板系统#_4-简版实现",textType:"title",routeTitle:"backend > 实时协作的艺术：构建高效共享白板系统",groupType:1},{text:"4.1 Server",link:"/backend/实时协作的艺术：构建高效共享白板系统#_4-1-server",textType:"title",routeTitle:"backend > 实时协作的艺术：构建高效共享白板系统",groupType:1},{text:"4.2 浏览器端",link:"/backend/实时协作的艺术：构建高效共享白板系统#_4-2-浏览器端",textType:"title",routeTitle:"backend > 实时协作的艺术：构建高效共享白板系统",groupType:1},{text:"4.3 简单加密/解密处理",link:"/backend/实时协作的艺术：构建高效共享白板系统#_4-3-简单加密-解密处理",textType:"title",routeTitle:"backend > 实时协作的艺术：构建高效共享白板系统",groupType:1},{text:"企业知识助理",link:"/business/ai#企业知识助理",textType:"title",routeTitle:"business > ai",groupType:2},{text:"文本摘要和视频摘要技术研究",link:"/business/ai#文本摘要和视频摘要技术研究",textType:"title",routeTitle:"business > ai",groupType:2},{text:"背景",link:"/business/ai#背景",textType:"title",routeTitle:"business > ai",groupType:2},{text:"存在的问题",link:"/business/ai#存在的问题",textType:"title",routeTitle:"business > ai",groupType:2},{text:"解决方案",link:"/business/ai#解决方案",textType:"title",routeTitle:"business > ai",groupType:2},{text:"参考资料",link:"/business/ai#参考资料",textType:"title",routeTitle:"business > ai",groupType:2},{text:"editor编辑器基本原理",link:"/business/editor#editor编辑器基本原理",textType:"title",routeTitle:"business > editor",groupType:2},{text:"wps编辑器",link:"/business/editor#wps编辑器",textType:"title",routeTitle:"business > editor",groupType:2},{text:"编辑器插件",link:"/business/editor#编辑器插件",textType:"title",routeTitle:"business > editor",groupType:2},{text:"可以做编辑器相关业务",link:"/business/editor#可以做编辑器相关业务",textType:"title",routeTitle:"business > editor",groupType:2},{text:"可以做后端业务nest",link:"/business/editor#可以做后端业务nest",textType:"title",routeTitle:"business > editor",groupType:2},{text:"部署运维",link:"/business/editor#部署运维",textType:"title",routeTitle:"business > editor",groupType:2},{text:"",link:"/business/index#",textType:"title",routeTitle:"business > index",groupType:2},{text:"参考",link:"/business/lint#参考",textType:"title",routeTitle:"business > lint",groupType:2},{text:"1. playwright 介绍",link:"/business/playwright#_1-playwright-介绍",textType:"title",routeTitle:"business > playwright",groupType:2},{text:"2. Playwright Test for VSCode",link:"/business/playwright#_2-playwright-test-for-vscode",textType:"title",routeTitle:"business > playwright",groupType:2},{text:"3. 初始化项目",link:"/business/playwright#_3-初始化项目",textType:"title",routeTitle:"business > playwright",groupType:2},{text:"4. 运行测试",link:"/business/playwright#_4-运行测试",textType:"title",routeTitle:"business > playwright",groupType:2},{text:"5. 添加 cookie",link:"/business/playwright#_5-添加-cookie",textType:"title",routeTitle:"business > playwright",groupType:2},{text:"6. 录制一个测试用例",link:"/business/playwright#_6-录制一个测试用例",textType:"title",routeTitle:"business > playwright",groupType:2},{text:"7. 测试用例及断言",link:"/business/playwright#_7-测试用例及断言",textType:"title",routeTitle:"business > playwright",groupType:2},{text:"8. 小结",link:"/business/playwright#_8-小结",textType:"title",routeTitle:"business > playwright",groupType:2},{text:"介绍",link:"/business/sentry#介绍",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"部署",link:"/business/sentry#部署",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"步骤",link:"/business/sentry#步骤",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"当前sentry平台部署",link:"/business/sentry#当前sentry平台部署",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"部署中的问题",link:"/business/sentry#部署中的问题",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"使用",link:"/business/sentry#使用",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"接入邮箱📮报警",link:"/business/sentry#接入邮箱📮报警",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"mail.use-ssl: true",link:"/business/sentry#mail-use-ssl-true",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"sentry通过https访问",link:"/business/sentry#sentry通过https访问",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"If you're using a reverse SSL proxy, you should enable the X-Forwarded-Proto",link:"/business/sentry#if-you-re-using-a-reverse-ssl-proxy-you-should-enable-the-x-forwarded-proto",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"header and enable the settings below",link:"/business/sentry#header-and-enable-the-settings-below",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"End of SSL/TLS settings",link:"/business/sentry#end-of-ssl-tls-settings",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"使用中的问题",link:"/business/sentry#使用中的问题",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"docker重启",link:"/business/sentry#docker重启",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"sentry-srouce map",link:"/business/sentry#sentry-srouce-map",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"上传日志信息--手动上报",link:"/business/sentry#上传日志信息-手动上报",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"设置变量",link:"/business/sentry#设置变量",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"设置全局变量",link:"/business/sentry#设置全局变量",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"创建警报规则",link:"/business/sentry#创建警报规则",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"release",link:"/business/sentry#release",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"原理",link:"/business/sentry#原理",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"资料",link:"/business/sentry#资料",textType:"title",routeTitle:"business > sentry",groupType:2},{text:"安装启动",link:"/business/whistle#安装启动",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"常用操作",link:"/business/whistle#常用操作",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"替换文件",link:"/business/whistle#替换文件",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"跨域 gzip",link:"/business/whistle#跨域-gzip",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"种Cookie",link:"/business/whistle#种cookie",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"修改接口返回值",link:"/business/whistle#修改接口返回值",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"接口延迟",link:"/business/whistle#接口延迟",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"https://local.zhiliao.domain/api/zl/space/square/list  reqDelay://1000",link:"/business/whistle#https-local-zhiliao-domain-api-zl-space-square-list-reqdelay-1000",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"https://local.zhiliao.domain/api/zl/space/square/list  resDelay://1000",link:"/business/whistle#https-local-zhiliao-domain-api-zl-space-square-list-resdelay-1000",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"修改js",link:"/business/whistle#修改js",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"修改css",link:"/business/whistle#修改css",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"前端页面走本地代码，接口走后端",link:"/business/whistle#前端页面走本地代码-接口走后端",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"使用本地页面",link:"/business/whistle#使用本地页面",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"打印日志",link:"/business/whistle#打印日志",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"host",link:"/business/whistle#host",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"修改ua",link:"/business/whistle#修改ua",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"https://local.zhiliao.domain/api  https://10.90.129.185:9002/api",link:"/business/whistle#https-local-zhiliao-domain-api-https-10-90-129-185-9002-api",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"跨域",link:"/business/whistle#跨域",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"参考",link:"/business/whistle#参考",textType:"title",routeTitle:"business > whistle",groupType:2},{text:"分支管理",link:"/business/workflow#分支管理",textType:"title",routeTitle:"business > workflow",groupType:2},{text:"分支流程管理",link:"/business/workflow#分支流程管理",textType:"title",routeTitle:"business > workflow",groupType:2},{text:"Fork 相关",link:"/business/workflow#fork-相关",textType:"title",routeTitle:"business > workflow",groupType:2},{text:"操作完成后可用该命令检查，origin 和 upstream 会各有2个（fetch 和 push）",link:"/business/workflow#操作完成后可用该命令检查-origin-和-upstream-会各有2个-fetch-和-push",textType:"title",routeTitle:"business > workflow",groupType:2},{text:"操作完成后可用该命令检查，origin 和 upstream 会各有2个（fetch 和 push）",link:"/business/workflow#操作完成后可用该命令检查-origin-和-upstream-会各有2个-fetch-和-push-1",textType:"title",routeTitle:"business > workflow",groupType:2},{text:"然后将本地分支推到origin",link:"/business/workflow#然后将本地分支推到origin",textType:"title",routeTitle:"business > workflow",groupType:2},{text:"主仓库新建分支后",link:"/business/workflow#主仓库新建分支后",textType:"title",routeTitle:"business > workflow",groupType:2},{text:"MR之前",link:"/business/workflow#mr之前",textType:"title",routeTitle:"business > workflow",groupType:2},{text:"先将本地改动推向个人仓库 origin，避免 rebase 操作失误，弄丢了 commit",link:"/business/workflow#先将本地改动推向个人仓库-origin-避免-rebase-操作失误-弄丢了-commit",textType:"title",routeTitle:"business > workflow",groupType:2},{text:"这里以feat_a分支举例，实际操作时，是 rebase MR 的目标分支",link:"/business/workflow#这里以feat-a分支举例-实际操作时-是-rebase-mr-的目标分支",textType:"title",routeTitle:"business > workflow",groupType:2},{text:"rebase 成功，强推回 origin",link:"/business/workflow#rebase-成功-强推回-origin",textType:"title",routeTitle:"business > workflow",groupType:2},{text:"开发流程",link:"/business/workflow#开发流程",textType:"title",routeTitle:"business > workflow",groupType:2},{text:"进阶",link:"/business/workflow#进阶",textType:"title",routeTitle:"business > workflow",groupType:2},{text:"前端开发规范lint",link:"/business/workflow#前端开发规范lint",textType:"title",routeTitle:"business > workflow",groupType:2},{text:"发版",link:"/business/workflow#发版",textType:"title",routeTitle:"business > workflow",groupType:2},{text:"换肤",link:"/business/前端常见业务#换肤",textType:"title",routeTitle:"business > 前端常见业务",groupType:2},{text:"国际化",link:"/business/前端常见业务#国际化",textType:"title",routeTitle:"business > 前端常见业务",groupType:2},{text:"移动端适配",link:"/business/前端常见业务#移动端适配",textType:"title",routeTitle:"business > 前端常见业务",groupType:2},{text:"分支管理",link:"/business/工作流程#分支管理",textType:"title",routeTitle:"business > 工作流程",groupType:2},{text:"发版流程",link:"/business/工作流程#发版流程",textType:"title",routeTitle:"business > 工作流程",groupType:2},{text:"技术怎么选",link:"/business/技术选型#技术怎么选",textType:"title",routeTitle:"business > 技术选型",groupType:2},{text:"选vue还是react",link:"/business/技术选型#选vue还是react",textType:"title",routeTitle:"business > 技术选型",groupType:2},{text:"[TOC]",link:"/business/rtc/video#toc",textType:"title",routeTitle:"rtc > video",groupType:2},{text:"video api",link:"/business/rtc/video#video-api",textType:"title",routeTitle:"rtc > video",groupType:2},{text:"[TOC]",link:"/business/rtc/webRTC1#toc",textType:"title",routeTitle:"rtc > webRTC1",groupType:2},{text:"web直播",link:"/business/rtc/webRTC1#web直播",textType:"title",routeTitle:"rtc > webRTC1",groupType:2},{text:"实现原理",link:"/business/rtc/webRTC1#实现原理",textType:"title",routeTitle:"rtc > webRTC1",groupType:2},{text:"实现步骤",link:"/business/rtc/webRTC1#实现步骤",textType:"title",routeTitle:"rtc > webRTC1",groupType:2},{text:"demo",link:"/business/rtc/webRTC1#demo",textType:"title",routeTitle:"rtc > webRTC1",groupType:2},{text:"参考",link:"/business/rtc/webRTC1#参考",textType:"title",routeTitle:"rtc > webRTC1",groupType:2},{text:"[TOC]",link:"/business/rtc/webRTC2#toc",textType:"title",routeTitle:"rtc > webRTC2",groupType:2},{text:"协议",link:"/business/rtc/webRTC2#协议",textType:"title",routeTitle:"rtc > webRTC2",groupType:2},{text:"流媒体采集",link:"/business/rtc/webRTC2#流媒体采集",textType:"title",routeTitle:"rtc > webRTC2",groupType:2},{text:"rtmp",link:"/business/rtc/webRTC2#rtmp",textType:"title",routeTitle:"rtc > webRTC2",groupType:2},{text:"srcObject",link:"/business/rtc/webRTC2#srcobject",textType:"title",routeTitle:"rtc > webRTC2",groupType:2},{text:"StreamMedia",link:"/business/rtc/webRTC2#streammedia",textType:"title",routeTitle:"rtc > webRTC2",groupType:2},{text:"websocket做了 也做了WebRTC信令",link:"/business/rtc/webRTC2#websocket做了-也做了webrtc信令",textType:"title",routeTitle:"rtc > webRTC2",groupType:2},{text:"mediaPlayer",link:"/business/rtc/webRTC2#mediaplayer",textType:"title",routeTitle:"rtc > webRTC2",groupType:2},{text:"video",link:"/business/rtc/webRTC2#video",textType:"title",routeTitle:"rtc > webRTC2",groupType:2},{text:"audio",link:"/business/rtc/webRTC2#audio",textType:"title",routeTitle:"rtc > webRTC2",groupType:2},{text:"数据格式 mp4 flv",link:"/business/rtc/webRTC2#数据格式-mp4-flv",textType:"title",routeTitle:"rtc > webRTC2",groupType:2},{text:"参考",link:"/business/rtc/webRTC2#参考",textType:"title",routeTitle:"rtc > webRTC2",groupType:2},{text:"live-player 第一次使用需要申请摄像头 麦克风权限(需要用户授权 `scope.camera`、`scope.record`)",link:"/business/rtc/zego#live-player-第一次使用需要申请摄像头-麦克风权限-需要用户授权-scope-camera-、-scope-record",textType:"title",routeTitle:"rtc > zego",groupType:2},{text:"端口占用问题处理方式",link:"/devops/deploy#端口占用问题处理方式",textType:"title",routeTitle:"devops > deploy",groupType:3},{text:"客户端输入的数据都会原样显示在服务器上",link:"/devops/deploy#客户端输入的数据都会原样显示在服务器上",textType:"title",routeTitle:"devops > deploy",groupType:3},{text:"pid:871",link:"/devops/deploy#pid-871",textType:"title",routeTitle:"devops > deploy",groupType:3},{text:"pid:871",link:"/devops/deploy#pid-871-1",textType:"title",routeTitle:"devops > deploy",groupType:3},{text:"git操作",link:"/devops/git#git操作",textType:"title",routeTitle:"devops > git",groupType:3},{text:"常用指令",link:"/devops/index#常用指令",textType:"title",routeTitle:"devops > index",groupType:3},{text:"pid:871",link:"/devops/index#pid-871",textType:"title",routeTitle:"devops > index",groupType:3},{text:"pid:871",link:"/devops/index#pid-871-1",textType:"title",routeTitle:"devops > index",groupType:3},{text:"mac nginx常见命令",link:"/devops/nginx#mac-nginx常见命令",textType:"title",routeTitle:"devops > nginx",groupType:3},{text:"linux nginx常用命令",link:"/devops/nginx#linux-nginx常用命令",textType:"title",routeTitle:"devops > nginx",groupType:3},{text:"常见业务示例",link:"/devops/nginx#常见业务示例",textType:"title",routeTitle:"devops > nginx",groupType:3},{text:"参考",link:"/devops/nginx#参考",textType:"title",routeTitle:"devops > nginx",groupType:3},{text:"常用命令",link:"/devops/shell#常用命令",textType:"title",routeTitle:"devops > shell",groupType:3},{text:"上传文件",link:"/devops/shell#上传文件",textType:"title",routeTitle:"devops > shell",groupType:3},{text:"查histroy",link:"/devops/shell#查histroy",textType:"title",routeTitle:"devops > shell",groupType:3},{text:"重命名",link:"/devops/shell#重命名",textType:"title",routeTitle:"devops > shell",groupType:3},{text:"软链接",link:"/devops/shell#软链接",textType:"title",routeTitle:"devops > shell",groupType:3},{text:"查找应用路径",link:"/devops/shell#查找应用路径",textType:"title",routeTitle:"devops > shell",groupType:3},{text:"查历史记录",link:"/devops/shell#查历史记录",textType:"title",routeTitle:"devops > shell",groupType:3},{text:"zx用法",link:"/devops/shell#zx用法",textType:"title",routeTitle:"devops > shell",groupType:3},{text:"Yum",link:"/devops/包管理#yum",textType:"title",routeTitle:"devops > 包管理",groupType:3},{text:"node版本管理",link:"/devops/版本管理#node版本管理",textType:"title",routeTitle:"devops > 版本管理",groupType:3},{text:"切换node版本",link:"/devops/版本管理#切换node版本",textType:"title",routeTitle:"devops > 版本管理",groupType:3},{text:"node版本管理",link:"/devops/版本管理#node版本管理-1",textType:"title",routeTitle:"devops > 版本管理",groupType:3},{text:"切换node版本",link:"/devops/版本管理#切换node版本-1",textType:"title",routeTitle:"devops > 版本管理",groupType:3},{text:"查看开启的端口",link:"/devops/端口管理#查看开启的端口",textType:"title",routeTitle:"devops > 端口管理",groupType:3},{text:"查看端口被那个进程占用 port:8000",link:"/devops/端口管理#查看端口被那个进程占用-port-8000",textType:"title",routeTitle:"devops > 端口管理",groupType:3},{text:"pid:871",link:"/devops/端口管理#pid-871",textType:"title",routeTitle:"devops > 端口管理",groupType:3},{text:"查看端口被那个进程占用 port:8000",link:"/devops/端口管理#查看端口被那个进程占用-port-8000-1",textType:"title",routeTitle:"devops > 端口管理",groupType:3},{text:"pid:871",link:"/devops/端口管理#pid-871-1",textType:"title",routeTitle:"devops > 端口管理",groupType:3},{text:"远程主机端口是否启用",link:"/devops/端口管理#远程主机端口是否启用",textType:"title",routeTitle:"devops > 端口管理",groupType:3},{text:"输入账号 密码 登录主机",link:"/devops/端口管理#输入账号-密码-登录主机",textType:"title",routeTitle:"devops > 端口管理",groupType:3},{text:"客户端输入的数据都会原样显示在服务器上",link:"/devops/端口管理#客户端输入的数据都会原样显示在服务器上",textType:"title",routeTitle:"devops > 端口管理",groupType:3},{text:"登录",link:"/devops/自动化部署#登录",textType:"title",routeTitle:"devops > 自动化部署",groupType:3},{text:"安装shell expect",link:"/devops/自动化部署#安装shell-expect",textType:"title",routeTitle:"devops > 自动化部署",groupType:3},{text:"linux进程",link:"/devops/进程原理#linux进程",textType:"title",routeTitle:"devops > 进程原理",groupType:3},{text:"查看进程",link:"/devops/进程原理#查看进程",textType:"title",routeTitle:"devops > 进程原理",groupType:3},{text:"PM2",link:"/devops/进程原理#pm2",textType:"title",routeTitle:"devops > 进程原理",groupType:3},{text:"常用命令",link:"/devops/进程原理#常用命令",textType:"title",routeTitle:"devops > 进程原理",groupType:3},{text:"config",link:"/devops/进程原理#config",textType:"title",routeTitle:"devops > 进程原理",groupType:3},{text:"定位",link:"/frontend/axios#定位",textType:"title",routeTitle:"frontend > axios",groupType:0},{text:"特性",link:"/frontend/axios#特性",textType:"title",routeTitle:"frontend > axios",groupType:0},{text:"洋葱模型",link:"/frontend/axios#洋葱模型",textType:"title",routeTitle:"frontend > axios",groupType:0},{text:"axios请求图片",link:"/frontend/axios#axios请求图片",textType:"title",routeTitle:"frontend > axios",groupType:0},{text:"全部配置axios.defaults",link:"/frontend/axios#全部配置axios-defaults",textType:"title",routeTitle:"frontend > axios",groupType:0},{text:"axios对象",link:"/frontend/axios#axios对象",textType:"title",routeTitle:"frontend > axios",groupType:0},{text:"axios适配器",link:"/frontend/axios#axios适配器",textType:"title",routeTitle:"frontend > axios",groupType:0},{text:"axios方法",link:"/frontend/axios#axios方法",textType:"title",routeTitle:"frontend > axios",groupType:0},{text:"核心函数",link:"/frontend/axios#核心函数",textType:"title",routeTitle:"frontend > axios",groupType:0},{text:"浏览器端",link:"/frontend/axios#浏览器端",textType:"title",routeTitle:"frontend > axios",groupType:0},{text:"node端",link:"/frontend/axios#node端",textType:"title",routeTitle:"frontend > axios",groupType:0},{text:"axios防御XSRF攻击",link:"/frontend/axios#axios防御xsrf攻击",textType:"title",routeTitle:"frontend > axios",groupType:0},{text:"参考",link:"/frontend/axios#参考",textType:"title",routeTitle:"frontend > axios",groupType:0},{text:"js操作cookie",link:"/frontend/cookie#js操作cookie",textType:"title",routeTitle:"frontend > cookie",groupType:0},{text:"浏览器开发者工具操作cookie",link:"/frontend/cookie#浏览器开发者工具操作cookie",textType:"title",routeTitle:"frontend > cookie",groupType:0},{text:"服务器操作cookie",link:"/frontend/cookie#服务器操作cookie",textType:"title",routeTitle:"frontend > cookie",groupType:0},{text:"storage",link:"/frontend/cookie#storage",textType:"title",routeTitle:"frontend > cookie",groupType:0},{text:"CSS选择器",link:"/frontend/CSS#css选择器",textType:"title",routeTitle:"frontend > CSS",groupType:0},{text:"浏览器工作原理",link:"/frontend/dom#浏览器工作原理",textType:"title",routeTitle:"frontend > dom",groupType:0},{text:"dom常见操作",link:"/frontend/dom#dom常见操作",textType:"title",routeTitle:"frontend > dom",groupType:0},{text:"事件转发和事件流",link:"/frontend/dom#事件转发和事件流",textType:"title",routeTitle:"frontend > dom",groupType:0},{text:"默认行为和可取消事件",link:"/frontend/dom#默认行为和可取消事件",textType:"title",routeTitle:"frontend > dom",groupType:0},{text:"参考",link:"/frontend/dom#参考",textType:"title",routeTitle:"frontend > dom",groupType:0},{text:"请求库",link:"/frontend/fetch#请求库",textType:"title",routeTitle:"frontend > fetch",groupType:0},{text:"浏览器端使用",link:"/frontend/fetch#浏览器端使用",textType:"title",routeTitle:"frontend > fetch",groupType:0},{text:"node中使用",link:"/frontend/fetch#node中使用",textType:"title",routeTitle:"frontend > fetch",groupType:0},{text:"fetch vs XMLHttpRequest",link:"/frontend/fetch#fetch-vs-xmlhttprequest",textType:"title",routeTitle:"frontend > fetch",groupType:0},{text:"get请求",link:"/frontend/fetch#get请求",textType:"title",routeTitle:"frontend > fetch",groupType:0},{text:"Post、Put请求",link:"/frontend/fetch#post、put请求",textType:"title",routeTitle:"frontend > fetch",groupType:0},{text:"Post formData",link:"/frontend/fetch#post-formdata",textType:"title",routeTitle:"frontend > fetch",groupType:0},{text:"关于formData",link:"/frontend/fetch#关于formdata",textType:"title",routeTitle:"frontend > fetch",groupType:0},{text:"参考文件",link:"/frontend/fetch#参考文件",textType:"title",routeTitle:"frontend > fetch",groupType:0},{text:"",link:"/frontend/JS核心#",textType:"title",routeTitle:"frontend > JS核心",groupType:0},{text:"原型链",link:"/frontend/JS核心#原型链",textType:"title",routeTitle:"frontend > JS核心",groupType:0},{text:"",link:"/frontend/Promise常见面试题#",textType:"title",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:"1\\. Promise 对象池",link:"/frontend/Promise常见面试题#_1-promise-对象池",textType:"title",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:"2\\. 两个 Promise 对象相加",link:"/frontend/Promise常见面试题#_2-两个-promise-对象相加",textType:"title",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:"3\\. 有时间限制的 Promise 对象",link:"/frontend/Promise常见面试题#_3-有时间限制的-promise-对象",textType:"title",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:"4\\. 延迟每个 Promise 对象的解析",link:"/frontend/Promise常见面试题#_4-延迟每个-promise-对象的解析",textType:"title",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:"5\\. 转换回调函数为 Promise 函数",link:"/frontend/Promise常见面试题#_5-转换回调函数为-promise-函数",textType:"title",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:"6\\. 并行执行 Promise 以获取独有的结果",link:"/frontend/Promise常见面试题#_6-并行执行-promise-以获取独有的结果",textType:"title",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:"7\\. 并行执行异步函数",link:"/frontend/Promise常见面试题#_7-并行执行异步函数",textType:"title",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:"8\\. 睡眠函数",link:"/frontend/Promise常见面试题#_8-睡眠函数",textType:"title",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:"9\\. 异步任务调度器",link:"/frontend/Promise常见面试题#_9-异步任务调度器",textType:"title",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:"11\\. 设计可取消 Promise",link:"/frontend/Promise常见面试题#_11-设计可取消-promise",textType:"title",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:"10\\. 多个 Callback 函数 Promise 化的测试用例",link:"/frontend/Promise常见面试题#_10-多个-callback-函数-promise-化的测试用例",textType:"title",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:"- 做React需要会什么？",link:"/frontend/react#做react需要会什么",textType:"title",routeTitle:"frontend > react",groupType:0},{text:"",link:"/frontend/sentry异常监控#",textType:"title",routeTitle:"frontend > sentry异常监控",groupType:0},{text:"参考",link:"/frontend/sentry异常监控#参考",textType:"title",routeTitle:"frontend > sentry异常监控",groupType:0},{text:"",link:"/frontend/vue3#",textType:"title",routeTitle:"frontend > vue3",groupType:0},{text:"",link:"/frontend/vue3_refs#",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"1.slot语法更简短",link:"/frontend/vue3_refs#_1-slot语法更简短",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"统一成v-slot,包括局部作用域",link:"/frontend/vue3_refs#统一成v-slot-包括局部作用域",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"2.动态指令参数",link:"/frontend/vue3_refs#_2-动态指令参数",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"3.树摇",link:"/frontend/vue3_refs#_3-树摇",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"变化",link:"/frontend/vue3_refs#变化",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"Affected 2.x APIs",link:"/frontend/vue3_refs#affected-2-x-apis",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"4.增强v-model",link:"/frontend/vue3_refs#_4-增强v-model",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"5.全局方法改成实例方法",link:"/frontend/vue3_refs#_5-全局方法改成实例方法",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"Before",link:"/frontend/vue3_refs#before",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"After",link:"/frontend/vue3_refs#after",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"6.自定义指令",link:"/frontend/vue3_refs#_6-自定义指令",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"动机",link:"/frontend/vue3_refs#动机",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"Before",link:"/frontend/vue3_refs#before-1",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"After",link:"/frontend/vue3_refs#after-1",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"7.composition api",link:"/frontend/vue3_refs#_7-composition-api",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"8.移除filter",link:"/frontend/vue3_refs#_8-移除filter",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"移除动机",link:"/frontend/vue3_refs#移除动机",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"9.移除keycode",link:"/frontend/vue3_refs#_9-移除keycode",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"移除动机",link:"/frontend/vue3_refs#移除动机-1",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"10.移除inline-template",link:"/frontend/vue3_refs#_10-移除inline-template",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"移除动机",link:"/frontend/vue3_refs#移除动机-2",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"11.vue实例上移除事件方法",link:"/frontend/vue3_refs#_11-vue实例上移除事件方法",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"移除动机",link:"/frontend/vue3_refs#移除动机-3",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"12.移除inline-template",link:"/frontend/vue3_refs#_12-移除inline-template",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"移除动机",link:"/frontend/vue3_refs#移除动机-4",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"13.data对象声明",link:"/frontend/vue3_refs#_13-data对象声明",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"参考",link:"/frontend/vue3_refs#参考",textType:"title",routeTitle:"frontend > vue3_refs",groupType:0},{text:"",link:"/frontend/其他#",textType:"title",routeTitle:"frontend > 其他",groupType:0},{text:"其他",link:"/frontend/其他#其他",textType:"title",routeTitle:"frontend > 其他",groupType:0},{text:"1. 背景",link:"/frontend/国内高速前端 Unpkg CDN 替代方案#_1-背景",textType:"title",routeTitle:"frontend > 国内高速前端 Unpkg CDN 替代方案",groupType:0},{text:"2. 国内 Unpkg",link:"/frontend/国内高速前端 Unpkg CDN 替代方案#_2-国内-unpkg",textType:"title",routeTitle:"frontend > 国内高速前端 Unpkg CDN 替代方案",groupType:0},{text:"元素宽高",link:"/frontend/坐标位置#元素宽高",textType:"title",routeTitle:"frontend > 坐标位置",groupType:0},{text:"元素坐标位置",link:"/frontend/坐标位置#元素坐标位置",textType:"title",routeTitle:"frontend > 坐标位置",groupType:0},{text:"整体坐标位置",link:"/frontend/坐标位置#整体坐标位置",textType:"title",routeTitle:"frontend > 坐标位置",groupType:0},{text:"参考",link:"/frontend/坐标位置#参考",textType:"title",routeTitle:"frontend > 坐标位置",groupType:0},{text:"grid",link:"/frontend/布局#grid",textType:"title",routeTitle:"frontend > 布局",groupType:0},{text:"flex",link:"/frontend/布局#flex",textType:"title",routeTitle:"frontend > 布局",groupType:0},{text:"1. 背景",link:"/frontend/常用注入 Script 方法#_1-背景",textType:"title",routeTitle:"frontend > 常用注入 Script 方法",groupType:0},{text:"2. 常用方法",link:"/frontend/常用注入 Script 方法#_2-常用方法",textType:"title",routeTitle:"frontend > 常用注入 Script 方法",groupType:0},{text:"2.1. 工具包的注入",link:"/frontend/常用注入 Script 方法#_2-1-工具包的注入",textType:"title",routeTitle:"frontend > 常用注入 Script 方法",groupType:0},{text:"2.2. 脚本的注入",link:"/frontend/常用注入 Script 方法#_2-2-脚本的注入",textType:"title",routeTitle:"frontend > 常用注入 Script 方法",groupType:0},{text:"2.2.1. 直接 DevTools 执行",link:"/frontend/常用注入 Script 方法#_2-2-1-直接-devtools-执行",textType:"title",routeTitle:"frontend > 常用注入 Script 方法",groupType:0},{text:"2.2.2. 直接在地址栏执行",link:"/frontend/常用注入 Script 方法#_2-2-2-直接在地址栏执行",textType:"title",routeTitle:"frontend > 常用注入 Script 方法",groupType:0},{text:"2.2.3. 书签执行",link:"/frontend/常用注入 Script 方法#_2-2-3-书签执行",textType:"title",routeTitle:"frontend > 常用注入 Script 方法",groupType:0},{text:"1. 直接在源代码中打断点",link:"/frontend/断点调试#_1-直接在源代码中打断点",textType:"title",routeTitle:"frontend > 断点调试",groupType:0},{text:"2. 通过元素事件找到源代码打断点",link:"/frontend/断点调试#_2-通过元素事件找到源代码打断点",textType:"title",routeTitle:"frontend > 断点调试",groupType:0},{text:"3. 找到元素打dom断点",link:"/frontend/断点调试#_3-找到元素打dom断点",textType:"title",routeTitle:"frontend > 断点调试",groupType:0},{text:"4. 通过MutationObserver打断点，查看调用栈",link:"/frontend/断点调试#_4-通过mutationobserver打断点-查看调用栈",textType:"title",routeTitle:"frontend > 断点调试",groupType:0},{text:"- 问题",link:"/frontend/面试#问题",textType:"title",routeTitle:"frontend > 面试",groupType:0},{text:"题目",link:"/interview/字符串问号排序#题目",textType:"title",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"样例",link:"/interview/字符串问号排序#样例",textType:"title",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"输入：",link:"/interview/字符串问号排序#输入",textType:"title",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"输出：",link:"/interview/字符串问号排序#输出",textType:"title",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"输入：",link:"/interview/字符串问号排序#输入-1",textType:"title",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"输出：",link:"/interview/字符串问号排序#输出-1",textType:"title",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"输入：",link:"/interview/字符串问号排序#输入-2",textType:"title",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"输出：",link:"/interview/字符串问号排序#输出-2",textType:"title",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"代码实现",link:"/interview/字符串问号排序#代码实现",textType:"title",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"问题描述",link:"/interview/实现一个代理服务器#问题描述",textType:"title",routeTitle:"interview > 实现一个代理服务器",groupType:0},{text:"代码实现",link:"/interview/实现一个代理服务器#代码实现",textType:"title",routeTitle:"interview > 实现一个代理服务器",groupType:0},{text:"问题描述",link:"/interview/找单独的数#问题描述",textType:"title",routeTitle:"interview > 找单独的数",groupType:0},{text:"输入格式",link:"/interview/找单独的数#输入格式",textType:"title",routeTitle:"interview > 找单独的数",groupType:0},{text:"输出格式",link:"/interview/找单独的数#输出格式",textType:"title",routeTitle:"interview > 找单独的数",groupType:0},{text:"输入样例(1)",link:"/interview/找单独的数#输入样例-1",textType:"title",routeTitle:"interview > 找单独的数",groupType:0},{text:"输出样例(1)",link:"/interview/找单独的数#输出样例-1",textType:"title",routeTitle:"interview > 找单独的数",groupType:0},{text:"输入样例(2)",link:"/interview/找单独的数#输入样例-2",textType:"title",routeTitle:"interview > 找单独的数",groupType:0},{text:"输出样例(2)",link:"/interview/找单独的数#输出样例-2",textType:"title",routeTitle:"interview > 找单独的数",groupType:0},{text:"代码实现",link:"/interview/找单独的数#代码实现",textType:"title",routeTitle:"interview > 找单独的数",groupType:0},{text:"问题描述",link:"/interview/查找热点数据#问题描述",textType:"title",routeTitle:"interview > 查找热点数据",groupType:0},{text:"代码实现",link:"/interview/查找热点数据#代码实现",textType:"title",routeTitle:"interview > 查找热点数据",groupType:0},{text:"curl",link:"/tools/curl#curl-1",textType:"title",routeTitle:"tools > curl",groupType:0},{text:"get请求",link:"/tools/curl#get请求",textType:"title",routeTitle:"tools > curl",groupType:0},{text:"post json请求",link:"/tools/curl#post-json请求",textType:"title",routeTitle:"tools > curl",groupType:0},{text:"post application/x-www-form-urlencoded请求",link:"/tools/curl#post-application-x-www-form-urlencoded请求",textType:"title",routeTitle:"tools > curl",groupType:0},{text:"post formData请求",link:"/tools/curl#post-formdata请求",textType:"title",routeTitle:"tools > curl",groupType:0},{text:"put请求",link:"/tools/curl#put请求",textType:"title",routeTitle:"tools > curl",groupType:0},{text:"delete请求",link:"/tools/curl#delete请求",textType:"title",routeTitle:"tools > curl",groupType:0},{text:"生成curl工具",link:"/tools/curl#生成curl工具",textType:"title",routeTitle:"tools > curl",groupType:0},{text:"参考",link:"/tools/curl#参考",textType:"title",routeTitle:"tools > curl",groupType:0},{text:"管理接口文档",link:"/tools/postman#管理接口文档",textType:"title",routeTitle:"tools > postman",groupType:0},{text:"设置环境变量",link:"/tools/postman#设置环境变量",textType:"title",routeTitle:"tools > postman",groupType:0},{text:"发请求",link:"/tools/postman#发请求",textType:"title",routeTitle:"tools > postman",groupType:0},{text:"mock服务器",link:"/tools/postman#mock服务器",textType:"title",routeTitle:"tools > postman",groupType:0},{text:"自动化测试",link:"/tools/postman#自动化测试",textType:"title",routeTitle:"tools > postman",groupType:0},{text:"单个接口测试",link:"/tools/postman#单个接口测试",textType:"title",routeTitle:"tools > postman",groupType:0},{text:"集合测试",link:"/tools/postman#集合测试",textType:"title",routeTitle:"tools > postman",groupType:0},{text:"查看http报文",link:"/tools/postman#查看http报文",textType:"title",routeTitle:"tools > postman",groupType:0},{text:"查看各语言版的请求",link:"/tools/postman#查看各语言版的请求",textType:"title",routeTitle:"tools > postman",groupType:0},{text:"不会查帮助",link:"/tools/postman#不会查帮助",textType:"title",routeTitle:"tools > postman",groupType:0},{text:"参考",link:"/tools/postman#参考",textType:"title",routeTitle:"tools > postman",groupType:0},{text:"Prettier",link:"/tools/webstorm#prettier",textType:"title",routeTitle:"tools > webstorm",groupType:0},{text:"验证.prettier规则",link:"/tools/webstorm#验证-prettier规则",textType:"title",routeTitle:"tools > webstorm",groupType:0},{text:"设置webStorm代码风格",link:"/tools/代码风格#设置webstorm代码风格",textType:"title",routeTitle:"tools > 代码风格",groupType:0},{text:"editorConfig",link:"/tools/代码风格#editorconfig",textType:"title",routeTitle:"tools > 代码风格",groupType:0},{text:"http://editorconfig.org",link:"/tools/代码风格#http-editorconfig-org",textType:"title",routeTitle:"tools > 代码风格",groupType:0},{text:"说明",link:"/tools/代码风格#说明",textType:"title",routeTitle:"tools > 代码风格",groupType:0},{text:"设置文件编码为 UTF-8；",link:"/tools/代码风格#设置文件编码为-utf-8",textType:"title",routeTitle:"tools > 代码风格",groupType:0},{text:"用两个空格代替制表符；",link:"/tools/代码风格#用两个空格代替制表符",textType:"title",routeTitle:"tools > 代码风格",groupType:0},{text:"在保存时删除尾部的空白字符；",link:"/tools/代码风格#在保存时删除尾部的空白字符",textType:"title",routeTitle:"tools > 代码风格",groupType:0},{text:"在文件结尾添加一个空白行；",link:"/tools/代码风格#在文件结尾添加一个空白行",textType:"title",routeTitle:"tools > 代码风格",groupType:0},{text:"ESLint",link:"/tools/代码风格#eslint",textType:"title",routeTitle:"tools > 代码风格",groupType:0},{text:"配置规则",link:"/tools/代码风格#配置规则",textType:"title",routeTitle:"tools > 代码风格",groupType:0},{text:"Prettier",link:"/tools/代码风格#prettier",textType:"title",routeTitle:"tools > 代码风格",groupType:0},{text:"参考",link:"/tools/代码风格#参考",textType:"title",routeTitle:"tools > 代码风格",groupType:0},{text:"截长图",link:"/tools/提效工具#截长图",textType:"title",routeTitle:"tools > 提效工具",groupType:0},{text:"代码覆盖率 show Coverage",link:"/tools/谷歌开发者工具#代码覆盖率-show-coverage",textType:"title",routeTitle:"tools > 谷歌开发者工具",groupType:0},{text:"查看内存溢出",link:"/tools/谷歌开发者工具#查看内存溢出",textType:"title",routeTitle:"tools > 谷歌开发者工具",groupType:0},{text:"常用网站导航",link:"/index#常用网站导航",textType:"title",routeTitle:"index > 首页",groupType:0},{text:"vue",link:"/index#vue",textType:"title",routeTitle:"index > 首页",groupType:0},{text:"react",link:"/index#react",textType:"title",routeTitle:"index > 首页",groupType:0},{text:"blog",link:"/index#blog",textType:"title",routeTitle:"index > 首页",groupType:0},{text:"代码衡量指标",link:"/index#代码衡量指标",textType:"title",routeTitle:"index > 首页",groupType:0},{text:"前端学习方向",link:"/index#前端学习方向",textType:"title",routeTitle:"index > 首页",groupType:0},{text:"学习资源",link:"/index#学习资源",textType:"title",routeTitle:"index > 首页",groupType:0},{text:"后端文档",link:"/index#后端文档",textType:"title",routeTitle:"index > 首页",groupType:0},{text:"进阶标准规范",link:"/index#进阶标准规范",textType:"title",routeTitle:"index > 首页",groupType:0},{text:"",link:"/backend/http#http详解-基于node",textType:"text",routeTitle:"backend > http",groupType:1},{text:"http协议历史",link:"/backend/http#http协议历史",textType:"text",routeTitle:"backend > http",groupType:1},{text:"```bash GET /mypage.html <HTML> 这是一个非常简单的HTML页面 </HTML> ```",link:"/backend/http#http-0-9-–-单行协议",textType:"code",routeTitle:"backend > http",groupType:1},{text:'- 加了 Method StatusCode headers ```bash GET /mypage.html HTTP/1.0 User-Agent: NCSA_Mosaic/2.0 (Windows 3.1) 200 OK Date: Tue, 15 Nov 1994 08:12:31 GMT Server: CERN/3.0 libwww/2.17 Content-Type: text/html <HTML> 一个包含图片的页面 <IMG SRC="/myimg.gif"> </HTML> ```',link:"/backend/http#http-1-0-–-构建可扩展性",textType:"code",routeTitle:"backend > http",groupType:1},{text:"- keep-alive连接复用 - 缓存机制etag lastModified - 内容协商 - host - ...",link:"/backend/http#http-1-1-–-标准化的协议",textType:"text",routeTitle:"backend > http",groupType:1},{text:"- 二进制协议 - 多路复用 - headers压缩 - 服务器推送",link:"/backend/http#http-2",textType:"text",routeTitle:"backend > http",groupType:1},{text:"- QUIC",link:"/backend/http#http-3",textType:"text",routeTitle:"backend > http",groupType:1},{text:"http方法 restful",link:"/backend/http#http方法-restful",textType:"text",routeTitle:"backend > http",groupType:1},{text:"http状态吗",link:"/backend/http#http状态吗",textType:"text",routeTitle:"backend > http",groupType:1},{text:"header",link:"/backend/http#header",textType:"text",routeTitle:"backend > http",groupType:1},{text:"content-type",link:"/backend/http#content-type",textType:"text",routeTitle:"backend > http",groupType:1},{text:"跨域",link:"/backend/http#跨域",textType:"text",routeTitle:"backend > http",groupType:1},{text:"304",link:"/backend/http#缓存",textType:"text",routeTitle:"backend > http",groupType:1},{text:"location + 302",link:"/backend/http#重定向",textType:"text",routeTitle:"backend > http",groupType:1},{text:"认证",link:"/backend/http#认证",textType:"text",routeTitle:"backend > http",groupType:1},{text:"https",link:"/backend/http#https",textType:"text",routeTitle:"backend > http",groupType:1},{text:"",link:"/backend/http#负载均衡",textType:"text",routeTitle:"backend > http",groupType:1},{text:"```js let methods = [ 'ACL', 'BIND', 'CHECKOUT', 'CONNECT', 'COPY', 'DELETE', 'GET', 'HEAD', 'LINK', 'LOCK', 'M-SEARCH', 'MERGE', 'MKACTIVITY', 'MKCALENDAR', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS', 'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT', 'REBIND', 'REPORT', 'SEARCH', 'SOURCE', 'SUBSCRIBE', 'TRACE', 'UNBIND', 'UNLINK', 'UNLOCK', 'UNSUBSCRIBE' ] ```",link:"/backend/http#http-method",textType:"code",routeTitle:"backend > http",groupType:1},{text:"```js let HttpStatus = { '100': 'Continue', '101': 'Switching Protocols', '102': 'Processing', '103': 'Early Hints', '200': 'OK', '201': 'Created', '202': 'Accepted', '203': 'Non-Authoritative Information', '204': 'No Content', '205': 'Reset Content', '206': 'Partial Content', '207': 'Multi-Status', '208': 'Already Reported', '226': 'IM Used', '300': 'Multiple Choices', '301': 'Moved Permanently', '302': 'Found', '303': 'See Other', '304': 'Not Modified', '305': 'Use Proxy', '307': 'Temporary Redirect', '308': 'Permanent Redirect', '400': 'Bad Request', '401': 'Unauthorized', '402': 'Payment Required', '403': 'Forbidden', '404': 'Not Found', '405': 'Method Not Allowed', '406': 'Not Acceptable', '407': 'Proxy Authentication Required', '408': 'Request Timeout', '409': 'Conflict', '410': 'Gone', '411': 'Length Required', '412': 'Precondition Failed', '413': 'Payload Too Large', '414': 'URI Too Long', '415': 'Unsupported Media Type', '416': 'Range Not Satisfiable', '417': 'Expectation Failed', '418': \"I'm a Teapot\", '421': 'Misdirected Request', '422': 'Unprocessable Entity', '423': 'Locked', '424': 'Failed Dependency', '425': 'Too Early', '426': 'Upgrade Required', '428': 'Precondition Required', '429': 'Too Many Requests', '431': 'Request Header Fields Too Large', '451': 'Unavailable For Legal Reasons', '500': 'Internal Server Error', '501': 'Not Implemented', '502': 'Bad Gateway', '503': 'Service Unavailable', '504': 'Gateway Timeout', '505': 'HTTP Version Not Supported', '506': 'Variant Also Negotiates', '507': 'Insufficient Storage', '508': 'Loop Detected', '509': 'Bandwidth Limit Exceeded', '510': 'Not Extended', } ```",link:"/backend/http#http状态码",textType:"code",routeTitle:"backend > http",groupType:1},{text:"`maxHeaderSize=16384` - 不同语言实现的服务器该值不一样 - 参考 [node]()",link:"/backend/http#node默认的maxheadersize",textType:"text",routeTitle:"backend > http",groupType:1},{text:"强制缓存 from cache cache control no-cache no-store default expirse max-age 协商缓存 304 last-modifify if-modified-since Etag if-none-match",link:"/backend/http#http缓存",textType:"text",routeTitle:"backend > http",groupType:1},{text:"- 再谈HTTPS - TLS详情",link:"/backend/http#参考",textType:"text",routeTitle:"backend > http",groupType:1},{text:"- node - nest - nginx",link:"/backend/index#后端",textType:"text",routeTitle:"backend > index",groupType:1},{text:"",link:"/backend/mysql#mysql",textType:"text",routeTitle:"backend > mysql",groupType:1},{text:"show tables; show databases; use xf_live; #连上数据库 mysql -h 10.11.65.15 -uroot -p'7#8Zk&r!Y%v7N*&N'; #显示表字段 desc users; #删除外键 alter table 表名 drop foreign key 外键名字 #删除列 alter table `rooms` drop column `identity`",link:"/backend/mysql#常用命令",textType:"text",routeTitle:"backend > mysql",groupType:1},{text:"",link:"/backend/nest#next",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"Next.js 是一个使用 React 构建单页应用程序（SPA）的开源 JavaScript 框架。它使得构建服务端渲染（SSR）和静态网站生成（SSG）的 React 应用程序变得简单和高效。Next.js 由 Vercel（原 Zeit）公司开发，并且自推出以来得到了广泛的关注和使用。 Next.js 提供了一系列的特性和优势，包括但不限于： 1. **服务端渲染（SSR）**：每次页面请求时，都在服务器上实时渲染页面，这有助于提高首屏加载速度并改善搜索引擎优化（SEO）。 2. **静态网站生成（SSG）**：在构建时生成静态的 HTML 页面，可以部署到任何静态网站托管服务上，进一步提高性能和扩展性。 3. **文件系统路由**：Next.js 通过 `/pages` 目录中的文件结构自动创建路由，每个 React 组件文件对应一个路由。 4. **自动代码拆分**：Next.js 会自动对每个页面进行代码拆分，只加载当前页面所需的代码，这有助于减少页面的加载时间。 5. **API 路由**：可以在 `/pages/api` 目录下创建 API 路由，方便构建 API 接口。 6. **内置 CSS 和 Sass 支持**：Next.js 支持 CSS Modules，并内置了对 CSS-in-JS 库的支持，同时也支持预处理器如 Sass。 7. **开箱即用的 TypeScript 支持**：Next.js 提供了对 TypeScript 的内置支持，无需额外的配置。 8. **插件生态系统**：社区提供了大量的 Next.js 插件，可以很容易地扩展应用的功能。 Next.js 的开发体验通常被认为是它的主要优点之一，因为它简化了许多传统上需要手动配置的部分，例如路由和代码拆分。这使得开发者可以专注于编写应用逻辑，而不是花费过多时间在构建配置上。由于其灵活性和性能，Next.js 已经被许多企业用于构建生产级的网站和应用。",link:"/backend/nest#_1-next-js",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"首次发布于 2016 年。它的诞生背景是基于开发者和企业对构建更快、更优化的 Web 应用程序的需求，特别是在服务端渲染（SSR）和搜索引擎优化（SEO）方面。React 本身是一个客户端渲染的库，这意味着 JavaScript 需要在用户的浏览器中运行才能生成 HTML 内容。这种模式在用户体验和性能上存在一些挑战，尤其是对首屏加载时间和 SEO 不友好。 Next.js 主要解决了以下问题： 1. **SEO 和首屏加载性能**： 传统的客户端渲染的 React 应用可能不利于搜索引擎爬虫的抓取，且首次加载时间较长。Next.js 提供服务端渲染作为默认行为，这意味着页面在服务器上被渲染为 HTML，然后发送给客户端。这样做可以显著提升首屏加载速度，并对搜索引擎优化友好。 2. **开发效率**： 在使用 React 开发大型应用时，开发者通常需要配置路由、代码拆分、构建优化等。Next.js 通过约定大于配置的方式，减少了这些常见任务的手动设置，提供了简易的文件系统路由、自动的代码拆分和热加载，提高了开发效率。 3. **构建和部署**： Next.js 提供现成的构建系统和对持续集成的优化，使得将应用从开发阶段迁移到生产变得简单。此外，与 Vercel 平台的无缝集成也让部署变得异常轻松。 4. **灵活的数据获取策略**： Next.js 提供了灵活的数据获取方法，如 `getStaticProps` 和 `getServerSideProps`，使得开发者可以根据页面的需求选择不同的数据预渲染策略，例如静态生成或服务器端渲染。 5. **无需额外设置的 TypeScript 支持**： Next.js 从一开始就考虑了对 TypeScript 的支持，让开发者能够享受到强类型语言带来的好处，而无需复杂的配置。 6. **API 路由**： Next.js 允许开发者在同一个项目中构建前端页面和 API 接口，简化了全栈应用的开发过程。 7. **生态系统和社区支持**： Next.js 随着时间的推移建立起了一个健康的插件生态系统，并且得到了强大的社区支持，这为开发者提供了各种资源和第三方库的集成。 总之，Next.js 的出现是为了简化和优化基于 React 的应用开发流程，同时提供了高性能和 SEO 友好的解决方案，它代表了当代 Web 应用开发的一个重要趋势。",link:"/backend/nest#_2-诞生背景",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"安装 Next.js 非常简单，主要有两种方式：使用 `create-next-app` 脚手架来创建新项目，或者手动添加到现有的 React 项目中。以下是安装 Next.js 的步骤：",link:"/backend/nest#_3-安装",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"1. 使用 `npx`（`npm` 的包执行工具）执行以下命令来创建一个新的 Next.js 应用。这会自动下载 `create-next-app` 并创建一个新的项目。 ```bash npx create-next-app my-next-app ``` 2. 进入项目目录： ```bash cd my-next-app ``` 3. 启动开发服务器： ```bash npm run dev ``` 或者，如果你使用的是 `yarn`： ```bash yarn dev ``` 这样，你的 Next.js 应用就会在 `localhost:3000` 上启动，你可以在浏览器中访问它。",link:"/backend/nest#使用-create-next-app-创建新项目",textType:"code",routeTitle:"backend > nest",groupType:1},{text:'如果你已经有一个 React 项目，你可以通过安装以下几个包来将其转换为 Next.js 项目： ```bash npm install next react react-dom ``` 或者，如果你使用 `yarn`： ```bash yarn add next react react-dom ``` 之后，你需要在 `package.json` 中添加几个脚本来启动 Next.js： ```json "scripts": { "dev": "next", "build": "next build", "start": "next start" } ```',link:"/backend/nest#手动添加到现有的-react-项目",textType:"code",routeTitle:"backend > nest",groupType:1},{text:"Next.js 有一个约定优于配置的原则，这意味着项目的基本目录结构和工作方式已经被预设好了。以下是 Next.js 应用的常见目录结构： ``` my-next-app/ |-- pages/ | |-- index.js # 主页 | |-- _app.js # 可选的 App 组件，用于初始化页面 | `-- [其他页面].js |-- public/ # 静态文件放置目录，如图片、favicon 等 |-- styles/ # 样式文件目录 |-- node_modules/ # 项目依赖目录 |-- package.json # 项目依赖和脚本配置文件 |-- next.config.js # 可选的 Next.js 配置文件 `-- [其他配置文件] ``` - `pages/`：这是存放页面组件的目录，每个文件都会自动对应一个路由。例如，`pages/about.js` 会对应 `/about` 这个路由。 - `public/`：用于存放静态资源，如图片、字体等，这些文件可以直接通过 `/` 路径在浏览器中访问。 - `styles/`：保存 CSS 文件的地方，你可以根据需要组织你的样式文件。 - `node_modules/`：存放所有安装的依赖包。 - `package.json`：定义了项目的依赖和可运行的脚本。 - `next.config.js`：可选的配置文件，用于自定义 Next.js 的高级配置，比如添加环境变量、修改构建的 Webpack 配置等。 通过这种目录结构，Next.js 提供了一个强大且灵活的框架，允许开发者迅速启动项目并按需进行扩展。",link:"/backend/nest#next-js-的基本目录和工作结构",textType:"code",routeTitle:"backend > nest",groupType:1},{text:"1. `pages/index.tsx` 或 `pages/index.js` 这是 Next.js 应用程序的默认入口页面，也就是访问站点根 URL（如 `http://localhost:3000/`）时加载的页面。使用 TypeScript 编写时后缀为 `.tsx`，纯 JavaScript 时为 `.js`。 2. `pages/_app.tsx` 或 `pages/_app.js` 这是 Next.js 中的一个特殊文件，它允许你初始化所有页面。你可以使用这个文件来保持页面布局，保持状态（如 Redux 或 MobX）时使用，或者用于全局 CSS 的插入。这个文件是可选的，如果你的应用不需要全局初始化，则不需要创建它。 3. `pages/_document.tsx` 或 `pages/_document.js` `_document` 也是一个特殊文件，用于自定义文档结构。Next.js 会使用这个文件来渲染网站的 HTML 结构。默认情况下，Next.js 为你生成文档结构，但如果你需要自定义 `<html>` 和 `<body>` 标签或在 `<head>` 中添加额外的链接和脚本，你可以通过创建 `_document` 文件来实现。这个文件也是可选的，只有在需要自定义整个 HTML 页面结构时才需要它。 4. `app/layout.tsx` 或 `app/layout.js` `layout` 文件并不是 Next.js 的特定组件或约定。但在开发过程中，通常会创建一个 `Layout` 组件来封装页面结构，比如包含导航栏和页脚的共享布局。此组件可以在不同页面中复用，以便保持一致的外观和行为。通常，开发者会根据项目需要自行创建和组织 `Layout` 组件。 5. `app/page.tsx` 或 `app/page.js` 这同样不是 Next.js 的特定组件或约定。它可能是开发者根据项目需要自定义的一个组件或页面逻辑。在实际的 Next.js 项目中，你可能不会看到这个文件，除非团队有特定的组织结构或命名习惯。 工作流程如下： - 当用户访问网站时，Next.js 会根据请求的路径查找 `pages` 目录中相应的页面组件。 - 如果存在 `_app` 文件，Next.js 会使用它来初始化所有页面，你可以在这里插入全局样式或共享组件。 - 如果存在 `_document` 文件，Next.js 会使用它来构建 HTML 文档结构。这只会在服务器端渲染时发生，且仅用于初始页面加载。 - 如果你使用了 `Layout` 组件，通常会在 `_app` 文件中引入并包裹页面内容，从而为你的页面提供统一的布局。 在实际的 Next.js 应用中，你可能会根据实际的需要添加或省略这些文件。例如，对于一个简单的项目，你可能只需要 `pages/index.tsx` 文件。对于复杂一点的项目，可能会加入 `_app.tsx` 和 `_document.tsx` 来进行全局布局和文档结构的自定义。其他如 `app/layout.tsx` 或 `app/page.tsx` 这样的文件则更多取决于你个人或团队的项目结构和组件组织方式。",link:"/backend/nest#最小工作流程",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"本页面提供了 Next.js 应用程序的项目结构概览。它涵盖了顶层文件和文件夹、配置文件，以及在 `app` 和 `pages` 目录内的路由约定。 点击文件和文件夹名称以了解每个约定的更多信息。",link:"/backend/nest#_4-目录结构",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"顶层文件夹用于组织应用程序的代码和静态资源。 - `app` - 应用路由器 - `pages` - 页面路由器 - `public` - 将要提供服务的静态资源 - `src` - 可选的应用源代码文件夹",link:"/backend/nest#顶层文件夹",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"顶层文件用于配置应用程序，管理依赖项，运行中间件，集成监控工具，以及定义环境变量。",link:"/backend/nest#顶层文件",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"- `next.config.js` - Next.js 的配置文件 - `package.json` - 项目依赖和脚本 - `instrumentation.ts` - OpenTelemetry 和检测文件 - `middleware.ts` - Next.js 请求中间件 - `.env` - 环境变量 - `.env.local` - 本地环境变量 - `.env.production` - 生产环境变量 - `.env.development` - 开发环境变量 - `.eslintrc.json` - ESLint 的配置文件 - `.gitignore` - Git 忽略的文件和文件夹 - `next-env.d.ts` - Next.js 的 TypeScript 声明文件 - `tsconfig.json` - TypeScript 的配置文件 - `jsconfig.json` - JavaScript 的配置文件",link:"/backend/nest#next-js",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"以下文件约定用于在应用路由器中定义路由和处理元数据。",link:"/backend/nest#app-路由约定",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"- `layout` `.js .jsx .tsx` - 布局 - `page` `.js .jsx .tsx` - 页面 - `loading` `.js .jsx .tsx` - 加载 UI - `not-found` `.js .jsx .tsx` - 未找到页面 UI - `error` `.js .jsx .tsx` - 错误 UI - `global-error` `.js .jsx .tsx` - 全球错误 UI - `route` `.js .ts` - API 端点 - `template` `.js .jsx .tsx` - 重新渲染的布局 - `default` `.js .jsx .tsx` - 平行路由备用页面",link:"/backend/nest#路由文件",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"- `folder/` - 路由片段 - `folder/folder/` - 嵌套路由片段",link:"/backend/nest#嵌套路由",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"- `[folder]` - 动态路由片段 - `[...folder]` - 捕获所有路由片段 - `[[...folder]]` - 可选的捕获所有路由片段",link:"/backend/nest#动态路由",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"- `(folder)` - 不影响路由的路由组 - `_folder` - 让该文件夹及其所有子片段退出路由",link:"/backend/nest#路由组和私有文件夹",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"- `@folder` - 命名插槽 - `(.)folder` - 拦截同一层级 - `(..)folder` - 拦截上一层级 - `(..)(..)folder` - 拦截两层以上 - `(...)folder` - 从根部拦截",link:"/backend/nest#平行路由和拦截路由",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"",link:"/backend/nest#元数据文件约定",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"- `favicon` `.ico` - 网站图标文件 - `icon` `.ico .jpg .jpeg .png .svg` - 应用图标文件 - `icon` `.js .ts .tsx` - 生成的应用图标 - `apple-icon` `.jpg .jpeg .png` - Apple 应用图标文件 - `apple-icon` `.js .ts .tsx` - 生成的 Apple 应用图标",link:"/backend/nest#应用图标",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"- `opengraph-image` `.jpg .jpeg .png .gif` - Open Graph 图片文件 - `opengraph-image` `.js .ts .tsx` - 生成的 Open Graph 图片 - `twitter-image` `.jpg .jpeg .png .gif` - Twitter 图片文件 - `twitter-image` `.js .ts .tsx` - 生成的 Twitter 图片",link:"/backend/nest#open-graph-和-twitter-图片",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"- `sitemap` `.xml` - 网站地图文件 - `sitemap` `.js .ts` - 生成的网站地图 - `robots` `.txt` - 机器人文件 - `robots` `.js .ts` - 生成的机器人文件",link:"/backend/nest#seo",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"以下文件约定用于在页面路由器中定义路由。",link:"/backend/nest#pages-路由约定",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"- `_app` `.js .jsx .tsx` - 自定义应用程序 - `_document` `.js .jsx .tsx` - 自定义文档 - `_error` `.js .jsx .tsx` - 自定义错误页面 - `404` `.js .jsx .tsx` - 404 错误页面 - `500` `.js .jsx .tsx` - 500 错误页面",link:"/backend/nest#特殊文件",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"",link:"/backend/nest#路由",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"- `index` `.js .jsx .tsx` - 主页 - `folder/index` `.js .jsx .tsx` - 嵌套页面",link:"/backend/nest#文件夹约定",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"- `index` `.js .jsx .tsx` - 主页 - `file` `.js .jsx .tsx` - 页面文件",link:"/backend/nest#文件约定",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"",link:"/backend/nest#动态路由-1",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"- `[folder]/index` `.js .jsx .tsx` - 动态路由片段 - `[...folder]/index` `.js .jsx .tsx` - 捕获所有路由片段 - `[[...folder]]/index` `.js .jsx .tsx` - 可选的捕获所有路由片段",link:"/backend/nest#文件夹约定-1",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"- `[file]` `.js .jsx .tsx` - 动态路由片段 - `[...file]` `.js .jsx .tsx` - 捕获所有路由片段 - `[[...file]]` `.js .jsx .tsx` - 可选的捕获所有路由片段",link:"/backend/nest#文件约定-1",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"Next.js 拥有两种不同的路由器：App Router 和 Pages Router。App Router 是一种较新的路由器，它允许你使用 React 的最新特性，例如服务器组件（Server Components）和流式传输（Streaming）。Pages Router 是原始的 Next.js 路由器，它允许你构建服务端渲染（Server-Rendered）的 React 应用程序，并且继续支持旧版本的 Next.js 应用程序。",link:"/backend/nest#_5-路由",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"`pages` 目录是 Next.js 最初提供的默认路由机制。在这个目录下，文件系统被用作路由器的基础，即每个文件（除了一些特殊的文件如 `_app.js` 或 `_document.js`）都会自动映射到一个 URL 路径上。例如： - `pages/index.js` 映射到站点的根 URL (`/`)。 - `pages/about.js` 映射到 `/about`。 - `pages/posts/[id].js` 映射到一个动态路由，如 `/posts/1`。 这种方式可以快速创建新页面，并且无需手动配置路由。",link:"/backend/nest#pages-路由器-pages-router",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"随着 Next.js 12 的发布，`app` 路径（目前处于实验阶段）引入了一个新的路由系统，它提供了更灵活的路由定义方式，包括对路由组、布局、加载状态、错误处理和并行路由等的支持。`app` 目录允许开发者使用文件和文件夹来定义路由，同时也可以用各种新的文件命名约定来控制路由行为。例如： - `app/page.js` 是一个页面。 - `app/layout.js` 是一个布局，可以被包含在多个页面中。 - `app/loading.js` 定义了加载状态的 UI。 - `app/404.js` 提供了一个404错误页面。 - `app/(users)/[id].js` 创建了一个路由组。 使用 `app` 路由器，你可以更细致地控制应用的路由和渲染行为，更好地组织代码逻辑。",link:"/backend/nest#app-路由器-app-router",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"",link:"/backend/nest#_6-示例",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"当然，这里给出一个使用 Next.js 的示例，展示如何在前端页面与后端 API 接口之间进行调用。",link:"/backend/nest#_6-1-前后端接口声明-调用",textType:"text",routeTitle:"backend > nest",groupType:1},{text:'首先，你需要在 Next.js 的 `pages/api` 目录下创建一个 API 接口。这将使得 Next.js 为你自动处理 API 路由。例如，创建一个简单的 API 接口来获取用户数据。 在 `pages/api/user.js` 文件中： ```javascript // Example of a simple API handler in Next.js export default function handler(req, res) { // Here you would fetch user data from a database or another API const user = { id: 1, name: "John Doe", email: "john@example.com", }; // Return user data as JSON res.status(200).json(user); } ```',link:"/backend/nest#_1-创建后端-api-接口",textType:"code",routeTitle:"backend > nest",groupType:1},{text:'接着，在前端页面中调用上述 API。你可以使用 `fetch` API 或者其他 HTTP 客户端库，如 `axios`，来进行 API 调用。 在 `pages/index.js` 文件中： ```javascript import { useEffect, useState } from "react"; export default function Home() { const [user, setUser] = useState(null); useEffect(() => { // Fetch the user data from the API async function fetchUserData() { const response = await fetch("/api/user"); const userData = await response.json(); setUser(userData); } fetchUserData(); }, []); // The empty array causes this effect to only run on mount // Render user data if available return ( <div> <h1>User Profile</h1> {user ? ( <div> <p>Name: {user.name}</p> <p>Email: {user.email}</p> </div> ) : ( <p>Loading...</p> )} </div> ); } ``` 在本例中，当页面加载时，`useEffect` 钩子会触发，并执行 `fetchUserData` 函数来获取用户数据。数据被成功获取后，它会更新状态 `user`，并重新渲染页面以显示用户的信息。如果数据尚未加载完成，则会显示 "Loading..."。 请注意，这里的 API 调用是指向相对路径 `/api/user`，这是因为 Next.js 会自动处理这个路径到我们在 `pages/api/user.js` 中定义的 API 接口。',link:"/backend/nest#_2-前端页面调用-api-接口",textType:"code",routeTitle:"backend > nest",groupType:1},{text:"要实现一个完整的登录示例，包括登录后的鉴权、登录态保持和退出机制，在 Next.js 中通常会涉及到 API 路由、Cookies 或者其他存储方式以及前端状态管理。以下是一个简化的示例：",link:"/backend/nest#_6-2-登录场景",textType:"text",routeTitle:"backend > nest",groupType:1},{text:'在 `pages/api/login.js` 文件中，我们创建一个处理登录请求的 API： ```javascript // Example of a login API handler in Next.js export default function handler(req, res) { if (req.method === "POST") { const { username, password } = req.body; // 这里应该有身份验证逻辑。例如，检查用户名和密码是否匹配。 // 为简化示例，我们假设任何用户名和密码组合都是有效的。 if (username && password) { // 登录成功，设置 Cookie 以保持登录状态 res.setHeader("Set-Cookie", "token=valid-token; path=/; HttpOnly"); res.status(200).json({ message: "登录成功" }); } else { // 登录失败 res.status(401).json({ message: "登录失败" }); } } else { // 不支持除 POST 之外的方法 res.setHeader("Allow", "POST"); res.status(405).end(`Method ${req.method} Not Allowed`); } } ``` 在上述代码中，我们仅接受 POST 请求，并简单地假设所有的登录尝试都是有效的。在实际应用中，你需要添加真实的身份验证逻辑并安全地处理密码。',link:"/backend/nest#_1-创建登录-api-接口",textType:"code",routeTitle:"backend > nest",groupType:1},{text:'在前端，你需要一个表单来收集用户的用户名和密码，然后将这些信息发送到登录 API。 在 `pages/login.js` 文件中： ```javascript import { useState } from "react"; import Router from "next/router"; export default function Login() { const [username, setUsername] = useState(""); const [password, setPassword] = useState(""); const handleSubmit = async (event) => { event.preventDefault(); const response = await fetch("/api/login", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ username, password }), }); if (response.ok) { // 登录成功，跳转到受保护的页面 Router.push("/profile"); } else { // 登录失败，显示错误消息 alert("登录失败"); } }; return ( <form onSubmit={handleSubmit}> <label> 用户名: <input type="text" value={username} onChange={(e) => setUsername(e.target.value)} /> </label> <label> 密码: <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} /> </label> <button type="submit">登录</button> </form> ); } ``` 在这个登录表单中，我们收集用户名和密码，然后将其作为 JSON 发送到登录 API。如果登录成功，我们会重定向用户到受保护的个人资料页面。',link:"/backend/nest#_2-创建前端登录页面",textType:"code",routeTitle:"backend > nest",groupType:1},{text:'登录状态通常由服务器通过设置 HTTP Cookie 来保持。在上述登录 API 中，我们设置了一个名为 \'token\' 的 Cookie。你可以在服务器上验证此 Cookie 以确认用户是否登录。 退出登录只需删除或清空 Cookie 即可。创建一个退出 API 接口： 在 `pages/api/logout.js` 文件中： ```javascript // Example of a logout API handler in Next.js export default function handler(req, res) { // 删除登录 Cookie res.setHeader( "Set-Cookie", "token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT" ); res.status(200).json({ message: "已退出登录" }); } ``` 然后在前端添加一个退出登录的按钮： ```javascript import Router from "next/router"; export default function LogoutButton() { const handleLogout = async () => { const response = await fetch("/api/logout", { method: "POST" }); if (response.ok) { // 退出登录成功，重定向到首页 Router.push("/"); } }; return <button onClick={handleLogout}>退出登录</button>; } ```',link:"/backend/nest#_3-登录态保持和退出登录机制",textType:"code",routeTitle:"backend > nest",groupType:1},{text:'对于登录后的鉴权，你需要在服务端检查请求中是否包含有效的登录态（例如，检查 token Cookie）。对于需要鉴权的 API，你可以添加逻辑来确保只有已登录的用户才能访问： 在 `pages/api/protected.js` 文件中： ```javascript // Example of a protected API handler in Next.js export default function handler(req, res) { // 检查 token Cookie const { token } = req.cookies; if (token === "valid-token") { // 用户已登录，可以访问受保护的资源 res.status(200).json({ data: "受保护的数据" }); } else { // 用户未登录或 token 无效 res.status(401).json({ message: "未授权" }); } } ``` 在实际应用中，你会使用更复杂的逻辑来生成和验证 token，可能还会使用刷新 token 机制等。 请记住，这只是一个简化的登录示例。在实际项目中，你应该为所有敏感操作使用 HTTPS 来保护数据的安全，确保 cookie 的安全设置，比如使用 `Secure` 和 `SameSite` 属性，并对密码进行哈希处理和加盐等安全措施。此外，你可能还需要考虑使用第三方认证服务，如 Auth0、Firebase Auth 或 NextAuth.js，它们为身份验证和会话管理提供了更鲁棒的解决方案。',link:"/backend/nest#_4-登录后的鉴权",textType:"code",routeTitle:"backend > nest",groupType:1},{text:"Next.js 的 API 路由允许你创建可以被其他域访问的接口服务。你可以创建无服务器函数（Serverless Functions）来处理 HTTP 请求，并通过设置适当的 CORS（跨源资源共享）策略，允许其他域名的请求访问你的 API。 以下是创建可以被其他域访问的 API 路由的步骤：",link:"/backend/nest#_6-3-接口平台场景",textType:"text",routeTitle:"backend > nest",groupType:1},{text:'在 `/pages/api` 目录下创建一个新的 `.js` 文件来定义你的 API 路由，例如 `hello.js`。 ```javascript // pages/api/hello.js export default function handler(req, res) { res.status(200).json({ message: "Hello World!" }); } ```',link:"/backend/nest#步骤-1-创建-api-路由",textType:"code",routeTitle:"backend > nest",groupType:1},{text:'在你的 API 路由文件中，你可以使用 `Next.js` 提供的 `micro-cors` 或手动设置 HTTP 头来实现跨域资源共享。下面是一个手动设置 HTTP 头的示例： ```javascript // pages/api/hello.js export default function handler(req, res) { // 设置 CORS 头 res.setHeader("Access-Control-Allow-Credentials", true); res.setHeader("Access-Control-Allow-Origin", "*"); // 或者你可以指定允许的域名 res.setHeader( "Access-Control-Allow-Methods", "GET,OPTIONS,PATCH,DELETE,POST,PUT" ); res.setHeader( "Access-Control-Allow-Headers", "X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version" ); // 如果是 OPTIONS 请求，返回204 \'No Content\' if (req.method === "OPTIONS") { res.status(204).end(); return; } // 其他请求，如 GET，处理并返回相应的数据 res.status(200).json({ message: "Hello World!" }); } ``` 这样设置后，你的 API 现在可以接受跨域请求。`Access-Control-Allow-Origin` 头部决定了哪些源可以访问资源。如果你想要限制特定的域名而非所有域都可以访问，可以将 `\'*\'` 替换为具体的源地址。',link:"/backend/nest#步骤-2-设置-cors",textType:"code",routeTitle:"backend > nest",groupType:1},{text:"如果你已经有一个自己的服务器，并配置了 Node.js 环境，那么部署 Next.js 应用会相对简单。以下是在你自己的服务器上部署 Next.js 应用的步骤：",link:"/backend/nest#_7-部署",textType:"text",routeTitle:"backend > nest",groupType:1},{text:"首先，在你的本地开发环境中构建 Next.js 应用。这将生成 `.next` 目录，其中包含了用于生产环境的优化过的应用版本。 ```bash next build ```",link:"/backend/nest#步骤-1-构建应用",textType:"code",routeTitle:"backend > nest",groupType:1},{text:"在服务器上，导航到应用的目录，运行 `npm install` 或 `yarn` 来安装依赖（如果你没有一同上传 `node_modules` 目录）。 ```bash cd /path/to/your/app npm install ```",link:"/backend/nest#步骤-2-安装依赖",textType:"code",routeTitle:"backend > nest",groupType:1},{text:"使用 `next start` 来启动你的应用。该命令将会启动一个 Node.js 服务器，该服务器提供了生产环境下的 HTTP 服务。 ```bash next start -p YOUR_PORT ``` 其中 `YOUR_PORT` 是你希望应用运行的端口号（如80，443，3000等）。如果你不指定端口，Next.js 默认会使用 3000 端口。",link:"/backend/nest#步骤-3-启动应用",textType:"code",routeTitle:"backend > nest",groupType:1},{text:'在生产环境中，你可能会希望应用能够在后台运行，并在崩溃时自动重启。这时你可以使用进程管理器如 `pm2`。如果你还没有 `pm2`，可以通过 npm 安装它： ```bash npm install pm2 -g ``` 然后，使用 `pm2` 启动你的 Next.js 应用： ```bash pm2 start "next start -p YOUR_PORT" --name "nextjs-app" ``` 这将启动你的应用，并允许 `pm2` 来管理它。',link:"/backend/nest#步骤-4-使用进程管理器-可选",textType:"code",routeTitle:"backend > nest",groupType:1},{text:'如果你的应用依赖于环境变量，确保在服务器上设置这些环境变量。你可以在服务器的 `.bashrc`、`.profile` 或其他适用于你的 shell 的配置文件中设置环境变量，或者在启动应用时直接设置： ```bash ENV_VAR1=value1 ENV_VAR2=value2 pm2 start "next start -p YOUR_PORT" --name "nextjs-app" ```',link:"/backend/nest#步骤-5-设置环境变量-可选",textType:"code",routeTitle:"backend > nest",groupType:1},{text:"如果你在服务器上运行了 Nginx 或 Apache，你可能想要设置一个反向代理，将来自外部的请求转发到 Next.js 应用的端口上。这样可以让你使用 SSL，自定义域名，以及其他高级功能。 这是一个简单的 Nginx 反向代理配置示例： ```nginx server { listen 80; server_name yourdomain.com; location / { proxy_pass http://localhost:YOUR_PORT; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } } ```",link:"/backend/nest#步骤-6-反向代理设置-可选",textType:"code",routeTitle:"backend > nest",groupType:1},{text:"",link:"/backend/node#node",textType:"text",routeTitle:"backend > node",groupType:1},{text:"- 可读性 (代码结构优雅，好维护) - 同构统一（写法不变兼容各种情况） - 可扩展性（添加新需求不用改原来代码） - 稳定性 (可抗住大规模测试和并发测试) - 高效 (秒杀)",link:"/backend/node#代码质量衡量标注",textType:"text",routeTitle:"backend > node",groupType:1},{text:"",link:"/backend/node#高并发、高扩展、高可用",textType:"text",routeTitle:"backend > node",groupType:1},{text:"",link:"/backend/node#pwa-快应用-小程序对比",textType:"text",routeTitle:"backend > node",groupType:1},{text:"| | 小程序 | pwa | 快应用 | H5 || 提出者 | 腾讯 | Google | 国内手机厂商 | w3c | | 发展现状 | 国内牛逼 | 国内不行 | 国内有苗头 | 主流 | | 原理 | 混合渲染webview + 原生 | webview渲染（web增强版） | 原生渲染 | webview渲染 | | 优缺点 | 可以使用微信账号、支付功能 | 离线时需要登录不能用 | | 性能体验要差一点，权限支持不好 | - 性能上 原生渲染>混合渲染>webview渲染",link:"/backend/node#对比",textType:"text",routeTitle:"backend > node",groupType:1},{text:"技术服务于商业，或为抢占市场、或为政治原因 - 国外搞pwa - 微信搞小程序 - 国内搞快应用",link:"/backend/node#从商业角度看技术",textType:"text",routeTitle:"backend > node",groupType:1},{text:"- 快应用和pwa有什么不同？ - 支持PWA(Progressive Web Apps) 的网站都有哪些？",link:"/backend/node#参考",textType:"text",routeTitle:"backend > node",groupType:1},{text:"",link:"/backend/使用PM2实现高效的应用监控与管理#使用pm2实现高效的应用监控与管理",textType:"text",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"PM2 是一个流行的进程管理器，用于 Node.js 应用程序。它支持应用程序的负载均衡、自动重启、日志管理、监控以及多环境管理等功能。PM2让开发者能够以守护进程的方式运行和管理 Node.js 应用，即使在应用崩溃或服务器重启后也能自动重启应用。这使得 PM2非常适合在生产环境中部署 Node.js 应用。除此之外，PM2还支持应用的零停机更新，以及对 Docker 容器的支持。",link:"/backend/使用PM2实现高效的应用监控与管理#_1-pm2",textType:"text",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"PM2 的诞生背景主要是为了解决 Node.js 应用程序在生产环境中的运维问题。在 PM2出现之前，Node.js 开发者经常面临如何有效管理和维持应用稳定运行的挑战，特别是在应对应用崩溃、服务器重启或是负载均衡等方面。 PM2的主要目标是提供一个简单而强大的工具，帮助开发者和系统管理员在生产环境中管理和维护 Node.js 应用。它解决的关键问题包括： 1. **自动重启**: 如果 Node.js 应用崩溃或由于某种原因停止，PM2可以自动重启应用，确保服务的持续可用性。 2. **负载均衡**: PM2支持集群模式，能够启动多个应用实例，并在它们之间自动分配负载，提高应用的可伸缩性和可用性。 3. **无停机更新**: PM2允许开发者在不停止当前服务的情况下，更新 Node.js 应用到新的版本，这对于需要24/7运行的服务来说非常重要。 4. **日志管理**: PM2提供了日志管理的功能，使得跟踪和调试生产环境中的应用更为便捷。 5. **监控**: PM2包含了一个监控系统，可以实时查看应用的 CPU 和内存使用情况，帮助开发者优化应用性能。",link:"/backend/使用PM2实现高效的应用监控与管理#_2-诞生背景",textType:"text",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"执行以下命令来全局安装 PM2。全局安装意味着你可以在任何地方运行 PM2命令。 ```bash npm install pm2 -g ``` 这条命令会将 PM2安装到你的系统上，`-g` 参数表示全局安装，这样你就可以在任何目录下使用 PM2命令。 安装完成后，你可以运行以下命令来检查 PM2是否正确安装： ```bash pm2 --version ```",link:"/backend/使用PM2实现高效的应用监控与管理#_2-安装",textType:"code",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"| 命令 | 描述 | 使用示例及参数 || `start` | 启动应用 | `pm2 start app.js`<br>`pm2 start app.js -i 4 --name myApp`<br>`pm2 start app.js --watch` | | `stop` | 停止应用 | `pm2 stop app.js`<br>`pm2 stop 0`<br>`pm2 stop all` | | `restart` | 重启应用 | `pm2 restart app.js`<br>`pm2 restart all` | | `delete` | 删除应用 | `pm2 delete app.js`<br>`pm2 delete 0`<br>`pm2 delete all` | | `list` | 列出所有应用 | `pm2 list` | | `monit` | 监控应用 | `pm2 monit` | | `logs` | 查看应用日志 | `pm2 logs`<br>`pm2 logs app.js`<br>`pm2 logs --lines 100` | | `save` | 保存当前应用列表 | `pm2 save` | | `reload` | 重载应用 | `pm2 reload app.js`<br>`pm2 reload all` | | `scale` | 调整集群模式下的实例数量 | `pm2 scale app +1`<br>`pm2 scale app 4` | | `describe` | 查看应用详细信息 | `pm2 describe 0` | | `update` | 更新 PM2守护进程 | `pm2 update` | | `status` | 查看应用状态 | `pm2 status` | | `flush` | 清空所有日志文件 | `pm2 flush` | | `startup` | 创建开机自启动脚本 | `pm2 startup` | | `unstartup` | 删除开机自启动脚本 | `pm2 unstartup` |",link:"/backend/使用PM2实现高效的应用监控与管理#_3-常用命令",textType:"text",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"PM2的配置文件通常被称为`ecosystem.config.js`，这是一个 JavaScript 文件，允许你配置和管理应用程序的多个方面。通过使用配置文件，你可以轻松地指定环境变量、日志文件路径、实例数量等，并且可以一次性启动多个应用。下面详细介绍如何使用 PM2配置文件。",link:"/backend/使用PM2实现高效的应用监控与管理#_4-配置文件",textType:"text",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:'PM2的`ecosystem.config.js`文件基本结构如下： ```javascript module.exports = { apps: [ { name: "app1", // 应用程序名称 script: "./app.js", // 主脚本路径 args: "arg1 arg2", // 传递给脚本的参数 instances: 4, // 应用实例数 autorestart: true, // 自动重启 watch: false, // 监控文件变动 max_memory_restart: "1G", // 内存超过1G 重启 env: { // 环境变量 NODE_ENV: "development", }, env_production: { // 生产环境变量 NODE_ENV: "production", }, }, { name: "app2", script: "./app2.js", // 其他配置... }, ], }; ```',link:"/backend/使用PM2实现高效的应用监控与管理#基本结构",textType:"code",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"- **apps**: 一个数组，包含了你要运行的应用的配置对象。 - **name**: 应用程序的名称。 - **script**: 应用程序的启动脚本或文件。 - **args**: 传递给脚本的参数。 - **instances**: 启动应用实例的数量。对于无状态的应用，可以设置为`max`以根据 CPU 核心数量来启动最大实例数。 - **autorestart**: 如果应用崩溃或者停止，是否自动重启。 - **watch**: 是否启用文件监控和自动重启。 - **max_memory_restart**: 当应用超过指定内存量时自动重启。 - **env**: 在这个对象中，你可以指定传递给应用的环境变量。这些环境变量在所有环境下都会加载。 - **env_production**, **env_development**: 你可以为不同的环境指定不同的环境变量。",link:"/backend/使用PM2实现高效的应用监控与管理#主要字段解释",textType:"text",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"1. **启动应用**: 使用配置文件启动应用时，运行如下命令： ```bash pm2 start ecosystem.config.js ``` 2. **指定环境**: 如果你有为不同环境定义的变量，可以在启动时指定： ```bash pm2 start ecosystem.config.js --env production ``` 这将使用`env_production`中定义的环境变量。 3. **管理应用**: 一旦应用启动，你可以使用 PM2的标准命令来管理它们，例如`pm2 stop`, `pm2 restart`, 和`pm2 delete`。 配置文件为应用部署提供了强大而灵活的管理方式，特别是当你需要部署多个应用或需要为应用指定特定的环境变量和配置时。通过精心设计的配置文件，你可以确保应用的部署更加一致和可预测。",link:"/backend/使用PM2实现高效的应用监控与管理#使用配置文件",textType:"code",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:'如果你不使用配置文件，而是选择直接使用 PM2的 CLI 命令来实现上面提到的功能，可以通过在命令行中添加特定的选项和参数来完成。下面是如何通过 CLI 命令实现配置文件中提到的一些主要功能： 1. **启动应用并传递参数**: ```bash pm2 start app.js --name "app1" -- arg1=value1 arg2=value2 ``` 这里`--name "app1"`设定了应用的名称，`-- arg1 arg2`向应用传递了参数。 2. **指定实例数量**: ```bash pm2 start app.js -i 4 ``` 该命令启动了4个应用实例。如果你想要根据 CPU 核心数量来启动最大实例数，可以使用`-i max`。 3. **启用自动重启**: 自动重启是 PM2的默认行为，无需特别指定。 4. **启用文件监控**: ```bash pm2 start app.js --watch ``` 这会监控应用目录中文件的变动，并在变动时自动重启应用。 5. **限制内存重启**: ```bash pm2 start app.js --max-memory-restart 1G ``` 当应用消耗的内存超过1GB 时，PM2将自动重启应用。 6. **设置环境变量**: 你可以在启动命令中直接设置环境变量： ```bash NODE_ENV=development pm2 start app.js ``` 或者，为了同时设置多个环境变量，可以使用： ```bash pm2 start app.js --env NODE_ENV=development,env1=13,env2=32 ``` 7. **为生产环境设置环境变量**: 对于生产环境，你可以这样设置： ```bash NODE_ENV=production pm2 start app.js ``` 使用 CLI 命令直接设置这些选项的好处是快速简便，特别是对于一次性或临时的任务。但对于更复杂的部署，或者当你需要在多个环境中维护一致的配置时，使用配置文件将更为有效和易于管理。',link:"/backend/使用PM2实现高效的应用监控与管理#_5-cli-实现配置文件效果",textType:"code",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"PM2提供了一个内置的监控工具，允许你实时查看运行在 PM2下的应用的性能指标，如 CPU 和内存使用情况。这个监控工具可以帮助你了解应用的运行状况，及时发现潜在的问题。",link:"/backend/使用PM2实现高效的应用监控与管理#_6-监控",textType:"text",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"1. **启动监控控制台**: 要查看实时的监控数据，可以在命令行中使用以下命令： ```bash pm2 monit ``` 这会打开一个交互式的监控控制台，其中展示了所有由 PM2管理的进程的 CPU 和内存使用情况。",link:"/backend/使用PM2实现高效的应用监控与管理#使用-pm2监控命令行工具",textType:"code",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"PM2还提供了一个 Web 界面，称为 PM2 Plus，用于更高级的监控和管理功能，包括远程监控和日志管理。不过，这需要在 PM2 Plus 网站上注册并设置 keymetrics 代理。 1. **PM2 Plus**: - 你可以访问PM2 Plus来获取更多关于这个服务的信息。 - 它允许你监控关键指标，设置告警，查看日志，和进行实时的问题排查。",link:"/backend/使用PM2实现高效的应用监控与管理#使用-pm2-web-界面",textType:"text",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"PM2还允许你定义自己的指标来监控。你可以在你的应用中集成 PM2的 API 来发送自定义指标，这样就可以在 PM2的监控工具中查看这些指标了。",link:"/backend/使用PM2实现高效的应用监控与管理#自定义指标",textType:"text",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"",link:"/backend/使用PM2实现高效的应用监控与管理#_7-其它",textType:"text",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:'在使用 PM2的集群模式运行多个实例的场景下，确保会话（session）一致性是一个重要的考虑点。由于每个实例都是独立运行的，直接在内存中存储会话信息可能会导致会话不一致的问题，因为用户的后续请求可能被路由到不同的实例上，而不同的实例之间无法共享内存中的会话信息。 为了解决这个问题，通常的做法是使用一个中央存储来存储会话信息，这样不同的实例可以共享这些信息。以下是一些常见的解决方案： 1. **使用 Redis 存储会话**: Redis 是一种常用的解决方案，它提供了快速的数据读写并支持数据持久化。使用 Redis 作为会话存储，可以确保不同的实例能够访问和更新同一份会话数据。 2. **使用数据库存储会话**: 另一种常见的方法是将会话存储在数据库中，如 MongoDB 或 MySQL 等。这样可以确保会话信息的一致性，但可能比使用内存存储或 Redis 的性能稍低。 3. **使用其他共享存储方案**: 根据应用的具体需求，还可以考虑使用其他类型的共享存储方案，如 Memcached、Etcd 等。 对于 Node.js 应用，如果你使用 Express 框架，可以利用`express-session`配合 Redis 等存储的中间件来实现会话的共享。例如，使用`connect-redis`中间件将会话存储在 Redis 中： ```javascript const session = require("express-session"); const RedisStore = require("connect-redis")(session); app.use( session({ store: new RedisStore({ // Redis 服务器配置 host: "localhost", port: 6379, }), secret: "your_secret", resave: false, saveUninitialized: false, }) ); ``` 使用这种方式，无论用户的请求被路由到哪个实例，应用都能访问到同一份会话信息，从而避免了会话不一致的问题。确保你的会话存储方案是可伸缩的，并且可以处理你的应用负载。',link:"/backend/使用PM2实现高效的应用监控与管理#_7-1-负载均衡下的会话管理",textType:"code",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"当 PM2重启应用时，确保应用的当前状态完成后再继续，以及在异常重启下恢复重启前的状态，需要在应用层面做一些策略设计。这通常涉及到优雅的关闭处理和持久化状态管理。",link:"/backend/使用PM2实现高效的应用监控与管理#_7-2-异常重启处理",textType:"text",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:'1. **捕获关闭信号**：在 Node.js 应用中，你可以监听如`SIGINT`和`SIGTERM`这样的信号，这样当 PM2尝试重启应用时，你的代码可以捕获这些信号并执行清理逻辑。 ```javascript process.on("SIGINT", function () { console.log("Received SIGINT. Performing graceful shutdown."); gracefulShutdown(); }); function gracefulShutdown() { // 在这里执行清理操作，如关闭数据库连接、完成正在处理的请求等 } ``` 2. **完成正在处理的请求**：在收到关闭信号后，应用应该停止接受新的请求，但同时确保当前正在处理的请求完成。这可能涉及到跟踪所有活跃的请求并等待它们结束。',link:"/backend/使用PM2实现高效的应用监控与管理#优雅的关闭处理",textType:"code",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"1. **状态持久化**：为了在重启后恢复状态，应用的关键状态需要持久化，例如存储在数据库或文件系统中。这样，在应用重启后，可以从这些持久化的存储中恢复状态。 2. **启动时的状态恢复逻辑**：应用启动时应该包含逻辑来检查并恢复之前的状态。这可能包括读取数据库中的数据，或从文件系统中恢复信息等。",link:"/backend/使用PM2实现高效的应用监控与管理#恢复状态",textType:"text",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"- **进程守护**：PM2会守护你的应用进程，如果应用崩溃或非正常退出，它会自动重启应用。这是通过配置 PM2的`restart`策略实现的。 - **零停机重启**：使用 PM2的`reload`或`gracefulReload`命令可以实现零停机重启，这对于不间断服务的应用特别有用。这些命令会等待新的实例启动并接收连接后，再停止旧的实例。",link:"/backend/使用PM2实现高效的应用监控与管理#pm2特定策略",textType:"text",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:'```js const express = require("express"); const app = express(); const server = app.listen(3000, () => console.log("Server started on port 3000") ); let activeConnections = new Set(); app.get("/", (req, res) => { // 模拟长时间运行的请求 const requestId = Date.now(); activeConnections.add(requestId); console.log(`Request ${requestId} started`); setTimeout(() => { res.send("Hello World"); activeConnections.delete(requestId); console.log(`Request ${requestId} finished`); }, 10000); // 假设请求处理需要10秒 }); process.on("SIGINT", () => { console.log("Received SIGINT. Graceful shutdown start."); // 停止服务器接受新的连接 server.close(() => { console.log("Server closed. No new connections are accepted."); }); // 等待所有活动请求完成 const checkActiveConnections = () => { if (activeConnections.size > 0) { console.log( `Waiting for ${activeConnections.size} active connections to finish.` ); setTimeout(checkActiveConnections, 1000); } else { console.log("All connections finished. Exiting now."); process.exit(0); } }; checkActiveConnections(); }); ``` 捕获`SIGINT`信号后，进程确实有机会执行清理逻辑，但这并不意味着 PM2无法再去主动 kill 进程。当你的应用捕获`SIGINT`信号并进入清理阶段时，PM2会等待一段时间（默认是1600毫秒），这个时间是可配置的。如果应用在这段时间内没有退出，PM2会发送`SIGKILL`信号来强制终止进程。 这意味着你的清理逻辑需要在 PM2的超时时间内完成，以确保它能够正常执行并让进程优雅地退出。如果清理逻辑需要的时间超过了 PM2的超时阈值，你可以调整 PM2的配置来增加这个超时时间。 例如，你可以在启动应用时通过`--kill-timeout`参数来设置这个超时时间： ```bash pm2 start app.js --kill-timeout 3000 ``` 这里，`--kill-timeout 3000`表示 PM2将等待3000毫秒（3秒）给应用足够的时间来处理清理逻辑。如果应用在3秒内没有退出，PM2将使用`SIGKILL`来强制终止应用。 这个机制确保了你的应用有机会在 PM2重启或停止它之前完成必要的清理工作，同时也保留了 PM2在应用无法正确响应终止信号时强制关闭它的能力。',link:"/backend/使用PM2实现高效的应用监控与管理#_7-3-sigint-信号超时处理",textType:"code",routeTitle:"backend > 使用PM2实现高效的应用监控与管理",groupType:1},{text:"前面看到一个共享白板的场景，如：发给你一个地址，让你在上面做题，双方都可以进行实时编辑。这个功能小而美，这里简单实现下。",link:"/backend/实时协作的艺术：构建高效共享白板系统#实时协作的艺术-构建高效共享白板系统",textType:"text",routeTitle:"backend > 实时协作的艺术：构建高效共享白板系统",groupType:1},{text:"实现多人协同编辑共享白板的功能，可以用到以下几种关键技术： 1. **WebSockets**: WebSockets 提供了一个全双工的通信渠道，允许数据在客户端和服务器之间实时、快速地双向传输。这对于多人实时协作尤其重要。 2. **Operational Transformation (OT)**: 这是一种算法，用于同步和解决多个用户同时对同一个文档进行操作时可能产生的冲突。Google Docs 使用的就是这种技术。 3. **Conflict-free Replicated Data Types (CRDTs)**: CRDTs 是一种数据结构，它允许同时在多个设备上对数据进行修改，并能够确保最终的一致性，不需要复杂的冲突解决策略。 4. **Real-time Database**: 如 Firebase Realtime Database 或 Amazon DynamoDB 等，这些数据库支持实时数据同步。 5. **Backend as a Service (BaaS)**: 服务如 Firebase、Azure 或 AWS Amplify 等，提供了实时数据库、身份验证、托管等服务，可以简化多人协同编辑功能的后端开发。 6. **REST API/GraphQL**: 对于非实时的数据同步需求，可以使用 REST API 或 GraphQL 来处理数据的获取和更新。 7. **WebRTC**: WebRTC 支持浏览器之间的点对点通信，可以用于支持实时音视频聊天等功能。 8. **Security**: 使用 OAuth, JWT 等进行身份验证和授权，确保数据安全。 9. **Message Queue**: 使用消息队列（如 RabbitMQ, Kafka）可以帮助实现高效、可靠的消息分发机制，适用于大规模的协作场景。 10. **Microservices Architecture**: 采用微服务架构，可以将复杂的应用拆分成更容易管理和扩展的小模块。 11. **Load Balancing**: 在服务器端使用负载均衡技术来分配客户端请求，确保系统的高可用性和伸缩性。",link:"/backend/实时协作的艺术：构建高效共享白板系统#_1-多人协同关键技术",textType:"text",routeTitle:"backend > 实时协作的艺术：构建高效共享白板系统",groupType:1},{text:'Operational Transformation (OT) 和 Conflict-free Replicated Data Types (CRDTs) 都是解决分布式系统中数据一致性问题的算法，但它们在理念和实现上有所不同。 **Operational Transformation (OT):** - **概念**: OT 通过转换同时发生的操作来解决冲突，它需要跟踪每个操作的上下文信息，包括操作的位置和历史。 - **实现**: 通常需要一个中心服务器来进行操作转换和冲突解决，确保所有客户端最终都看到相同的文档状态。 - **优点**: 在某些情况下，OT 可以提供更精细的控制和更多的协作特性。 - **缺点**: 实现复杂，对网络延迟敏感。 **Conflict-free Replicated Data Types (CRDTs):** - **概念**: CRDTs 通过确保所有操作都是可交换的（Commutative）和可合并的（Associative）来避免冲突，不需要中心服务器来解决冲突。 - **实现**: 客户端可以独立地执行操作，并通过一种最终一致性的方式来同步更新。 - **优点**: 结构简单，适合离线和网络不稳定的环境。 - **缺点**: 可能无法支持某些需要精确控制操作顺序的协作特性。 以下是基于 Node.js 的简化示例，展示 OT 和 CRDTs 的基本概念： **OT 示例 (Node.js):** ```javascript // 假设有两个操作：用户 A 在位置0插入字符"a"，用户 B 在位置0插入字符"b"。 // 服务器需要转换其中一个操作，以保持一致性。 // 初始字符串 let document = ""; // 用户 A 的操作 const opA = { position: 0, char: "a", type: "insert" }; // 用户 B 的操作 const opB = { position: 0, char: "b", type: "insert" }; // OT 转换函数 function transform(op1, op2) { if ( op1.position === op2.position && op1.type === "insert" && op2.type === "insert" ) { op1.position += 1; } return op1; } // 服务器转换操作 const transformedOpA = transform(opA, opB); // 应用操作 function applyOp(op) { document = document.substring(0, op.position) + op.char + document.substring(op.position); } // 按顺序应用操作 applyOp(opB); applyOp(transformedOpA); console.log(document); // 输出 "ba" ``` **CRDTs 示例 (Node.js):** ```javascript // 假设我们有一个可合并的计数器 CRDT，任何节点都可以独立增加计数器，然后通过某种机制合并。 class GCounter { constructor() { this.counts = {}; } // 增加当前节点的计数 increment(nodeId) { if (!this.counts[nodeId]) { this.counts[nodeId] = 0; } this.counts[nodeId] += 1; } // 合并来自其他节点的计数器 merge(otherCounter) { for (let nodeId in otherCounter.counts) { if ( !this.counts[nodeId] || this.counts[nodeId] < otherCounter.counts[nodeId] ) { this.counts[nodeId] = otherCounter.counts[nodeId]; } } } // 获取总计数 getValue() { return Object.values(this.counts).reduce((sum, count) => sum + count, 0); } } // 创建两个节点的计数器 const counterA = new GCounter(); const counterB = new GCounter(); // 节点 A 和节点 B 独立计数 counterA.increment("A"); counterB.increment("B"); // 合并计数器状态 counterA.merge(counterB); counterB.merge(counterA); console.log(counterA.getValue()); // 输出 "2" console.log(counterB.getValue()); // 输出 "2" ``` 在上述两个示例中，OT 示例展示了在文本协作编辑场景中如何使用操作转换来保持文档一致性。而 CRDTs 示例则展示了在计数器场景下如何使用可合并的计数器来确保最终一致性，无需考虑操作的顺序。 需要注意，以上示例仅用于描述 OT 和 CRDTs 的基本概念，并非完整的协同编辑系统实现。在实际的多人协同编辑应用中，OT 和 CRDTs 的实现会更加复杂，涉及到更多的边界情况和性能优化。',link:"/backend/实时协作的艺术：构建高效共享白板系统#_2-算法对比-ot-vs-crdts",textType:"code",routeTitle:"backend > 实时协作的艺术：构建高效共享白板系统",groupType:1},{text:"WebSockets 和 WebRTC 是两种不同的技术，它们都可以在浏览器中用于实现实时通信，但是它们的设计目标、用例和实现方式存在显著差异。 **WebSockets:** 1. **基本概念**：WebSockets 提供了一个全双工的通信协议，允许客户端与服务器之间建立一个持久的连接，并通过这个连接进行实时的数据交换。 2. **特点**： - 基于 TCP 连接。 - 协议标识符为 `ws://` 或加密的 `wss://`。 - 适用于客户端和服务器之间的任意类型的数据传输。 - 没有内置的直接点对点（P2P）通信能力；所有通信都是通过服务器进行中转的。 3. **优势**： - 降低了服务器和客户端之间通信的延迟。 - 支持文本和二进制数据的传输。 - 被广泛支持，大多数现代浏览器都提供了原生的 WebSocket 支持。 4. **劣势**： - 不适合用于 P2P 场景，因为数据传输需要通过服务器中转。 - 相比于 HTTP 轮询，WebSocket 更复杂，需要服务器端支持 WebSocket 协议。 **WebRTC:** 1. **基本概念**：WebRTC（Web Real-Time Communication）是一个支持网页浏览器进行实时语音对话、视频对话和点对点文件共享的技术。 2. **特点**： - 提供了 P2P 直接通信的能力，不需要服务器中转数据（除了在建立连接时需要信令服务器）。 - 协议标准复杂，包括了一组不同的 API 和协议。 - 支持数据通道（Data Channels）、音频和视频流。 - 通信可以是加密的，且通常建立在 UDP 上，以减少延迟。 3. **优势**： - 适合于视频/语音通话、实时游戏、P2P 文件共享等高实时性和带宽敏感的应用。 - 减少服务器带宽需求，因为数据可以直接在用户之间传输。 - 支持 NAT 穿透和加密，安全性较高。 4. **劣势**： - 实现复杂，需要处理 NAT 穿透、会话控制协议（如 ICE、STUN、TURN）等。 - 对于非实时、高可靠性要求的数据传输场景可能不是最佳选择。 **适合的场景**： - **WebSockets**： - 聊天应用：需要服务器存储和转发消息。 - 多人在线游戏：服务器维护游戏逻辑和状态。 - 实时数据更新：如股票行情、新闻直播等。 - 协同工作应用：如文档编辑、项目管理工具等。 - **WebRTC**： - 视频/语音通话：如 Skype 的网页版。 - 实时 P2P 游戏：需要低延迟的双方通讯。 - 私密文件共享：直接在用户间传输数据，不通过服务器。 - 实时音视频直播：支持大规模的 P2P 数据流传输。 总的来说，WebSockets 主要用于需要服务器处理逻辑的实时通信，而 WebRTC 适用于需要直接点对点通信，且对延迟和带宽有更高要求的场景。根据应用的需求和设计，可以选择合适的技术来实现。",link:"/backend/实时协作的艺术：构建高效共享白板系统#_3-传输对比-websockets-vs-webrtc",textType:"text",routeTitle:"backend > 实时协作的艺术：构建高效共享白板系统",groupType:1},{text:"这里直接采用 WebSockets 简单实现一下。",link:"/backend/实时协作的艺术：构建高效共享白板系统#_4-简版实现",textType:"text",routeTitle:"backend > 实时协作的艺术：构建高效共享白板系统",groupType:1},{text:'```javascript // 从相应的包中导入所需模块。 import express from "express"; import http from "http"; import WebSocket, { WebSocketServer } from "ws"; // 创建一个新的 Express 应用实例。 const app = express(); // 使用 Express 应用创建一个新的 HTTP 服务器。 const server = http.createServer(app); // 初始化一个新的 WebSocket 服务器实例并将其挂载到 HTTP 服务器上。 const wss = new WebSocketServer({ server }); // 设置 Express 应用以从"public"目录提供静态文件。 app.use(express.static("public")); // 为 WebSocket 服务器的\'connection\'事件定义行为。 wss.on("connection", function connection(ws) { // 通知所有客户端有新用户连接。 const userConnected = { type: "user-event", event: "connected", userCount: wss.clients.size, // 包含当前用户数量。 }; // 将用户连接事件广播给所有客户端（除了新连接的用户）。 broadcast(ws, JSON.stringify(userConnected), false); // 为 WebSocket 实例的\'message\'事件定义行为。 ws.on("message", function incoming(data) { // 将接收到的消息广播给所有客户端。 broadcast(ws, data.toString()); }); // 为 WebSocket 实例的\'close\'事件定义行为。 ws.on("close", function close() { // 通知所有客户端用户已断开连接。 const userDisconnected = { type: "user-event", event: "disconnected", userCount: wss.clients.size - 1, // 更新用户数量。 }; // 将用户断开连接事件广播给所有客户端。 broadcast(ws, JSON.stringify(userDisconnected), false); }); }); // 在8083端口启动 HTTP 服务器。 server.listen(8083, function () { console.log("服务器正在 http://localhost:8083 上运行"); }); // 定义一个函数来向所有已连接的 WebSocket 客户端广播数据。 function broadcast(client, data, excludeSelf = true) { // 遍历所有已连接的 WebSocket 客户端。 wss.clients.forEach(function each(otherClient) { // 检查是否排除发送者以及其他客户端的 WebSocket 是否处于开放状态。 if ( excludeSelf ? otherClient !== client && otherClient.readyState === WebSocket.OPEN : true ) { // 向其他客户端发送数据。 otherClient.send(data); } }); } ```',link:"/backend/实时协作的艺术：构建高效共享白板系统#_4-1-server",textType:"code",routeTitle:"backend > 实时协作的艺术：构建高效共享白板系统",groupType:1},{text:"```html <!DOCTYPE html> <html> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>共享白板</title> <style> html, body { height: 100%; margin: 0; padding: 0; display: flex; flex-direction: column; align-items: center; } h1 { height: 5vh; } textarea { width: 90vw; height: 80vh; outline: none; } </style> </head> <body> <h1>共享白板：(<span id=\"count\"></span>)</h1> <textarea id=\"sharedTextarea\" rows=\"10\" cols=\"50\"></textarea> <script src=\"https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/lodash.js/4.17.21/lodash.min.js\" crossorigin=\"anonymous\"><\/script> <script> // 创建 WebSocket 连接，连接到当前页面的主机地址 const ws = new WebSocket('ws://' + location.host); // 当从 WebSocket 收到消息时的处理逻辑 ws.onmessage = async function (event) { // 解析收到的消息 const message = JSON.parse(event.data); // 判断消息类型 if (message.type === 'text-update') { // 如果是文本更新消息，则更新文本域的内容及光标位置 const textarea = document.getElementById('sharedTextarea'); textarea.focus(); textarea.value = message.content; // 更新光标位置 textarea.selectionStart = message.selectionStart; textarea.selectionEnd = message.selectionEnd; } else if (message.type === 'user-event') { // 如果是用户事件（连接或断开），更新在线人数显示 console.log('User event:', message.event, 'Current user count:', message.userCount); document.getElementById('count').innerText = message.userCount + '人在线'; } }; // 当 WebSocket 连接关闭时的处理逻辑 ws.onclose = function () { console.log('WebSocket connection closed'); document.getElementById('count').innerText = '已离线'; }; // 发送更新内容到服务器的函数 async function sendUpdate() { const textarea = document.getElementById('sharedTextarea'); const content = textarea.value const message = { type: 'text-update', content, selectionStart: textarea.selectionStart, selectionEnd: textarea.selectionEnd }; // 通过 WebSocket 发送更新消息 ws.send(JSON.stringify(message)); } // 使用 lodash 的防抖函数，限制 sendUpdate 函数的触发频率 const dSendUpdate = _.debounce(sendUpdate, 500) // 给文本域添加事件监听，当输入、鼠标释放和键盘释放事件发生时触发更新 document.getElementById('sharedTextarea').addEventListener('input', dSendUpdate); document.getElementById('sharedTextarea').addEventListener('mouseup', dSendUpdate); document.getElementById('sharedTextarea').addEventListener('keyup', dSendUpdate); <\/script> </body> </html> ``` 这段代码构成了一个简单的共享白板 HTML 页面，用户可以在文本域中输入并实时与其他用户共享内容。通过 WebSocket 通信机制，用户的每次输入都会被发送到服务器，并由服务器广播给其他用户，实现协编辑的效果。同时，页面还能够显示当前在线的用户数量。使用了 lodash 库中的`debounce`函数来限制发送更新的频率，避免因为频繁通信而导致的性能问题。",link:"/backend/实时协作的艺术：构建高效共享白板系统#_4-2-浏览器端",textType:"code",routeTitle:"backend > 实时协作的艺术：构建高效共享白板系统",groupType:1},{text:'```javascript // 定义一个异步函数用于加密文本。 async function en(textToEncrypt) { // 使用 TextEncoder 将文本转换为 UTF-8编码的字节。 const encoder = new TextEncoder(); const data = encoder.encode(textToEncrypt); // 从 localStorage 中读取 AES 密钥，将十六进制字符串转换为字节数组。 const keyBuffer = new Uint8Array( localStorage .getItem("aesKey") .match(/[\\da-f]{2}/gi) .map((h) => parseInt(h, 16)) ); // 从 localStorage 中读取初始化向量(IV)，将十六进制字符串转换为字节数组。 const ivBuffer = new Uint8Array( localStorage .getItem("aesIv") .match(/[\\da-f]{2}/gi) .map((h) => parseInt(h, 16)) ); // 导入密钥，用于后续的加密操作。 const key = await window.crypto.subtle.importKey( "raw", // 密钥数据的格式。 keyBuffer, // 密钥数据。 "AES-CBC", // 使用的加密算法。 true, // 密钥是否可导出。 ["encrypt", "decrypt"] // 密钥用途。 ); // 执行加密操作。 const encryptedData = await window.crypto.subtle.encrypt( { name: "AES-CBC", // 使用的加密算法。 iv: ivBuffer, // 初始向量。 }, key, // 导入的密钥。 data // 要加密的数据。 ); // 将加密后的数据转换为 Base64字符串。 return btoa(String.fromCharCode.apply(null, new Uint8Array(encryptedData))); } // 定义一个异步函数用于解密 Base64字符串。 async function de(base64String) { // 将 Base64字符串转换为字节数组。 const encryptedData = new Uint8Array( atob(base64String) .split("") .map((char) => char.charCodeAt(0)) ); // 从 localStorage 中读取 AES 密钥，将十六进制字符串转换为字节数组。 const keyBuffer = new Uint8Array( localStorage .getItem("aesKey") .match(/[\\da-f]{2}/gi) .map((h) => parseInt(h, 16)) ); // 从 localStorage 中读取初始化向量(IV)，将十六进制字符串转换为字节数组。 const ivBuffer = new Uint8Array( localStorage .getItem("aesIv") .match(/[\\da-f]{2}/gi) .map((h) => parseInt(h, 16)) ); // 导入密钥，用于后续的解密操作。 const key = await window.crypto.subtle.importKey( "raw", // 密钥数据的格式。 keyBuffer, // 密钥数据。 "AES-CBC", // 使用的加密算法。 true, // 密钥是否可导出。 ["encrypt", "decrypt"] // 密钥用途。 ); // 执行解密操作。 const decryptedData = await window.crypto.subtle.decrypt( { name: "AES-CBC", // 使用的加密算法。 iv: ivBuffer, // 初始向量。 }, key, // 导入的密钥。 encryptedData // 要解密的数据。 ); // 使用 TextDecoder 将解密后的字节数据转换为文本。 const decoder = new TextDecoder(); return decoder.decode(decryptedData); } ``` 详细参考：https://github.com/lecepin/websocket-whiteboard',link:"/backend/实时协作的艺术：构建高效共享白板系统#_4-3-简单加密-解密处理",textType:"code",routeTitle:"backend > 实时协作的艺术：构建高效共享白板系统",groupType:1},{text:"",link:"/business/ai#ai业务",textType:"text",routeTitle:"business > ai",groupType:2},{text:"背景：我们每天都充斥大量的信息，而我们每个人的精力有限，加上短视频快餐文化横行，人们花在阅读上面的时间越来越少，如何提高阅读的质量，如何用有限的精力来快速获取并掌握高质量的信息显得尤为重要。 目标：openAi擅长自然语言处理，将openAi的能力融合到知识库中来做文档的阅读理解，改变传统的阅读模式，输入企业知识库给openAi尽行分析，提炼摘要内容，可以询问某个部门的规章制度，某个技术的流程细节，还可以通过追问的方式补充问答，对于不清楚的地方可以补充名词解释、证明逻辑、阅读翻译、划词解释、文档归类打标签。 亮点：让AI来学习理解知识库内容，用户借助AI的能力可以快速学习和理解知识 创新点：改变传统的阅读学习方式，借助Ai的学习理解能力，获取知识可以用检索和追问方式来学习，有目的的针对性学习来提高学习效率 可行性：用RSS订阅+爬虫的方式拿到用户可以读取到知识库内容，然后输入给openAi进行分析处理，用编程方式抹平输入openAI对token长度限制，用专业prompts提升AI理解力。",link:"/business/ai#企业知识助理",textType:"text",routeTitle:"business > ai",groupType:2},{text:"文本摘要和视频摘要技术研究",link:"/business/ai#文本摘要和视频摘要技术研究",textType:"text",routeTitle:"business > ai",groupType:2},{text:"对于长文本和长视频用户是没有耐心从头看到尾的，用户只关注对自己感觉兴趣的信息，对自己感兴趣才会详细阅读查看，因此摘要功能显得尤为重要，提炼出知识库和会议视频的摘要，让用户可以快速获取自己想要的信息。",link:"/business/ai#背景",textType:"text",routeTitle:"business > ai",groupType:2},{text:"当前openAI提供的聊天接口表现了一定的本文处理能力，对于短文本可以直接处理，但并不能直接处理长文本和音视频。需要解决的问题有： • 模型token长度限制怎么处理 • 上下文回话怎么关联 • 视频转音频 • 音频分割 • 摘要准确度怎么优化",link:"/business/ai#存在的问题",textType:"text",routeTitle:"business > ai",groupType:2},{text:"1. 使用文本分割，了解token计算规则 2. 采用embedding 3. 音视频分割 相关库 4. 摘要准确度优化调参，暂无不清楚 当前实践 [x] 读取AP文本 [x] 读写word本文 [ ] 后端联调接口提取短文本摘要 [ ] 创建文本和文本写入AP 待处理问题 • embedding的用法还需要学习",link:"/business/ai#解决方案",textType:"text",routeTitle:"business > ai",groupType:2},{text:"- https://platform.openai.com/docs - https://platform.openai.com/examples - https://github.com/openai/openai-cookbook",link:"/business/ai#参考资料",textType:"text",routeTitle:"business > ai",groupType:2},{text:"# 编辑器",link:"/business/editor#编辑器",textType:"text",routeTitle:"business > editor",groupType:2},{text:"- document.execCommand 加粗 斜体 加链接 - contenteditable 阅读 编辑模式 - document.getSelection(0) 拿到光标和选取位置 - 核心是 编辑工具 toolBar inlineToolbar - 难点是浏览器兼容性 不同浏览器表现不一致 光标、位置问题",link:"/business/editor#editor编辑器基本原理",textType:"text",routeTitle:"business > editor",groupType:2},{text:"自建渲染引擎，虚拟光标",link:"/business/editor#wps编辑器",textType:"text",routeTitle:"business > editor",groupType:2},{text:"",link:"/business/editor#编辑器插件",textType:"text",routeTitle:"business > editor",groupType:2},{text:"",link:"/business/editor#可以做编辑器相关业务",textType:"text",routeTitle:"business > editor",groupType:2},{text:"",link:"/business/editor#可以做后端业务nest",textType:"text",routeTitle:"business > editor",groupType:2},{text:"",link:"/business/editor#部署运维",textType:"text",routeTitle:"business > editor",groupType:2},{text:"",link:"/business/index#",textType:"text",routeTitle:"business > index",groupType:2},{text:"",link:"/business/lint#lint",textType:"text",routeTitle:"business > lint",groupType:2},{text:"- https://juejin.cn/post/7038143752036155428?searchId=20240422153232E9FEBDEE6F9C092E97C2",link:"/business/lint#参考",textType:"text",routeTitle:"business > lint",groupType:2},{text:"- https://juejin.cn/post/7236021829000691771?searchId=202404221417155BF449FED5BCAA1552BE",link:"/business/microfronend#参考",textType:"text",routeTitle:"business > microfronend",groupType:2},{text:"原文链接：https://juejin.cn/post/7289740992508215296 > > 📌推荐语： 2020年，微软（Microsoft）开源了一个名为Playwright的工具，与Selenium一样入门简单，支持多语言（Python、Java、Node.js、.NET），支持多浏览器（Chromium、Firefox、Webkit）,可跨平台（Windows、Linux、Mac OS）。Playwright同时支持接口自动化和UI自动化，为现代web应用提供了可靠的端到端的测试能力。 • Playwright优势： 1）自动等待功能让自动化更可靠； 2）自动追踪：可以很方便地配置重试策略，自动的追踪结果，以截图和录屏的方式进行记录； 3）断言机制：会根据网络环境进行自动断言，直到满足某种条件为止； 4）异步执行：Playwright基于socket进行双向通讯，支持同步与异步执行两种方式； 5）可运行多页仿真场景：Playwright是通过上下文管理浏览器，相当于每一个测试用例都会创建一个独立的上下文，浏览器的上下文其实就是一个全新的浏览器，这种方式的好处就是在提速的同时又实现测试与测试之间的隔离，使得测试结果更加准确，所以可以实现并行执行； 6）强大的工具集：还提供了强大的工具集，例如：脚本录制工具codegen、脚本编写以及调试工具playwright等。 官网链接：https://playwright.dev/ >",link:"/business/playwright#端到端测试框架-playwright-使用入门",textType:"text",routeTitle:"business > playwright",groupType:2},{text:"Playwright 是一个端到端（E2E）测试框架， 它可在所有现代浏览器中运行功能强大的测试和自动化。支持多种编程语言 API， 包括 JavaScript 、TypeScript、Python, .NET和Java。正因为它基于浏览器，相当于模拟用户真实操作，因此不光能够用来跑测试用例，还可以用来写爬虫。",link:"/business/playwright#_1-playwright-介绍",textType:"text",routeTitle:"business > playwright",groupType:2},{text:"我们可以安装一个 vscode 插件Playwright Test for VSCode，来帮助我们运行、录制、调试测试用例。",link:"/business/playwright#_2-playwright-test-for-vscode",textType:"text",routeTitle:"business > playwright",groupType:2},{text:"如果项目中没有安装PlaywrightNPM 包，或者重新开始一个新的测试项目，需要可以在 vscode 命令面板中输入intsll Playwright。 选择我们常用的浏览器，不必担心选错，后面可以在项目中更改。还可以选择 GitHub Action ，这样就可以轻松在 Github 中持续集成。 这里我选择 chromium，这样可以只下载一个浏览器内核。 点击OK后，插件会帮我们自动初始化程序， 下图是初始化的目录结构 配置文件都在playwright.config.ts中。 看下package.json，只包含了一个包@playwright/test",link:"/business/playwright#_3-初始化项目",textType:"text",routeTitle:"business > playwright",groupType:2},{text:'所有的测试用例都要写在tests文件夹中，默认有一个测试文件，包含有 2 个测试用例，代码在example.spec.ts中。 第一个测试用例：确保标题包含 Playwright； 第二个测试用例：确保点击 “Get Started”后，跳转到 intro 的链接。 选择左侧的测试用例，并且勾选Show browser，我们便可以直观的看到 Playwright 运行测试的过程。 以上例子默认是使用 chromium 来运行的，并且 chromium 不包含任何 cookie 和缓存信息。 在playwright.config.ts配置文件中， 可以配置启用的浏览器为 chrome，我们只需要增加一个参数channel，让 Playwright 使用浏览器来运行。 也可以是其他浏览器，参数可以为： "chrome", "chrome-beta", "chrome-dev", "chrome-canary", "msedge", "msedge-beta", "msedge-dev"，"msedge-canary". ``` use: { channel:\'chrome\', /* Base URL to use in actions like `await page.goto(\'/\')`. */ // baseURL: \'http://127.0.0.1:3000\', /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */ trace: \'on-first-retry\', }, ``` 我们虽然改成了使用浏览器来运行，但是启动的浏览器也是一个无痕模式，不包含任何缓存信息。',link:"/business/playwright#_4-运行测试",textType:"code",routeTitle:"business > playwright",groupType:2},{text:'测试的系统往往需要登录，而在运行每个测试用例之前运行，都需要登录，这肯定是繁琐的，因此我们可以在运行测试用例之前，手动拷贝 cookies，注入到浏览器中。 比如掘金的每日签到和抽奖，我就可以使用 Playwright 来实现自动化 首先建立一个测试文件 ```js import { test, expect, type Page } from "@playwright/test"; test("登录", async ({page, context}) => { await context.addCookies([ { name: "sessionid", value: "xxx", path: "/", domain: ".juejin.cn", }, { name: "sessionid_ss", value: "xxx", path: "/", domain: ".juejin.cn", }, ]); await page.goto("https://juejin.cn/"); }); ``` 打开 chrome 控制台，复制 cookies， 添加到代码中 此时点击左侧运行的测试用例，发现已经是登录状态。',link:"/business/playwright#_5-添加-cookie",textType:"code",routeTitle:"business > playwright",groupType:2},{text:'如果要手动去查找 dom ，从零开始写一个测试用例肯定是繁琐的，因此 Playwright VSCode 插件提供了录制功能。 运行上一次测试用例后，浏览器是未关闭的。此时我们点击 vscode 左侧的Record new按钮，vscode 便会自动创建一个测试文件，并且记录操作步骤。 录制时，浏览器又是一个全新的，不保留任何状态，那如果我们要测试的是登录后的功能，岂不是又要登录？ 其实 playwright 可以保存登录状态。 在上面测试用例后加一句 storageState。 ```js import { test, expect, type Page } from "@playwright/test"; test("登录", async ({page, context}) => { await context.addCookies([ { name: "sessionid", value: "xxx", path: "/", domain: ".juejin.cn", }, { name: "sessionid_ss", value: "xxx", path: "/", domain: ".juejin.cn", }, ]); await page.goto("https://juejin.cn/"); + await context.storageState({ path: \'state.json\' }); }); ``` 并且在playwright.config.ts中，配置存储位置。 此时我们录制操作，就已经是登录状态了。 以下便是录制后的代码。 ```js import { test, expect } from \'@playwright/test\'; test(\'test\', async ({ page }) => { await page.goto(\'https://juejin.cn/\'); await page.getByRole(\'button\', { name: \'去签到\' }).click(); await page.getByRole(\'button\', { name: \'立即签到\' }).click(); await page.getByRole(\'button\', { name: \'去抽奖\' }).click(); await page.getByText(\'免费抽奖次数：1次\').click(); await page.getByRole(\'button\', { name: \'收下奖励\' }).click(); }); ``` 录制完成后，直接运行代码可能会报错，我们需要调整一下，因为有些文本是异步请求实现的，有些事件是请求成功后绑定的，在手动录制时，因为已经响应完成，因此没问题，我们加上 2 句延迟。 ```js test("test", async ({ page }) => { await page.goto("https://juejin.cn/"); + await page.waitForTimeout(1000); await page.getByRole("button", { name: /去签到|已签到/ }).click(); + await page.waitForTimeout(1000); await page.getByRole("button", { name: /今日已签到|立即签到/ }).click(); await page.getByRole("button", { name: "去抽奖" }).click(); const lotteryElement = await page.$("#turntable-item-0"); const buttonText = await lotteryElement?.textContent(); if (buttonText === "免费抽奖次数：1次") { await lotteryElement?.click(); await page.getByRole("button", { name: "收下奖励" }).click(); } else { expect( page.locator("#turntable-item-0", { hasText: /单抽/ }) ).toBeDefined(); } }); ``` 便可以运行成功，注意这里我使用了waitForTimeout这个 api 在官网中已经被标记了废弃(deprecate) 实际测试场景中请使用改用网络事件、选择器变得可见等信号。 ```js await page.goto("https://juejin.cn/"); await page.waitForResponse((res) => res.url().includes("/user_api/v1/incentive_activity/award_after_login") ); await page.getByRole("button", { name: /去签到|已签到/ }).click(); await page.waitForResponse((res) => res.url().includes("/growth_api/v2/get_today_status") ); await page.getByRole("button", { name: /今日已签到|立即签到/ }).click(); ``` 等待接口响应成功后再出发点击事件。 还有一点就是，自动录制的代码，一般使用了语义化定位方法，比如getByRole、getByText，这些定位器往往不够准确，改动代码会导致测试用例失效。 因此我们可以使用locator定位器来替换。 在 Playwright 中，Locator 表示一种元素查找方式，是 Playwright 提供的一组方法，用于定位页面上的元素。 Locator 支持 XPath 和 CSS 选择器 ```js await page.locator( \'#tsf > div:nth-child(2) > div.A8SBwf > div.RNNXgb > div > div.a4bIc > input\' ).click(); await page .locator(\'//*[@id="tsf"]/div[2]/div[1]/div[1]/div/div[2]/input\') .click(); ``` 在 vscode 中可以使用 Pick locator 快速活动当前的 dom 定位。',link:"/business/playwright#_6-录制一个测试用例",textType:"code",routeTitle:"business > playwright",groupType:2},{text:'录制的测试代码只能确保业务能够跑通，但不能证明程序的可靠与健壮。一旦测试用例出错，也不知道是程序错误还是测试用例错误，因此我们还是需要根据测试用例来写可靠的测试代码。 比如上述掘金抽奖程序可以包含以下测试用例 • 签到的状态需要根据接口返回显示 通过 network 查看签到返回如下： 因此我的签到测试用例代码如下 ```js test("签到的状态根据接口返回显示", async ({ page }) => { await page.goto("https://juejin.cn/user/center/signin"); const promise = await page.waitForResponse((res) => res.url().includes("/growth_api/v2/get_today_status") ); const res = await promise.json(); if (res.data.check_in_done) { await expect(page.locator(".signedin")).toHaveText("今日已签到"); } else { await expect(page.locator(".signedin")).toHaveText("立即签到"); await page.getByRole("button", { name: /立即签到/ }).click(); await page.getByRole("button", { name: "去抽奖" }).click(); //调整到抽奖页面 await expect(page).toHaveURL(/user\\/center\\/lottery/); } }); ``` - 抽奖页面，根据接口返回显示抽奖次数和奖品 通过 network，看到抽奖配置接口返回如下： 因此我的测试用例代码如下 ```js test("根据接口返回显示抽奖次数", async ({ page }) => { await page.goto("https://juejin.cn/user/center/lottery"); const promise = await page.waitForResponse((res) => res.url().includes("/growth_api/v1/lottery_config/get") ); const res = await promise.json(); const lotteryNames = res.data.lottery.map((item) => { if (item.unlock_count === 0) { return new RegExp(item.lottery_name); } else { return new RegExp(`再抽${item.unlock_count}次解锁`); } }); await expect(page.locator(".item-container .turntable-item")).toHaveText( lotteryNames ); if (res.data.free_count) { await expect(page.locator("#turntable-item-0")).toHaveText( `免费抽奖次数：${res.data.free_count}次` ); } else { await expect(page.locator("#turntable-item-0")).toHaveText("单抽 200"); } }); ``` 有了以上断言，我们便可以确保前端页面显示与接口返回显示一致。 运行完成后，可以在 playwright-report 查看测试报告。',link:"/business/playwright#_7-测试用例及断言",textType:"code",routeTitle:"business > playwright",groupType:2},{text:"本文介绍了 Playwright 测试框架的入门使用，Playwright 是一个功能强大的端到端（E2E）测试框架，支持多种编程语言 API，适用于现代浏览器，还可用于编写网络爬虫。 首先介绍了 Playwright Test for VSCode 插件，以及如何初始化测试项目，如何运行测试用例，并指出可以选择不同的浏览器作为测试环境， 如何添加 Cookie 来模拟登录状态，以及如何使用录制功能来自动生成测试代码。 另外，文章强调了使用 Locator 定位器替代语义化定位方法，以提高测试的准确性。最后，我们通过了一个掘金抽奖程序实例强调了断言的重要性，以确保测试代码的可靠性。",link:"/business/playwright#_8-小结",textType:"text",routeTitle:"business > playwright",groupType:2},{text:"# Sentry部署与使用",link:"/business/sentry#sentry部署与使用",textType:"text",routeTitle:"business > sentry",groupType:2},{text:"Sentry 为一套开源的应用监控和错误追踪的解决方案。这套解决方案由对应的各种语言的SDK和一套庞大的数据后台服务组成。应用需要通过与之绑定的token接入Sentry SDK完成数据上报配置。通过Sentry SDK的配置，还可以上报错误关联的版本信息、发布环境、同时Sentry SDK会自动捕获异常发生前的相关操作，便于后续异常追踪。异常数据上报到数据服务后，会通过过滤、关键信息提取、归纳展示在数据后台的Web页面中 官方地址：https://github.com/getsentry/onpremise",link:"/business/sentry#介绍",textType:"text",routeTitle:"business > sentry",groupType:2},{text:"部署配置参考官网 - Docker 19.03.6+ - Compose 1.28.0+ - 4 CPU Cores - 8 GB RAM - 20 GB Free Disk Space",link:"/business/sentry#部署",textType:"text",routeTitle:"business > sentry",groupType:2},{text:"1. git clone https://github.com/getsentry/onpremise.git 2. cd onpremise 3. 执行./install.sh ./install.sh --skip-user-prompt 4. docker compose up -d > 提示: 目前sentry已经是docker容器化部署;如果我们想要整体走一下容器化部署的话，需要上面的步骤在一个linux的容器中操作，然后把linux的容器打包成一个新的镜像;然后在sre中新建一个应用，然后推送过去。之前和鸿钧、王博沟通，1.linux容器打包成镜像比较大，2。新建应用相对复杂一些；目前部署在线上xx机器中，二级域名https://sentry-zl.domain/指向",link:"/business/sentry#步骤",textType:"text",routeTitle:"business > sentry",groupType:2},{text:"sentry代码部署在/home/self-hosted sentry代码部署在/home/kooper/onpremise/ 说明 1. 登录线上服务器需要通过堡垒机ksop.domain-- 堡垒机申请试用说明 2. 线上地址https://sentry-zl.domain/ https://sentry-zl2.domain/",link:"/business/sentry#当前sentry平台部署",textType:"text",routeTitle:"business > sentry",groupType:2},{text:'注意： 拷贝的时候需要先拷贝到本地vscode中格式化，再粘贴到远端，避免有中文空格等因素影响 1. docker-compose版本过低（改用docker compose（docker自带的命令）） ``` curl -L https://github.com/docker/compose/releases/download/1.28.3/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose docker-compose --version ``` 2. docker下载太慢 ``` vim /etc/docker/daemon.json { "registry-mirrors": [ "https://registry.docker-cn.com", //国内官方镜像 "https://mirrors.tuna.tsinghua.edu.cn", //清华镜像 "http://hub-mirror.c.163.com", //网易163镜像 "https://docker.mirrors.ustc.edu.cn", //中科大镜像 ] } // 新增文件 cron/sources.list deb http://mirror.bjtu.edu.cn/debian bullseye main deb http://mirror.bjtu.edu.cn/debian bullseye-updates main // cron/Dockerfile ARG BASE_IMAGE FROM ${BASE_IMAGE} COPY sources.list /etc/apt/sources.list RUN apt-get update && apt-get install -y --no-install-recommends cron && \\ rm -r /var/lib/apt/lists/* COPY entrypoint.sh /entrypoint.sh ENTRYPOINT ["/entrypoint.sh"] // .env // 重启docker sudo systemctl daemon-reload sudo systemctl restart docker3 ``` 3. docker端口修改 ``` // 原来默认是9000端口指向容器内的80端口，现在10.102.119.42的80端口直接指向容器内80端口 // .env OMPOSE_PROJECT_NAME=sentry_onpremise SENTRY_EVENT_RETENTION_DAYS=90 # You can either use a port number or an IP:PORT combo for SENTRY_BIND # See https://docs.docker.com/compose/compose-file/#ports for more SENTRY_BIND=80 # Set SENTRY_MAIL_HOST to a valid FQDN (host/domain name) to be able to send emails! # SENTRY_MAIL_HOST=example.com SENTRY_IMAGE=getsentry/sentry:nightly SNUBA_IMAGE=getsentry/snuba:nightly RELAY_IMAGE=getsentry/relay:nightly SYMBOLICATOR_IMAGE=getsentry/symbolicator:nightly WAL2JSON_VERSION=latest SENTRY_EVENT_RETENTION_DAYS=30 // 数据保留最近30天 可以修改 ```',link:"/business/sentry#部署中的问题",textType:"code",routeTitle:"business > sentry",groupType:2},{text:"使用",link:"/business/sentry#使用",textType:"text",routeTitle:"business > sentry",groupType:2},{text:"1. 配置完成后，即可进入页面https://sentry-zl.domain/ 打开页面填入信息后即可进入sentry系统 2. config.yml配置 ```bash mail.backend: 'smtp' mail.host: 'smtp.domain' mail.port: 25 mail.username: 'xuzhe1@domain' mail.password: '*********' mail.use-tls: false",link:"/business/sentry#接入邮箱📮报警",textType:"code",routeTitle:"business > sentry",groupType:2},{text:"# The email address to send on behalf of mail.from: 'xuzhe1@domain' ``` - mail.backend：邮件发送方式； - mail.host: 邮件发送域名 ，使用的哪个邮箱可以去该邮箱文档中找到 smtp 发送域名； - mail.port: 邮件发送的端口号； - mail.username：用于 smtp 邮箱的账号； - mail.password：用于 smtp 邮箱的密码； - mail.use-tls：是否使用 tls 安全协议，这里填写 true 或 false，和 use-ssl 配置互斥； - mail.use-ssl：是否使用 ssl 安全协议，这里填写 true 或 false，和 use-tls 配置互斥； - mail.from：收到邮件时的发送人名称； 之后可以进入页面测试邮件发送https://sentry-zl.domain/manage/status/mail/",link:"/business/sentry#mail-use-ssl-true",textType:"code",routeTitle:"business > sentry",groupType:2},{text:"首先要修改 onpremise/sentry/config.yml system.url-prefix 配置，将其设置为我们访问的 Sentry 域名。 url-prefix 组成了项目的 DSN 地址，一定要保证格式正确。 `system.internal-url-prefix: 'https://sentry-zl.domain'` 然后是 /sentry/sentry.conf.py 文件下的 SSL/TLS 配置，将原来注释的部分全部打开。 ``` ###########",link:"/business/sentry#sentry通过https访问",textType:"code",routeTitle:"business > sentry",groupType:2},{text:"###########",link:"/business/sentry#ssl-tls",textType:"text",routeTitle:"business > sentry",groupType:2},{text:"If you're using a reverse SSL proxy, you should enable the X-Forwarded-Proto",link:"/business/sentry#if-you-re-using-a-reverse-ssl-proxy-you-should-enable-the-x-forwarded-proto",textType:"text",routeTitle:"business > sentry",groupType:2},{text:"SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https') SESSION_COOKIE_SECURE = True CSRF_COOKIE_SECURE = True SOCIAL_AUTH_REDIRECT_IS_HTTPS = True",link:"/business/sentry#header-and-enable-the-settings-below",textType:"text",routeTitle:"business > sentry",groupType:2},{text:"```",link:"/business/sentry#end-of-ssl-tls-settings",textType:"code",routeTitle:"business > sentry",groupType:2},{text:"org需要和sentry里面的对应",link:"/business/sentry#使用中的问题",textType:"text",routeTitle:"business > sentry",groupType:2},{text:'```bash docker compose down docker compose build docker compose up -d ``` 项目接入 Sentry 配置应在应用程序的生命周期中尽早进行。完成此操作后，Sentry 的 JavaScript SDK 会捕获所有未处理的异常和事务 ```bash npm install --save @sentry/vue @sentry/tracing Sentry.init({ // Sentry 项目的 dsn，可从项目设置中获取 dsn: \'https://23d1e539ef6c4cb6b14937fead1bf2ff@sentry-zl.domain/2\', // 初始参数配置内容 integrations: [new Integrations.BrowserTracing( routingInstrumentation: Sentry.vueRouterInstrumentation(router), tracingOrigins: ["localhost", "my-site-url.com", /^\\//], )], // 触发异常后发送给 Sentry 的概率 tracesSampleRate: 1.0, // 控制应捕获的面包屑(行为栈)的总量 maxBreadcrumbs: 20, // 规定上下文数据结构的深度，默认为 3 normalizeDepth: 100, // 版本信息 release: "common@1.0.0", // 环境信息 environment: process.env.NODE_ENV, // 钩子函数，在每次发送 event 前触发 beforeSend(event) { // 网页应用刷新后设置的变量会消失，所以我选择在 beforeSend 触发时插入用户信息 event.user = { userNick: "xz", }; return event; }, }); ```',link:"/business/sentry#docker重启",textType:"code",routeTitle:"business > sentry",groupType:2},{text:"```js //.npmrc sentrycli_cdnurl=https://npm.taobao.org/mirrors/sentry-cli // vue.config.js const SentryCliPlugin = require('@sentry/webpack-plugin'); new SentryCliPlugin({ include: './dist', ignoreFile: '.gitignore', release: 'production@1.2.0', ignore: ['node_modules', 'webpack.config.js'], configFile: '.sentryclirc', urlPrefix: '~/' }) // .sentryclirc [auth] token=c32f47d178064adeb3736742af42c34ebedf21aed43649bbb3d253a419e5c092 [defaults] url=https://sentry-zl.domain org=kso project=kso-zl-pc // package.json \"build\": \"vue-cli-service build && rm -fr ./dist/js/*.map\", ```",link:"/business/sentry#sentry-srouce-map",textType:"code",routeTitle:"business > sentry",groupType:2},{text:'有时我们不仅仅要收集异常信息，还需要在页面中打 log 来收集页面运行数据，这时可以用 Sentry.captureMessage(err[, obj]) api，进行传输日志。使用方法与 captureException 一致，建议将 level 设置为 Info，便于与异常区分开来，避免触发我们设置的异常警报。 ```js Sentry.captureMessage("Something went fundamentally wrong", { contexts: { text: { hahah: 22, }, }, level: Sentry.Severity.Info, }); ```',link:"/business/sentry#上传日志信息-手动上报",textType:"code",routeTitle:"business > sentry",groupType:2},{text:"捕捉异常还需要采集用户信息，在用户登录后需要通过 setUser 设置一下用户信息全局变量，如下所示 ```js Sentry.setUser({ tenant: { code: 12345, name: '测试公司', _id: 12345 }, orgAccount: { _id: 54321, orgName: '是机构啦' }, user: { _id: '8910JQ', loginName: '测试人员小Q' } }) ``` 通过 beforeSnd 插入用户信息 ```js Sentry.init({ ..., // 钩子函数，在每次发送 event 前触发 beforeSend(event) { // 在这里可根据业务情况发送用户信息 event.user = { userNick: 'xiaohu' }; return event; } }); ```",link:"/business/sentry#设置变量",textType:"code",routeTitle:"business > sentry",groupType:2},{text:"```javascript // 以下是 Sentry 定义的全局变量，可以直接使用 Sentry api 设置 Sentry.setUser(object); Sentry.tags(object); Sentry.extra(object); Sentry.level(object); Sentry.fingerprint(object); // 通过 setContext，设置 key 值，可自定义随事件传递的变量名 Sentry.setContext(key, context); ```",link:"/business/sentry#设置全局变量",textType:"code",routeTitle:"business > sentry",groupType:2},{text:"您可以为每个项目创建各种警报规则，并让 Sentry 知道您希望在应用程序中发生错误时通知的时间(when)、方式(how)和对象(whom)。 https://juejin.cn/post/7007607369962094599#heading-4",link:"/business/sentry#创建警报规则",textType:"text",routeTitle:"business > sentry",groupType:2},{text:"其中一种方式在source map上传的时候创建, 另一种脚手架可以创建 sentry-cli？ ```js new SentryCliPlugin({ include: './dist', ignoreFile: '.gitignore', release: process.env.RELEASE_VERSION, ignore: ['node_modules', 'vue.config.js'], configFile: '.sentryclirc', urlPrefix: '~/' // 需要和publicPath保持一致 }) ```",link:"/business/sentry#release",textType:"code",routeTitle:"business > sentry",groupType:2},{text:"前端捕获异常分为全局捕获和单点捕获 • 全局捕获代码集中，易于管理 • 单点捕获作为补充，对某些特殊情况进行捕获，但分散，不利于管理 1. 全局捕获 ◦ 通过全局的接口，将捕获代码集中写在一个地方，可以利用的接口又 ▪ window.addEventListener('error') ▪ window.addEventListener('unhandledrejection') ▪ document.addEventListener('click') ▪ 等 ◦ 框架级别的全局监听 ▪ 例如axios中使用interceptor进行拦击 ▪ vue、react都有自己的错误采集接口 ◦ 通过对全局函数进行封装包裹，实现在在调用该函数时自动捕获异常 ◦ 对实例方法重写(Patch), 在原有功能基础上包裹一层 ▪ 例如对setTimeout进行重写，在使用方法不变的情况下也可以捕获异常 2. 单点捕获 ◦ 在业务代码中对单个代码快进行包裹，活在逻辑流程中大点，实现有针对性的异常捕获 ◦ trye-catch ◦ 专门写一个函数来收集异常信息，在异常发生时，调用该函数 ◦ 专门写一个函数来包裹其他函数，得到一个新函数，该新函数运行结果和原函数一模一样，只是在发生异常时可以捕获异常 具体查看源码吧....",link:"/business/sentry#原理",textType:"text",routeTitle:"business > sentry",groupType:2},{text:"- Sentry Web 前端监控 - 官方最佳实践教程 - 基于Sentry搭建前端异常监控系统",link:"/business/sentry#资料",textType:"text",routeTitle:"business > sentry",groupType:2},{text:"",link:"/business/techselect#技术选型",textType:"text",routeTitle:"business > techselect",groupType:2},{text:"",link:"/business/whistle#whistle代理用法",textType:"text",routeTitle:"business > whistle",groupType:2},{text:"```bash npm install -g whistle w2 start -H 127.0.0.1 w2 start -n xx -w xx ```",link:"/business/whistle#安装启动",textType:"code",routeTitle:"business > whistle",groupType:2},{text:"- 修改header km.domain reqHeaders://{test-reqHeaders.json} km.domain resHeaders://{test-reqHeaders.json} ```test-reqHeaders.json ab: 111 ``` - 代理接口 -",link:"/business/whistle#常用操作",textType:"code",routeTitle:"business > whistle",groupType:2},{text:"local.zhiliao.domain/1.html html://E:\\xx\\test\\test.html local.zhiliao.domain/1.js js://E:\\xx\\test\\test.js local.zhiliao.domain/1.css css://E:\\xx\\test\\test.css",link:"/business/whistle#替换文件",textType:"text",routeTitle:"business > whistle",groupType:2},{text:"web.docer.wpscdn.cn resCors://* web.docer.wpscdn.cn enable://gzip",link:"/business/whistle#跨域-gzip",textType:"text",routeTitle:"business > whistle",groupType:2},{text:"wwo.domain resCookies://weboffice_branch=opf-amd-func-fp-fulltext-exporter",link:"/business/whistle#种cookie",textType:"text",routeTitle:"business > whistle",groupType:2},{text:'``` test.json { "code": 0, "msg": "ok", "data": [] } ``` local.zhiliao.domain replaceStatus://200 https://local.zhiliao.domain/a resBody://{test.json}',link:"/business/whistle#修改接口返回值",textType:"code",routeTitle:"business > whistle",groupType:2},{text:"接口延迟",link:"/business/whistle#接口延迟",textType:"text",routeTitle:"business > whistle",groupType:2},{text:"https://local.zhiliao.domain/api/zl/space/square/list reqDelay://1000",link:"/business/whistle#https-local-zhiliao-domain-api-zl-space-square-list-reqdelay-1000",textType:"text",routeTitle:"business > whistle",groupType:2},{text:"",link:"/business/whistle#https-local-zhiliao-domain-api-zl-space-square-list-resdelay-1000",textType:"text",routeTitle:"business > whistle",groupType:2},{text:"``` test.js alert(1); ``` local.zhiliao.domain/1.js jsAppend://{test.js}",link:"/business/whistle#修改js",textType:"code",routeTitle:"business > whistle",groupType:2},{text:"```test.css body{ background:red; } ``` local.zhiliao.domain/1.css cssAppend://{test.css}",link:"/business/whistle#修改css",textType:"code",routeTitle:"business > whistle",groupType:2},{text:"km.domain/api km.domain/api km.domain localhost:8080",link:"/business/whistle#前端页面走本地代码-接口走后端",textType:"text",routeTitle:"business > whistle",groupType:2},{text:"local.zhiliao.domain 127.0.0.1:8081",link:"/business/whistle#使用本地页面",textType:"text",routeTitle:"business > whistle",groupType:2},{text:"testapi-zl.domain log://",link:"/business/whistle#打印日志",textType:"text",routeTitle:"business > whistle",groupType:2},{text:"120.92.124.158 testapi-zl.domain",link:"/business/whistle#host",textType:"text",routeTitle:"business > whistle",groupType:2},{text:"local.zhiliao.domain ua://Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36 /wos.domain/ filter://hide local.zhiliao.domain ua://{aa} local.zhiliao.domain js://{js-test} local.zhiliao.domain log://{log-test} local.zhiliao.domain referer://https://vk.com/ local.zhiliao.domain reqHeaders://{req-headers}",link:"/business/whistle#修改ua",textType:"text",routeTitle:"business > whistle",groupType:2},{text:"https://local.zhiliao.domain/api https://10.90.129.185:9002/api",link:"/business/whistle#https-local-zhiliao-domain-api-https-10-90-129-185-9002-api",textType:"text",routeTitle:"business > whistle",groupType:2},{text:"``` test1.json origin: https://open-woa.domain/ methods: POST headers: x-csrftoken credentials: true maxAge: 300000 ``` https://open-xz.domain resCors://{test1.json} https://plussvr.domain resCors://https://local.zhiliao.domain",link:"/business/whistle#跨域",textType:"code",routeTitle:"business > whistle",groupType:2},{text:"https://wproxy.org/whistle/",link:"/business/whistle#参考",textType:"text",routeTitle:"business > whistle",groupType:2},{text:"",link:"/business/workflow#工作流程",textType:"text",routeTitle:"business > workflow",groupType:2},{text:"",link:"/business/workflow#分支管理",textType:"text",routeTitle:"business > workflow",groupType:2},{text:"• 从 Master 拉出 RC 分支 (由 Maintainer 执行) @ 1. 从 RC 分支拉出 Feat 分支 2. 在 Fork 的个人仓库上的 Feat 分支进行功能开发，向主仓库的 Feat 分支发 MR，review 后合入 3. Feat 分支开发完成后，进行功能测试，通过后，向 RC 发起 MR， review 后由测试合入 4. RC 分支开发完成后，进行合并测试 1. 未通过，打回 Feat 分支继续修改 2. 通过后，由测试向 Master 发起 MR 并合入 • Hotfix 分支从 Master 拉出，修复完成后合回 Master，并同步到 RC",link:"/business/workflow#分支流程管理",textType:"text",routeTitle:"business > workflow",groupType:2},{text:"将主仓库 fork 到自己账号后 拉取个人仓库代码，并将主仓库添加为 upstream ```bash git clone 个人仓库URL git remote add upstream 主仓库URL",link:"/business/workflow#fork-相关",textType:"code",routeTitle:"business > workflow",groupType:2},{text:"git remote -v ``` 如果本地是clone了主仓库，那么修改一下URL即可 ```bash git remote set-url origin 个人仓库URL git remote add upstream 主仓库URL",link:"/business/workflow#操作完成后可用该命令检查-origin-和-upstream-会各有2个-fetch-和-push",textType:"code",routeTitle:"business > workflow",groupType:2},{text:"git remote -v",link:"/business/workflow#操作完成后可用该命令检查-origin-和-upstream-会各有2个-fetch-和-push-1",textType:"text",routeTitle:"business > workflow",groupType:2},{text:"git fetch origin git push origin feat_a ```",link:"/business/workflow#然后将本地分支推到origin",textType:"code",routeTitle:"business > workflow",groupType:2},{text:"从 upstream 主仓库拉取最新分支，并推到 origin 个人仓库，并使用 --set-upstream 参数将该分支与 origin 绑定 ```bash git fetch upstream git checkout -b feat_a upstream/feat_a git push --set-upstream origin ```",link:"/business/workflow#主仓库新建分支后",textType:"code",routeTitle:"business > workflow",groupType:2},{text:"在发起一个 MR 之前，必须确保自己已同步最新代码，并解决完冲突 ```bash",link:"/business/workflow#mr之前",textType:"code",routeTitle:"business > workflow",groupType:2},{text:"git push origin",link:"/business/workflow#先将本地改动推向个人仓库-origin-避免-rebase-操作失误-弄丢了-commit",textType:"text",routeTitle:"business > workflow",groupType:2},{text:"git fetch upstream git rebase upstream/feat_a",link:"/business/workflow#这里以feat-a分支举例-实际操作时-是-rebase-mr-的目标分支",textType:"text",routeTitle:"business > workflow",groupType:2},{text:"git push origin -f ``` 除了发起 MR 之前，平时闲暇时可以多做该操作，同步越频繁，冲突时压力越小 也可以使用 git merge，两者的区别可参考 https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase-%E7%9A%84%E9%80%89%E6%8B%A9",link:"/business/workflow#rebase-成功-强推回-origin",textType:"code",routeTitle:"business > workflow",groupType:2},{text:"",link:"/business/workflow#开发流程",textType:"text",routeTitle:"business > workflow",groupType:2},{text:"管理好自己的仓库，使用 rebase -i 减少无谓的 commit，可参考 https://www.ruanyifeng.com/blog/2015/08/git-use-process.html",link:"/business/workflow#进阶",textType:"text",routeTitle:"business > workflow",groupType:2},{text:"lint eslint commitLint stylelint",link:"/business/workflow#前端开发规范lint",textType:"text",routeTitle:"business > workflow",groupType:2},{text:"",link:"/business/workflow#发版",textType:"text",routeTitle:"business > workflow",groupType:2},{text:"# 前端常见业务",link:"/business/前端常见业务#前端常见业务",textType:"text",routeTitle:"business > 前端常见业务",groupType:2},{text:"打包时sass - webpack打包时替换颜色值 - sass - less 运行时less换肤 - less - 维护两套样式文件 工作量大",link:"/business/前端常见业务#换肤",textType:"text",routeTitle:"business > 前端常见业务",groupType:2},{text:"无脑i18n",link:"/business/前端常见业务#国际化",textType:"text",routeTitle:"business > 前端常见业务",groupType:2},{text:"无脑选择rem,更为强大 vw",link:"/business/前端常见业务#移动端适配",textType:"text",routeTitle:"business > 前端常见业务",groupType:2},{text:"",link:"/business/工作流程#工作流程",textType:"text",routeTitle:"business > 工作流程",groupType:2},{text:"-",link:"/business/工作流程#分支管理",textType:"text",routeTitle:"business > 工作流程",groupType:2},{text:"",link:"/business/工作流程#发版流程",textType:"text",routeTitle:"business > 工作流程",groupType:2},{text:"",link:"/business/技术选型#技术选型",textType:"text",routeTitle:"business > 技术选型",groupType:2},{text:"- 取决于业务 - 从研发成本角度 - 使用成熟技术、熟练度高的技术生态比较完善 - 不盲目追求新技术，一个新技术出来一般要三年后才敢使用",link:"/business/技术选型#技术怎么选",textType:"text",routeTitle:"business > 技术选型",groupType:2},{text:"",link:"/business/技术选型#选vue还是react",textType:"text",routeTitle:"business > 技术选型",groupType:2},{text:"",link:"/business/rtc/video#toc",textType:"text",routeTitle:"rtc > video",groupType:2},{text:"- 播放 video.play() - 暂停 video.paused()",link:"/business/rtc/video#video-api",textType:"text",routeTitle:"rtc > video",groupType:2},{text:"",link:"/business/rtc/webRTC1#toc",textType:"text",routeTitle:"rtc > webRTC1",groupType:2},{text:"- WebRTC 采集传输 STUN(Session Traversal Utilities for NAT, TURN ChannelData Message) - video 播放 - 流媒体服务器 处理 - webSocket（ZegoExpressWebRTC-sdk） 发房间消息 在线人数",link:"/business/rtc/webRTC1#web直播",textType:"text",routeTitle:"rtc > webRTC1",groupType:2},{text:"- 采集 - 预览 - 传输 推流 - 显示 拉流 - 最小原型 ```javascript let constraints = { audio: true, video: { width: 1280, height: 720 } }; // 视频采集 const mediaStream = await navigator.mediaDevices.getUserMedia(constraints) // 预览 video.srcObject = mediaStream; video.onloadedmetadata = function(e) { video.play(); }; // 传输 WebRTC todo // 显示 video.srcObject = remoteStream; ```",link:"/business/rtc/webRTC1#实现原理",textType:"code",routeTitle:"rtc > webRTC1",groupType:2},{text:"1. 登录房间 2. 推流 3. 流更新获取拉流地址 ```javascript await zg.loginRoom(this.data.roomID, this.data.token, {userID: this.data.userID, userName: 'nick' + this.data.userID}); // 获取推流地址 const {url} = await zg.startPublishingStream(context.data.pushStreamID); // 推流到服务启后触发流更新 从streamList中拿到拉流src zg.on(\"roomStreamUpdate\", (roomID, updateType, streamList) => { // ... 解析出 remoteStream video.srcObject = remoteStream }); ```",link:"/business/rtc/webRTC1#实现步骤",textType:"code",routeTitle:"rtc > webRTC1",groupType:2},{text:"```html <!doctype html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"> <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"> <title>WebRTC直播</title> <script src=\"./ZegoExpressWebRTC-2.1.0.js\"><\/script> </head> <body> <video id=\"local-video\" autoplay width=\"500px\" height=\"500px\"></video> <video id=\"remote-video\" autoplay width=\"500px\" height=\"500px\"></video> <script> (async () => { try { let appID = 173****9272****706; // 请从官网控制台获取对应的appID let server = 'wss://webliveroom-test.zego.im/ws'; // 请从官网控制台获取对应的server地址，否则可能登录失败 const userId = '1'; const zg = new ZegoExpressEngine(appID, server); // console.log(zg) let url = 'https://wsliveroom-alpha.zego.im:8282/token'; const query = new URLSearchParams({ app_id: appID, id_name: userId }); url = url + '?' + query.toString(); // url = 'https://wsliveroom-alpha.zego.im:8282/token?app_id=1739272706&id_name=sample1613981824652' const res = await fetch(url); const token = await res.text(); const result = await zg.loginRoom('2', token, { userID: userId, userName: 'feng' }); console.warn({result}) let constraints = { camera: { AEC: true, AGC: true, ANS: true, audio: true, } } const localStream = await zg.createStream(constraints); let localVideo = document.getElementById('local-video'); let remoteVideo = document.getElementById('remote-video'); localVideo.srcObject = localStream; // localStream 为创建流获取的 MediaStream 对象 let t = zg.startPublishingStream('stream002', localStream) console.warn('publish stream' , t); zg.on('publisherStateUpdate',async result => { console.warn('publisherStateUpdate',result); const remoteStream = await zg.startPlayingStream(result.streamID); // remoteVideo为本地<video>或<audio>对象 remoteVideo.srcObject = remoteStream; // 推流状态更新回调 // ... }) zg.on('publishQualityUpdate', (streamID, stats) => { console.warn('publishQualityUpdate',result); // 推流质量回调 // ... }) } catch (e) { console.error(e); } })(); <\/script> </body> </html> ```",link:"/business/rtc/webRTC1#demo",textType:"code",routeTitle:"rtc > webRTC1",groupType:2},{text:"- 直播实现流程 - webrtc demo",link:"/business/rtc/webRTC1#参考",textType:"text",routeTitle:"rtc > webRTC1",groupType:2},{text:"",link:"/business/rtc/webRTC2#toc",textType:"text",routeTitle:"rtc > webRTC2",groupType:2},{text:"- 建立连接 - 会话生命周期",link:"/business/rtc/webRTC2#协议",textType:"text",routeTitle:"rtc > webRTC2",groupType:2},{text:'- navigator.mediaDevices.getUserMedia - 采集摄像头数据并播放 ```html <video style="width:800px;height: 800px;"></video> <script> // 想要获取一个最接近 1280x720 的相机分辨率 let constraints = { audio: true, video: { width: 1280, height: 720 } }; navigator.mediaDevices.getUserMedia(constraints) .then(function(mediaStream) { let video = document.querySelector(\'video\'); video.srcObject = mediaStream; video.onloadedmetadata = function(e) { video.play(); }; }) .catch(function(err) { console.log(err.name + ": " + err.message); }); // 总是在最后检查错误 <\/script> ```',link:"/business/rtc/webRTC2#流媒体采集",textType:"code",routeTitle:"rtc > webRTC2",groupType:2},{text:"Flv",link:"/business/rtc/webRTC2#rtmp",textType:"text",routeTitle:"rtc > webRTC2",groupType:2},{text:"srcObject",link:"/business/rtc/webRTC2#srcobject",textType:"text",routeTitle:"rtc > webRTC2",groupType:2},{text:"```javascript // 麦克风 getAudioTracks(): MediaStreamTrack[]; // 摄像头 getVideoTracks(): MediaStreamTrack[]; localStream.getTracks(); ``` - 获取媒体设备 navigator.mediaDevices.enumerateDevices() - RTCPeerConnection - peerConnection.addTrack(track, this.localStream);",link:"/business/rtc/webRTC2#streammedia",textType:"code",routeTitle:"rtc > webRTC2",groupType:2},{text:"- 房间信令 - webRTC信令",link:"/business/rtc/webRTC2#websocket做了-也做了webrtc信令",textType:"text",routeTitle:"rtc > webRTC2",groupType:2},{text:"",link:"/business/rtc/webRTC2#mediaplayer",textType:"text",routeTitle:"rtc > webRTC2",groupType:2},{text:"",link:"/business/rtc/webRTC2#video",textType:"text",routeTitle:"rtc > webRTC2",groupType:2},{text:"",link:"/business/rtc/webRTC2#audio",textType:"text",routeTitle:"rtc > webRTC2",groupType:2},{text:"",link:"/business/rtc/webRTC2#数据格式-mp4-flv",textType:"text",routeTitle:"rtc > webRTC2",groupType:2},{text:"- MDN WebRTC - MDN getUserMedia - w3c getusermedia",link:"/business/rtc/webRTC2#参考",textType:"text",routeTitle:"rtc > webRTC2",groupType:2},{text:"live-push rmtp flv",link:"/business/rtc/zego#live-player-第一次使用需要申请摄像头-麦克风权限-需要用户授权-scope-camera-、-scope-record",textType:"text",routeTitle:"rtc > zego",groupType:2},{text:"",link:"/devops/deploy#部署",textType:"text",routeTitle:"devops > deploy",groupType:3},{text:"- 端口问题 1. 开启端口 2. 验证端口 ```shell script telnet 127.0.0.1 3000 nc -l 3000 # 开启端口3000服务 nc 127.0.0.1 3000 #客户端连上改服务",link:"/devops/deploy#端口占用问题处理方式",textType:"code",routeTitle:"devops > deploy",groupType:3},{text:"``` 3. 查看端口 ```shell script #mac 查看端口被那个进程占用 port:8000 lsof -i:8000",link:"/devops/deploy#客户端输入的数据都会原样显示在服务器上",textType:"code",routeTitle:"devops > deploy",groupType:3},{text:'kill 871 #windows 查看端口被那个进程占用 port:8000 netstat -aon|findstr "8000"',link:"/devops/deploy#pid-871",textType:"text",routeTitle:"devops > deploy",groupType:3},{text:"taskkill /T /F /PID 871 ``` - 网络问题 1. 网络链路 2. 外网进入内网 3. 内网出外网 - 证书问题 ```js https 证书 ``` - nginx代理问题",link:"/devops/deploy#pid-871-1",textType:"code",routeTitle:"devops > deploy",groupType:3},{text:"",link:"/devops/git#git入门",textType:"text",routeTitle:"devops > git",groupType:3},{text:"常用操作 ```bash git branch 查看本地分支 git remote -v 查看仓库地址 git fetch origin 查询远程分支 git checkout feature/gonghang-privacy 检出远程分支 ``` git配置操作 ```git git config --list git config --global user.name feng git config --global user.email 123@qq.com ``` git查看状态和日志 ```shell git status #查看git状态 git log #查看日志 ``` git初始化 ```shell git init git clone ``` git从指定分支检出 ```shell git fetch origin git checkout -b mq_bug_20180524 origin/mq_bug_20180524 #本地分支 远程分支 ``` 删除暂存区 ``` git rm --cache . -r //删除整个暂存区 git rm --cache 文件名 ``` git提交代码 ``` git commit -m “消息” ``` git的对比 - git diff 工作区和暂存区 - git diff 分支名 工作区和历史区 - git diff --cached 暂存区和历史区比较 git撤销 ``` git checkout 文件名 //从暂存区中将工作区内容覆盖掉 ``` git回滚历史版本(本地的不是中央仓库) ```bash git reset --hard 版本号 git rest --hard HEAD^：回退到上一版； git rest --hard HEAD^^：回退到倒数第二版； git rest --hard 3628164：回退到commit id为3628164的版本； git reflog 查看所有版本 ``` 分支管理 ``` git branch //查看分支 git branch 分支名 //创建分支 git checkout 分支名 //切换分支 git branch -D 分支名 //删除分支 git checkout -b 分支名 //创建并切换分支 ``` linux文件操作 ``` rm -rf .git //删除文件夹 rm 2.txt mkdir git-project ls -al //显示隐藏文件 touch 1.txt //创建文件 cat 1.txt //查看文件 ``` vi编辑器 ``` i:插入模式 esc 退出编辑 :q!强制退出 :wq保存退出 ``` - 参考 git如何回滚远程仓库 git flow",link:"/devops/git#git操作",textType:"code",routeTitle:"devops > git",groupType:3},{text:"- Linux 命令大全",link:"/devops/index#运维",textType:"text",routeTitle:"devops > index",groupType:3},{text:"- 上传文件 `scp dist-admin.zip root@10.8.58.42:/data/webroot ` - 查histroy `history | grep mysql` - 重命名 `mv dist dist20210330` - 软链接 `ln -s /usr/local/bin/npx /usr/bin` - 查找应用路径 - kill端口进程 ```bash #mac 查看端口被那个进程占用 port:8000 lsof -i:8000",link:"/devops/index#常用指令",textType:"code",routeTitle:"devops > index",groupType:3},{text:'kill 871 #windows 查看端口被那个进程占用 port:8000 netstat -aon|findstr "8000"',link:"/devops/index#pid-871",textType:"text",routeTitle:"devops > index",groupType:3},{text:"taskkill /T /F /PID 871 ```",link:"/devops/index#pid-871-1",textType:"code",routeTitle:"devops > index",groupType:3},{text:"- jenkins",link:"/devops/jenkins#jenkins",textType:"text",routeTitle:"devops > jenkins",groupType:3},{text:"",link:"/devops/nginx#nginx",textType:"text",routeTitle:"devops > nginx",groupType:3},{text:"- 安装卸载 `brew install nginx` `brew uninstall nginx` - 常用指令 ```bash sudo nginx nginx -t nginx -help nginx -s reload nginx -s stop ```",link:"/devops/nginx#mac-nginx常见命令",textType:"code",routeTitle:"devops > nginx",groupType:3},{text:"```bash nginx -t nginx -s reload systemctl stop nginx systemctl restart nginx systemctl status nginx ```",link:"/devops/nginx#linux-nginx常用命令",textType:"code",routeTitle:"devops > nginx",groupType:3},{text:"```nginx server { listen 8080; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location /app/ { proxy_pass http://ip:port/app/; } location /console/ { proxy_pass http://ip:port/console/; } location /v2/ { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header x-forwarded-for $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:3000/v2/; } location / { proxy_pass http://ip:port/; } # 开启_ 下划线头 underscores_in_headers on; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } ```",link:"/devops/nginx#常见业务示例",textType:"code",routeTitle:"devops > nginx",groupType:3},{text:"- nginx指令 - nginx内置变量",link:"/devops/nginx#参考",textType:"text",routeTitle:"devops > nginx",groupType:3},{text:"",link:"/devops/shell#shell",textType:"text",routeTitle:"devops > shell",groupType:3},{text:"```bash",link:"/devops/shell#常用命令",textType:"code",routeTitle:"devops > shell",groupType:3},{text:"scp dist-admin.zip root@10.8.58.42:/data/webroot",link:"/devops/shell#上传文件",textType:"text",routeTitle:"devops > shell",groupType:3},{text:"history | grep mysql",link:"/devops/shell#查histroy",textType:"text",routeTitle:"devops > shell",groupType:3},{text:"mv dist dist20210330",link:"/devops/shell#重命名",textType:"text",routeTitle:"devops > shell",groupType:3},{text:"ln -s /usr/local/bin/npx /usr/bin",link:"/devops/shell#软链接",textType:"text",routeTitle:"devops > shell",groupType:3},{text:"",link:"/devops/shell#查找应用路径",textType:"text",routeTitle:"devops > shell",groupType:3},{text:"Histroy | grep mysql ```",link:"/devops/shell#查历史记录",textType:"code",routeTitle:"devops > shell",groupType:3},{text:'- zx使用支持node await语法，可以实现部署自动化 - 安装 `npm i -g zx` - 编写脚本 scripts/deploy.js ```js #!/usr/bin/env zx // 在控制台打印 $.verbose = true await $`ls`; cd(\'.vitepress/dist\'); await $`pwd`; await $`git push`; ``` - 和前端工程集成，在package.json中添加命令 `"deploy": " chmod +x script/deploy.js && script/deploy.js"`',link:"/devops/shell#zx用法",textType:"code",routeTitle:"devops > shell",groupType:3},{text:"",link:"/devops/包管理#包管理",textType:"text",routeTitle:"devops > 包管理",groupType:3},{text:"- 包的增删改查 ```shell sudo yum install <package> sudo yum remove <package> sudo yum update yum search <package> yum search <package> ``` - 参考",link:"/devops/包管理#yum",textType:"code",routeTitle:"devops > 包管理",groupType:3},{text:"",link:"/devops/常用指令#常用指令",textType:"text",routeTitle:"devops > 常用指令",groupType:3},{text:"# 版本管理",link:"/devops/版本管理#版本管理",textType:"text",routeTitle:"devops > 版本管理",groupType:3},{text:"- 安装NVM `curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash ` nvm 增删改查 ```bash nvm ls nvm install <version> nvm uninstall <version>",link:"/devops/版本管理#node版本管理",textType:"code",routeTitle:"devops > 版本管理",groupType:3},{text:"nvm alias default <version> ```",link:"/devops/版本管理#切换node版本",textType:"code",routeTitle:"devops > 版本管理",groupType:3},{text:"- 安装NVM `curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash ` nvm 增删改查 ```bash nvm ls nvm install <version> nvm uninstall <version>",link:"/devops/版本管理#node版本管理-1",textType:"code",routeTitle:"devops > 版本管理",groupType:3},{text:"nvm alias default <version> ```",link:"/devops/版本管理#切换node版本-1",textType:"code",routeTitle:"devops > 版本管理",groupType:3},{text:"",link:"/devops/端口管理#端口管理",textType:"text",routeTitle:"devops > 端口管理",groupType:3},{text:"- liunx ```bash netstat -nlut ``` - mac ```shell script",link:"/devops/端口管理#查看开启的端口",textType:"code",routeTitle:"devops > 端口管理",groupType:3},{text:"lsof -i:8000",link:"/devops/端口管理#查看端口被那个进程占用-port-8000",textType:"text",routeTitle:"devops > 端口管理",groupType:3},{text:"kill -9 871 ``` - windows ```shell script",link:"/devops/端口管理#pid-871",textType:"code",routeTitle:"devops > 端口管理",groupType:3},{text:'netstat -ano|findstr "8000"',link:"/devops/端口管理#查看端口被那个进程占用-port-8000-1",textType:"text",routeTitle:"devops > 端口管理",groupType:3},{text:"taskkill /T /F /PID 871 ```",link:"/devops/端口管理#pid-871-1",textType:"code",routeTitle:"devops > 端口管理",groupType:3},{text:"- 远程登录主机 ```shell script telnet 127.0.0.1",link:"/devops/端口管理#远程主机端口是否启用",textType:"code",routeTitle:"devops > 端口管理",groupType:3},{text:"``` - 判断端口是否开启 - 建立tcp连接和通信 ```shell script telnet 172.0.0.1 8000 ``` - nc ```bash nc -l 3000 # 开启端口3000服务 nc 127.0.0.1 3000 #客户端连上改服务",link:"/devops/端口管理#输入账号-密码-登录主机",textType:"code",routeTitle:"devops > 端口管理",groupType:3},{text:"```",link:"/devops/端口管理#客户端输入的数据都会原样显示在服务器上",textType:"code",routeTitle:"devops > 端口管理",groupType:3},{text:"",link:"/devops/自动化部署#自动化部署",textType:"text",routeTitle:"devops > 自动化部署",groupType:3},{text:"",link:"/devops/自动化部署#登录",textType:"text",routeTitle:"devops > 自动化部署",groupType:3},{text:'- linux `yum install expect` - mac `brew install expect` - 问题 1. brew安装失败问题 `Running Homebrew as root is extremely dangerous and no longer supported.` 2. 解决方法 ```shell script $ sudo chown -R `whoami` /usr/local/Homebrew/ $ sudo chown -R $(whoami) $(brew --prefix)/* $ sudo mkdir /usr/local/Frameworks $ sudo chown -R `whoami` /usr/local/Frameworks/ ``` ```shell script #! /usr/bin/expect spawn ./login72.sh send "cd /home/xxx/\\r" expect "*root@*" send "git pull\\r" expect "*Username for*" send "xxx\\r" expect "*Password for*" send "xxx\\r" expect "*root@*" send "npm run build\\r" expect "*root@*" send "pm2 restart node\\r" interact ```',link:"/devops/自动化部署#安装shell-expect",textType:"code",routeTitle:"devops > 自动化部署",groupType:3},{text:"",link:"/devops/进程原理#进程管理",textType:"text",routeTitle:"devops > 进程原理",groupType:3},{text:"```bash",link:"/devops/进程原理#linux进程",textType:"code",routeTitle:"devops > 进程原理",groupType:3},{text:"ps| grep node kill -9 pid ```",link:"/devops/进程原理#查看进程",textType:"code",routeTitle:"devops > 进程原理",groupType:3},{text:"- 安装 `node i -g pm2`",link:"/devops/进程原理#pm2",textType:"text",routeTitle:"devops > 进程原理",groupType:3},{text:"```shell pm2 start pm2-config.json pm2 restart all pm2 stop all pm2 delete 1 2 pm2 log 1 2 ```",link:"/devops/进程原理#常用命令",textType:"code",routeTitle:"devops > 进程原理",groupType:3},{text:'```shell { "apps": { "name": "wuwu", // 项目名 "script": "./bin/www", // 执行文件 "cwd": "./", // 根目录 "args": "", // 传递给脚本的参数 "interpreter": "", // 指定的脚本解释器 "interpreter_args": "", // 传递给解释器的参数 "watch": true, // 是否监听文件变动然后重启 "ignore_watch": [ // 不用监听的文件 "node_modules", "logs" ], "exec_mode": "cluster_mode", // 应用启动模式，支持fork和cluster模式 "instances": 4, // 应用启动实例个数，仅在cluster模式有效 默认为fork；或者 max "max_memory_restart": 8, // 最大内存限制数，超出自动重启 "error_file": "./logs/app-err.log", // 错误日志文件 "out_file": "./logs/app-out.log", // 正常日志文件 "merge_logs": true, // 设置追加日志而不是新建日志 "log_date_format": "YYYY-MM-DD HH:mm:ss", // 指定日志文件的时间格式 "min_uptime": "60s", // 应用运行少于时间被认为是异常启动 "max_restarts": 30, // 最大异常重启次数，即小于min_uptime运行时间重启次数； "autorestart": true, // 默认为true, 发生异常的情况下自动重启 "cron_restart": "", // crontab时间格式重启应用，目前只支持cluster模式; "restart_delay": "60s" // 异常重启情况下，延时重启时间 "env": { "NODE_ENV": "production", // 环境参数，当前指定为生产环境 process.env.NODE_ENV "REMOTE_ADDR": "爱上大声地" // process.env.REMOTE_ADDR }, "env_dev": { "NODE_ENV": "development", // 环境参数，当前指定为开发环境 pm2 start app.js --env_dev "REMOTE_ADDR": "" }, "env_test": { // 环境参数，当前指定为测试环境 pm2 start app.js --env_test "NODE_ENV": "test", "REMOTE_ADDR": "" } } } ```',link:"/devops/进程原理#config",textType:"code",routeTitle:"devops > 进程原理",groupType:3},{text:"",link:"/faq/index#whistle抓本地包",textType:"text",routeTitle:"faq > index",groupType:0},{text:"",link:"/frontend/axios#axios",textType:"text",routeTitle:"frontend > axios",groupType:0},{text:"Promise based HTTP client for the browser and node.js 基于Promise的httpClient兼容浏览器和node",link:"/frontend/axios#定位",textType:"text",routeTitle:"frontend > axios",groupType:0},{text:"- 支持promise - 同构代码（跨端） 浏览器上基于XMLHttpRequest node上基于http - 请求响应拦截器(洋葱模型) - 支持防XSRF攻击 - 取消请求",link:"/frontend/axios#特性",textType:"text",routeTitle:"frontend > axios",groupType:0},{text:"请求拦截器 -> 发请求 -> 响应拦截器 注意请求拦截器和响应拦截器都是数组",link:"/frontend/axios#洋葱模型",textType:"text",routeTitle:"frontend > axios",groupType:0},{text:"- 要加上responseType: 'arraybuffer' ```js let res = await axios.post(`https://api.weixin.qq.com/cgi-bin/wxaapp/createwxaqrcode?access_token=${access_token}`, { 'path': 'page/index/index', 'width': 430 }, { responseType: 'arraybuffer' }); response.setHeader('content-type',res.headers['content-type']) response.send(res.data) response.end(); ```",link:"/frontend/axios#axios请求图片",textType:"code",routeTitle:"frontend > axios",groupType:0},{text:"- axios.defaults保存axios的全局配置 - axios.get、post等方法会使用axios的全局配置 - axios.create创建axios实例会使用全部配置 - axios.default是为了在ts中兼容默认导入 ```js // Allow use of default import syntax in TypeScript module.exports.default = axios; ```",link:"/frontend/axios#全部配置axios-defaults",textType:"code",routeTitle:"frontend > axios",groupType:0},{text:"- axios对象不是Axios实例 ```js /** * Create an instance of Axios * * @param {Object} defaultConfig The default config for the instance * @return {Axios} A new instance of Axios */ function createInstance(defaultConfig) { var context = new Axios(defaultConfig); var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance utils.extend(instance, Axios.prototype, context); // Copy context to instance utils.extend(instance, context); return instance; } var axios = createInstance(defaults); ```",link:"/frontend/axios#axios对象",textType:"code",routeTitle:"frontend > axios",groupType:0},{text:"```js // 浏览器使用XMLHttpRequest node使用http function getDefaultAdapter() { var adapter; if (typeof XMLHttpRequest !== 'undefined') { // For browsers use XHR adapter adapter = require('./adapters/xhr'); } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') { // For node use HTTP adapter adapter = require('./adapters/http'); } return adapter; } ```",link:"/frontend/axios#axios适配器",textType:"code",routeTitle:"frontend > axios",groupType:0},{text:"- delete、get、head、options没有body参数 - post、put、patch可以携带body参数 - 参考axios.delete发body参数issue ```js // Provide aliases for supported request methods utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) { /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) { return this.request(mergeConfig(config || {}, { method: method, url: url, data: (config || {}).data })); }; }); utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) { /*eslint func-names:0*/ Axios.prototype[method] = function(url, data, config) { return this.request(mergeConfig(config || {}, { method: method, url: url, data: data })); }; }); // axios delete发送body参数 axios.request({ method: 'delete', url, data }) ```",link:"/frontend/axios#axios方法",textType:"code",routeTitle:"frontend > axios",groupType:0},{text:"",link:"/frontend/axios#核心函数",textType:"text",routeTitle:"frontend > axios",groupType:0},{text:"```js // XMLHttpRequest封装 module.exports = function xhrAdapter(config) { return new Promise(function dispatchXhrRequest(resolve, reject) { var requestData = config.data; var requestHeaders = config.headers; if (utils.isFormData(requestData)) { delete requestHeaders['Content-Type']; // Let the browser set it } var request = new XMLHttpRequest(); // HTTP basic authentication if (config.auth) { var username = config.auth.username || ''; var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : ''; requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password); } var fullPath = buildFullPath(config.baseURL, config.url); request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS request.timeout = config.timeout; // Listen for ready state request.onreadystatechange = function handleLoad() { if (!request || request.readyState !== 4) { return; } // The request errored out and we didn't get a response, this will be // handled by onerror instead // With one exception: request that using file: protocol, most browsers // will return status as 0 even though it's a successful request if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) { return; } // Prepare the response var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null; var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response; var response = { data: responseData, status: request.status, statusText: request.statusText, headers: responseHeaders, config: config, request: request }; settle(resolve, reject, response); // Clean up request request = null; }; // Handle browser request cancellation (as opposed to a manual cancellation) request.onabort = function handleAbort() { if (!request) { return; } reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request request = null; }; // Handle low level network errors request.onerror = function handleError() { // Real errors are hidden from us by the browser // onerror should only fire if it's a network error reject(createError('Network Error', config, null, request)); // Clean up request request = null; }; // Handle timeout request.ontimeout = function handleTimeout() { var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded'; if (config.timeoutErrorMessage) { timeoutErrorMessage = config.timeoutErrorMessage; } reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request)); // Clean up request request = null; }; // Add xsrf header // This is only done if running in a standard browser environment. // Specifically not if we're in a web worker, or react-native. if (utils.isStandardBrowserEnv()) { // Add xsrf header var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined; if (xsrfValue) { requestHeaders[config.xsrfHeaderName] = xsrfValue; } } // Add headers to the request if ('setRequestHeader' in request) { utils.forEach(requestHeaders, function setRequestHeader(val, key) { if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') { // Remove Content-Type if data is undefined delete requestHeaders[key]; } else { // Otherwise add header to the request request.setRequestHeader(key, val); } }); } // Add withCredentials to request if needed if (!utils.isUndefined(config.withCredentials)) { request.withCredentials = !!config.withCredentials; } // Add responseType to request if needed if (config.responseType) { try { request.responseType = config.responseType; } catch (e) { // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2. // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function. if (config.responseType !== 'json') { throw e; } } } // Handle progress if needed if (typeof config.onDownloadProgress === 'function') { request.addEventListener('progress', config.onDownloadProgress); } // Not all browsers support upload events if (typeof config.onUploadProgress === 'function' && request.upload) { request.upload.addEventListener('progress', config.onUploadProgress); } if (config.cancelToken) { // Handle cancellation config.cancelToken.promise.then(function onCanceled(cancel) { if (!request) { return; } request.abort(); reject(cancel); // Clean up request request = null; }); } if (!requestData) { requestData = null; } // Send the request request.send(requestData); }); }; ```",link:"/frontend/axios#浏览器端",textType:"code",routeTitle:"frontend > axios",groupType:0},{text:"```js //http封装 module.exports = function httpAdapter(config) { return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) { var resolve = function resolve(value) { resolvePromise(value); }; var reject = function reject(value) { rejectPromise(value); }; var data = config.data; var headers = config.headers; // Set User-Agent (required by some servers) // Only set header if it hasn't been set in config // See https://github.com/axios/axios/issues/69 if (!headers['User-Agent'] && !headers['user-agent']) { headers['User-Agent'] = 'axios/' + pkg.version; } if (data && !utils.isStream(data)) { if (Buffer.isBuffer(data)) { // Nothing to do... } else if (utils.isArrayBuffer(data)) { data = Buffer.from(new Uint8Array(data)); } else if (utils.isString(data)) { data = Buffer.from(data, 'utf-8'); } else { return reject(createError( 'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream', config )); } // Add Content-Length header if data exists headers['Content-Length'] = data.length; } // HTTP basic authentication var auth = undefined; if (config.auth) { var username = config.auth.username || ''; var password = config.auth.password || ''; auth = username + ':' + password; } // Parse url var fullPath = buildFullPath(config.baseURL, config.url); var parsed = url.parse(fullPath); var protocol = parsed.protocol || 'http:'; if (!auth && parsed.auth) { var urlAuth = parsed.auth.split(':'); var urlUsername = urlAuth[0] || ''; var urlPassword = urlAuth[1] || ''; auth = urlUsername + ':' + urlPassword; } if (auth) { delete headers.Authorization; } var isHttpsRequest = isHttps.test(protocol); var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent; var options = { path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, ''), method: config.method.toUpperCase(), headers: headers, agent: agent, agents: { http: config.httpAgent, https: config.httpsAgent }, auth: auth }; if (config.socketPath) { options.socketPath = config.socketPath; } else { options.hostname = parsed.hostname; options.port = parsed.port; } var proxy = config.proxy; if (!proxy && proxy !== false) { var proxyEnv = protocol.slice(0, -1) + '_proxy'; var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()]; if (proxyUrl) { var parsedProxyUrl = url.parse(proxyUrl); var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY; var shouldProxy = true; if (noProxyEnv) { var noProxy = noProxyEnv.split(',').map(function trim(s) { return s.trim(); }); shouldProxy = !noProxy.some(function proxyMatch(proxyElement) { if (!proxyElement) { return false; } if (proxyElement === '*') { return true; } if (proxyElement[0] === '.' && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) { return true; } return parsed.hostname === proxyElement; }); } if (shouldProxy) { proxy = { host: parsedProxyUrl.hostname, port: parsedProxyUrl.port, protocol: parsedProxyUrl.protocol }; if (parsedProxyUrl.auth) { var proxyUrlAuth = parsedProxyUrl.auth.split(':'); proxy.auth = { username: proxyUrlAuth[0], password: proxyUrlAuth[1] }; } } } } if (proxy) { options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : ''); setProxy(options, proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path); } var transport; var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true); if (config.transport) { transport = config.transport; } else if (config.maxRedirects === 0) { transport = isHttpsProxy ? https : http; } else { if (config.maxRedirects) { options.maxRedirects = config.maxRedirects; } transport = isHttpsProxy ? httpsFollow : httpFollow; } if (config.maxBodyLength > -1) { options.maxBodyLength = config.maxBodyLength; } // Create the request var req = transport.request(options, function handleResponse(res) { if (req.aborted) return; // uncompress the response body transparently if required var stream = res; // return the last request in case of redirects var lastRequest = res.req || req; // if no content, is HEAD request or decompress disabled we should not decompress if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) { switch (res.headers['content-encoding']) { /*eslint default-case:0*/ case 'gzip': case 'compress': case 'deflate': // add the unzipper to the body stream processing pipeline stream = stream.pipe(zlib.createUnzip()); // remove the content-encoding in order to not confuse downstream operations delete res.headers['content-encoding']; break; } } var response = { status: res.statusCode, statusText: res.statusMessage, headers: res.headers, config: config, request: lastRequest }; if (config.responseType === 'stream') { response.data = stream; settle(resolve, reject, response); } else { var responseBuffer = []; stream.on('data', function handleStreamData(chunk) { responseBuffer.push(chunk); // make sure the content length is not over the maxContentLength if specified if (config.maxContentLength > -1 && Buffer.concat(responseBuffer).length > config.maxContentLength) { stream.destroy(); reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded', config, null, lastRequest)); } }); stream.on('error', function handleStreamError(err) { if (req.aborted) return; reject(enhanceError(err, config, null, lastRequest)); }); stream.on('end', function handleStreamEnd() { var responseData = Buffer.concat(responseBuffer); if (config.responseType !== 'arraybuffer') { responseData = responseData.toString(config.responseEncoding); if (!config.responseEncoding || config.responseEncoding === 'utf8') { responseData = utils.stripBOM(responseData); } } response.data = responseData; settle(resolve, reject, response); }); } }); // Handle errors req.on('error', function handleRequestError(err) { if (req.aborted && err.code !== 'ERR_FR_TOO_MANY_REDIRECTS') return; reject(enhanceError(err, config, null, req)); }); // Handle request timeout if (config.timeout) { // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system. // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET. // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up. // And then these socket which be hang up will devoring CPU little by little. // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect. req.setTimeout(config.timeout, function handleRequestTimeout() { req.abort(); reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', req)); }); } if (config.cancelToken) { // Handle cancellation config.cancelToken.promise.then(function onCanceled(cancel) { if (req.aborted) return; req.abort(); reject(cancel); }); } // Send the request if (utils.isStream(data)) { data.on('error', function handleStreamError(err) { reject(enhanceError(err, config, null, req)); }).pipe(req); } else { req.end(data); } }); }; ```",link:"/frontend/axios#node端",textType:"code",routeTitle:"frontend > axios",groupType:0},{text:"```js let config = { xsrfCookieName: 'XSRF-TOKEN', xsrfHeaderName: 'X-XSRF-TOKEN' } if (utils.isStandardBrowserEnv()) { // Add xsrf header var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined; if (xsrfValue) { requestHeaders[config.xsrfHeaderName] = xsrfValue; } } ```",link:"/frontend/axios#axios防御xsrf攻击",textType:"code",routeTitle:"frontend > axios",groupType:0},{text:"- jquery官网 - axios github",link:"/frontend/axios#参考",textType:"text",routeTitle:"frontend > axios",groupType:0},{text:"- lp-logger 库",link:"/frontend/console#console",textType:"text",routeTitle:"frontend > console",groupType:0},{text:"",link:"/frontend/cookie#cookie字段",textType:"text",routeTitle:"frontend > cookie",groupType:0},{text:'```js //添加cookie document.cookie="name=feng" //修改cookie document.cookie="name=feng1" //删除cookie //通过expires和max-age来删除 ```',link:"/frontend/cookie#js操作cookie",textType:"code",routeTitle:"frontend > cookie",groupType:0},{text:"",link:"/frontend/cookie#浏览器开发者工具操作cookie",textType:"text",routeTitle:"frontend > cookie",groupType:0},{text:'服务器添加 设置头 set-cookie sessionId=123 ```java import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletResponse; /** * Cookie工具类 */ public class CookieUtil { /** * 设置HttpOnly Cookie * @param response HTTP响应 * @param cookie Cookie对象 * @param isHTTPOnly 是否为HttpOnly */ public static void addCookie(HttpServletResponse response, Cookie cookie, boolean isHttpOnly) { String name = cookie.getName();//Cookie名称 String value = cookie.getValue();//Cookie值 int maxAge = cookie.getMaxAge();//最大生存时间(毫秒,0代表删除,-1代表与浏览器会话一致) String path = cookie.getPath();//路径 String domain = cookie.getDomain();//域 boolean isSecure = cookie.getSecure();//是否为安全协议信息 StringBuilder buffer = new StringBuilder(); buffer.append(name).append("=").append(value).append(";"); if (maxAge == 0) { buffer.append("Expires=Thu Jan 01 08:00:00 CST 1970;"); } else if (maxAge > 0) { buffer.append("Max-Age=").append(maxAge).append(";"); } if (domain != null) { buffer.append("domain=").append(domain).append(";"); } if (path != null) { buffer.append("path=").append(path).append(";"); } if (isSecure) { buffer.append("secure;"); } if (isHttpOnly) { buffer.append("HTTPOnly;"); } response.addHeader("Set-Cookie", buffer.toString()); } } ```',link:"/frontend/cookie#服务器操作cookie",textType:"code",routeTitle:"frontend > cookie",groupType:0},{text:'```typescript interface Storage { /** * Returns the number of key/value pairs currently present in the list associated with the object. */ readonly length: number; /** * Empties the list associated with the object of all key/value pairs, if there are any. */ clear(): void; /** * Returns the current value associated with the given key, or null if the given key does not exist in the list associated with the object. */ getItem(key: string): string | null; /** * Returns the name of the nth key in the list, or null if n is greater than or equal to the number of key/value pairs in the object. */ key(index: number): string | null; /** * Removes the key/value pair with the given key from the list associated with the object, if a key/value pair with the given key exists. */ removeItem(key: string): void; /** * Sets the value of the pair identified by key to value, creating a new key/value pair if none existed for key previously. * * Throws a "QuotaExceededError" DOMException exception if the new value couldn\'t be set. (Setting could fail if, e.g., the user has disabled storage for the site, or if the quota has been exceeded.) */ setItem(key: string, value: string): void; [name: string]: any; } declare var sessionStorage: Storage; declare var localStorage: Storage; ``` | 特性 | cookie| localStorage | sessionStorage |indexDB|| 数据生命周期 | 一般由服务器生成，可以设置过期时间 |除非被清理，否则一直存在 |domain/path匹配不到tab页时清除 |除非被清理，否则一直存在| | 数据存储大小 | 4K |5M |5M |无限| | 与服务端通信 | 每次都会携带在 header 中，对于请求性能影响 |不参与 |不参与 |不参与|',link:"/frontend/cookie#storage",textType:"code",routeTitle:"frontend > cookie",groupType:0},{text:"",link:"/frontend/CSS#css",textType:"text",routeTitle:"frontend > CSS",groupType:0},{text:"- CSS 选择器游戏 - CSS 晚餐游戏 - Try CSS Selector",link:"/frontend/CSS#css选择器",textType:"text",routeTitle:"frontend > CSS",groupType:0},{text:"# dom",link:"/frontend/dom#dom",textType:"text",routeTitle:"frontend > dom",groupType:0},{text:"",link:"/frontend/dom#浏览器工作原理",textType:"text",routeTitle:"frontend > dom",groupType:0},{text:"",link:"/frontend/dom#dom常见操作",textType:"text",routeTitle:"frontend > dom",groupType:0},{text:"1. 捕获阶段 window->target过程 2. 事件阶段 事件执行 3. 冒泡阶段 target->window过程",link:"/frontend/dom#事件转发和事件流",textType:"text",routeTitle:"frontend > dom",groupType:0},{text:"```js let event = MouseEvent(); //停止传播 event.stopPropagation(); //阻止默认行为 例如：表单提交和重置，链接跳转，单选框复选框勾选 event.preventDefault(); defaultPrevented ```",link:"/frontend/dom#默认行为和可取消事件",textType:"code",routeTitle:"frontend > dom",groupType:0},{text:"DOM3规范 UI Event规范",link:"/frontend/dom#参考",textType:"text",routeTitle:"frontend > dom",groupType:0},{text:"",link:"/frontend/fetch#fetch",textType:"text",routeTitle:"frontend > fetch",groupType:0},{text:"请求库",link:"/frontend/fetch#请求库",textType:"text",routeTitle:"frontend > fetch",groupType:0},{text:"- XMLHttpRequest - axios - fetch",link:"/frontend/fetch#浏览器端使用",textType:"text",routeTitle:"frontend > fetch",groupType:0},{text:"- axios - node-fetch - request 1. 浏览器自带fetch，浏览器上使用有跨域问题 2. node需安装node-fetch,没有跨域问题",link:"/frontend/fetch#node中使用",textType:"text",routeTitle:"frontend > fetch",groupType:0},{text:"- fetch使用 Promise,不适用回调、写代码简洁 - fetch采用模块化设计,API分散在Response对象、Request对象、Headers对象,设计更合理 - fetch通过数据流处理数据，分块读取，有利于提高网站性能表现，减少内存占用,对于请求大文件或者网速慢的场景相当有用)",link:"/frontend/fetch#fetch-vs-xmlhttprequest",textType:"text",routeTitle:"frontend > fetch",groupType:0},{text:"- fetch ```javascript let param = new URLSearchParams({ roomId:1, uid:'1', }) let url = 'http://localhost:3000/v3/checkin'+'?'+param.toString(); fetch(url).then(response => response.json()) .then(data => console.log(data)); ``` - axios ```javascript let url = 'http://localhost:3000/v3/checkin'; axios.request( { url, method: 'GET', params:{ roomId:1, uid:'1', }, }).then(response => response.data) ```",link:"/frontend/fetch#get请求",textType:"code",routeTitle:"frontend > fetch",groupType:0},{text:"- fetch ```javascript let url = 'http://localhost:3000/v3/checkin'; fetch(url, { headers: { 'Content-Type': 'application/json', }, method: 'PUT', body:JSON.stringify({ 'roomId': 1, 'uid': '1', 'info': '{name:\"xx\",age:2}', }), }).then(response => response.json()) .then(data => console.log(data)); ``` 注意Body类型 `Body = Blob | BufferSource | FormData | URLSearchParams | ReadableStream<Uint8Array> | string;` Body不能为对象,需用 JSON.stringify(data) - axios ```javascript let url = 'http://localhost:3000/v3/checkin'; axios.request( { url, method: 'POST', data:{ 'roomId': 1, 'uid': '1', 'info': '{name:\"xx\",age:2}', }, }).then(response => response.data) ```",link:"/frontend/fetch#post、put请求",textType:"code",routeTitle:"frontend > fetch",groupType:0},{text:"- fetch ```javascript let url = 'http://localhost:3000/v3/checkin'; const formData = new FormData(); form.append('moduleName', 'test'); form.append('img', fs.createReadStream(__dirname + '/1.jpg')); fetch(url, { method: 'POST', body:formData }).then(response => response.json()) .then(data => console.log(data)); ``` - axios ```javascript let url = 'http://localhost:3000/v3/checkin'; const formData = new FormData(); form.append('moduleName', 'test'); form.append('img', fs.createReadStream(__dirname + '/1.jpg')); axios.request( { url, method: 'POST', data:formData, headers:formData.getHeaders() }).then(response => response.data) ``` - 有formData时不需要设置content-type",link:"/frontend/fetch#post-formdata",textType:"code",routeTitle:"frontend > fetch",groupType:0},{text:"- formData流处理注意 流只能读一次，重置读要做处理 - formData.append('img', fs.createReadStream(__dirname + '/1.jpg'));",link:"/frontend/fetch#关于formdata",textType:"text",routeTitle:"frontend > fetch",groupType:0},{text:"- Fetch API 教程 - axios - node-fetch - request - FormData",link:"/frontend/fetch#参考文件",textType:"text",routeTitle:"frontend > fetch",groupType:0},{text:"- 优质网站 - 编程经验干货 - 业务博客 - 深入浅出浏览器渲染原理 - Cookie - 深入理解浏览器的缓存机制 - 九种跨域方式实现原理 - Web 实时推送技术的总结 - Chrome 浏览器渲染全过程 - Devops，CI/CD - Nginx一网打尽：动静分离、压缩、缓存、黑白名单、跨域、高可用、性能优化 - sentry-接入",link:"/frontend/index#优质前端内容汇总",textType:"text",routeTitle:"frontend > index",groupType:0},{text:"",link:"/frontend/JS核心#",textType:"text",routeTitle:"frontend > JS核心",groupType:0},{text:"- 事件循环过程 1.先执行同步代码 2.执行完所有的微任务 3.执行一个宏任务 ```javascript setTimeout(()=>{ console.log('macrotask') },0); queueMicrotask(() => { /* 微任务中将运行的代码 */ console.log('microTask1') }); queueMicrotask(() => { /* 微任务中将运行的代码 */ console.log('microTask2') }); console.log('synchronize') //输出结果 // synchronize // microTask1 // microTask2 // macrotask ``` - 事件循环六个阶段 - 参考 node事件循环 深入理解js事件循环机制（Node.js篇） nodejs中的event loop",link:"/frontend/JS核心#原型链",textType:"code",routeTitle:"frontend > JS核心",groupType:0},{text:"",link:"/frontend/Promise常见面试题#",textType:"text",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:"请你编写一个异步函数 `promisePool` ，它接收一个异步函数数组 `functions` 和 池限制 `n`。它应该返回一个 `promise` 对象，当所有输入函数都执行完毕后，`promise` 对象就执行完毕。 池限制 定义是一次可以挂起的最多 `promise` 对象的数量。`promisePool` 应该开始执行尽可能多的函数，并在旧的 `promise` 执行完毕后继续执行新函数。`promisePool` 应该先执行 `functions[i]`，再执行 `functions[i + 1]`，然后执行 `functions[i + 2]`，等等。当最后一个 `promise` 执行完毕时，`promisePool` 也应该执行完毕。 例如，如果 `n = 1` , `promisePool` 在序列中每次执行一个函数。然而，如果 `n = 2` ，它首先执行两个函数。当两个函数中的任何一个执行完毕后，再执行第三个函数(如果它是可用的)，依此类推，直到没有函数要执行为止。 你可以假设所有的 `functions` 都不会被拒绝。对于 `promisePool` 来说，返回一个可以解析任何值的 `promise` 都是可以接受的。 ``` 示例 1： 输入： functions = [ () => new Promise(res => setTimeout(res, 300)), () => new Promise(res => setTimeout(res, 400)), () => new Promise(res => setTimeout(res, 200)) ] n = 2 输出：[[300,400,500],500] 解释 传递了三个函数。它们的睡眠时间分别为 300ms、 400ms 和 200ms。 在 t=0 时，执行前两个函数。池大小限制达到 2。 当 t=300 时，第一个函数执行完毕后，执行第3个函数。池大小为 2。 在 t=400 时，第二个函数执行完毕后。没有什么可执行的了。池大小为 1。 在 t=500 时，第三个函数执行完毕后。池大小为 0，因此返回的 promise 也执行完成。 示例 2： 输入： functions = [ () => new Promise(res => setTimeout(res, 300)), () => new Promise(res => setTimeout(res, 400)), () => new Promise(res => setTimeout(res, 200)) ] n = 5 输出：[[300,400,200],400] 解释： 在 t=0 时，所有3个函数都被执行。池的限制大小 5 永远不会满足。 在 t=200 时，第三个函数执行完毕后。池大小为 2。 在 t=300 时，第一个函数执行完毕后。池大小为 1。 在 t=400 时，第二个函数执行完毕后。池大小为 0，因此返回的 promise 也执行完成。 示例 3： 输入： functions = [ () => new Promise(res => setTimeout(res, 300)), () => new Promise(res => setTimeout(res, 400)), () => new Promise(res => setTimeout(res, 200)) ] n = 1 输出：[[300,700,900],900] 解释： 在 t=0 时，执行第一个函数。池大小为1。 当 t=300 时，第一个函数执行完毕后，执行第二个函数。池大小为 1。 当 t=700 时，第二个函数执行完毕后，执行第三个函数。池大小为 1。 在 t=900 时，第三个函数执行完毕后。池大小为 0，因此返回的 Promise 也执行完成。 ``` 实现 ```ts type F = () => Promise<any>; function promisePool(functions: F[], n: number): Promise<any[]> { let fNext = 0; // 下一个要执行的函数的索引 // 递归调用该函数以依次执行下一个函数 const evaluateNext = async (): Promise<void> => { if (fNext >= functions.length) { // 如果所有函数都已执行，则退出 return; } const fn = functions[fNext++]; // 获取下一个要执行的函数 await fn(); // 执行函数并等待其完成 await evaluateNext(); // 递归调用 evaluateNext，继续执行下一个函数 }; // 同时启动 n 个 evaluateNext()调用来保持 n 个异步任务并发 const runners = new Array(n).fill(null).map(() => evaluateNext()); // 等待所有启动的任务完成 return Promise.all(runners) } ```",link:"/frontend/Promise常见面试题#_1-promise-对象池",textType:"code",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:"给定两个 promise 对象 promise1 和 promise2，返回一个新的 promise。promise1 和 promise2 都会被解析为一个数字。返回的 Promise 应该解析为这两个数字的和。 ``` 示例 1： 输入： promise1 = new Promise(resolve => setTimeout(() => resolve(2), 20)), promise2 = new Promise(resolve => setTimeout(() => resolve(5), 60)) 输出：7 解释：两个输入的 Promise 分别解析为值 2 和 5。返回的 Promise 应该解析为 2 + 5 = 7。返回的 Promise 解析的时间不作为判断条件。 示例 2： 输入： promise1 = new Promise(resolve => setTimeout(() => resolve(10), 50)), promise2 = new Promise(resolve => setTimeout(() => resolve(-12), 30)) 输出：-2 解释：两个输入的 Promise 分别解析为值 10 和 -12。返回的 Promise 应该解析为 10 + -12 = -2。 ``` ```ts type P = Promise<number> async function addTwoPromises(promise1: P, promise2: P): P { }; /** * addTwoPromises(Promise.resolve(2), Promise.resolve(2)) * .then(console.log); // 4 */ ``` 实现 ```ts async function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> { return await promise1 + await promise2 }; async function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> { return await Promise.all([promise1, promise2]).then(([a, b]) => a + b) }; async function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> { const [a, b] = await Promise.all([promise1, promise2]) return a + b }; async function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> { return new Promise((resolve, reject) => { Promise.all([promise1, promise2]).then(([a, b]) => { resolve(a + b) }).catch(reject) }) }; ```",link:"/frontend/Promise常见面试题#_2-两个-promise-对象相加",textType:"code",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:'请你编写一个函数，它接受一个异步函数 fn 和一个以毫秒为单位的时间 t。它应根据限时函数返回一个有 限时 效果的函数。函数 fn 接受提供给 限时 函数的参数。 限时 函数应遵循以下规则： 如果 fn 在 t 毫秒的时间限制内完成，限时 函数应返回结果。 如果 fn 的执行超过时间限制，限时 函数应拒绝并返回字符串 "Time Limit Exceeded" 。 ``` 示例 1： 输入： fn = async (n) => { await new Promise(res => setTimeout(res, 100)); return n * n; } inputs = [5] t = 50 输出：{"rejected":"Time Limit Exceeded","time":50} 解释： const limited = timeLimit(fn, t) const start = performance.now() let result; try { const res = await limited(...inputs) result = {"resolved": res, "time": Math.floor(performance.now() - start)}; } catch (err) { result = {"rejected": err, "time": Math.floor(performance.now() - start)}; } console.log(result) // 输出结果 提供的函数设置在 100ms 后执行完成，但是设置的超时时间为 50ms，所以在 t=50ms 时拒绝因为达到了超时时间。 示例 2： 输入： fn = async (n) => { await new Promise(res => setTimeout(res, 100)); return n * n; } inputs = [5] t = 150 输出：{"resolved":25,"time":100} 解释： 在 t=100ms 时执行 5*5=25 ，没有达到超时时间。 示例 3： 输入： fn = async (a, b) => { await new Promise(res => setTimeout(res, 120)); return a + b; } inputs = [5,10] t = 150 输出：{"resolved":15,"time":120} 解释： 在 t=120ms 时执行 5+10=15，没有达到超时时间。 示例 4： 输入： fn = async () => { throw "Error"; } inputs = [] t = 1000 输出：{"rejected":"Error","time":0} 解释： 此函数始终丢出 Error 提示： 0 <= inputs.length <= 10 0 <= t <= 1000 fn 返回一个 Promise 对象 ``` 实现 ```ts type Fn = (...params: any[]) => Promise<any>; function timeLimit(fn: Fn, t: number): Fn { return async function(...args) { return new Promise(async (resolve, reject) => { const timeout = setTimeout(() => { reject("Time Limit Exceeded"); }, t); try { const result = await fn(...args); resolve(result); } catch(err) { reject(err); } clearTimeout(timeout); }); }; }; /** * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100); * limited(150).catch(console.log) // "Time Limit Exceeded" at t=100ms */ ```',link:"/frontend/Promise常见面试题#_3-有时间限制的-promise-对象",textType:"code",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:"给定一个函数数组 functions 和一个数字 ms，返回一个新的函数数组。 functions 是一个返回 Promise 对象的函数数组。 ms 表示延迟的时间，以毫秒为单位。它决定了在新数组中的每个函数返回的 Promise 在解析之前等待的时间。 新数组中的每个函数应该返回一个 Promise 对象，在延迟了 ms 毫秒后解析，保持原始 functions 数组中的顺序。delayAll 函数应确保从 functions 中的每个 Promise 都被延迟执行，形成返回延迟的 Promise 的函数的新数组。 ``` 示例 1： 输入： functions = [ () => new Promise((resolve) => setTimeout(resolve, 30)) ], ms = 50 输出：[80] 解释：数组中的 Promise 在 30 毫秒后解析，但被延迟了 50 毫秒，所以总共延迟了 30 毫秒 + 50 毫秒 = 80 毫秒。 示例 2： 输入： functions = [ () => new Promise((resolve) => setTimeout(resolve, 50)), () => new Promise((resolve) => setTimeout(resolve, 80)) ], ms = 70 输出：[120,150] 解释：数组中的 Promise 在 50 毫秒和 80 毫秒后解析，但它们被延迟了 70 毫秒，所以总共延迟了 50 毫秒 + 70 毫秒 = 120 毫秒 和 80 毫秒 + 70 毫秒 = 150 毫秒。 提示： functions 是一个返回 Promise 对象的函数数组 10 <= ms <= 500 1 <= functions.length <= 10 ``` 实现 ```ts type Fn = () => Promise<any> function delayAll(functions: Fn[], ms: number): Fn[] { return functions.map(fn => () => new Promise(res => { setTimeout(() => { res(fn()) }, ms) })) }; ```",link:"/frontend/Promise常见面试题#_4-延迟每个-promise-对象的解析",textType:"code",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:'编写一个函数，接受另一个函数 fn ，并将基于回调函数的函数转换为基于 Promise 的函数。 promisify 函数接受一个函数 fn ，fn 将回调函数作为其第一个参数，并且还可以接受其他额外的参数。 promisfy 返回一个新函数，新函数会返回一个 Promise 对象。当回调函数被成功调用时，新函数返回的 Promise 对象应该使用原始函数的结果进行解析；当回调函数被调用出现错误时，返回的 Promise 对象应该被拒绝并携带错误信息。最终返回的基于 Promise 的函数应该接受额外的参数作为输入。 ``` 以下是一个可以传递给 promisify 的函数示例： function sum(callback, a, b) { if (a < 0 || b < 0) { const err = Error(\'a and b must be positive\'); callback(undefined, err); } else { callback(a + b); } } 这是基于 Promise 的等效代码： async function sum(a, b) { if (a < 0 || b < 0) { throw Error(\'a and b must be positive\'); } else { return a + b; } } 示例 1： 输入： fn = (callback, a, b, c) => { return callback(a * b * c); } args = [1, 2, 3] 输出：{"resolved": 6} 解释： const asyncFunc = promisify(fn); asyncFunc(1, 2, 3).then(console.log); // 6 fn 以回调函数作为第一个参数和 args 作为其余参数进行调用。当使用 (1, 2, 3) 调用时，基于 Promise 的 fn 将解析为值 6。 示例 2： 输入： fn = (callback, a, b, c) => { callback(a * b * c, "Promise Rejected"); } args = [4, 5, 6] 输出：{"rejected": "Promise Rejected"} 解释： const asyncFunc = promisify(fn); asyncFunc(4, 5, 6).catch(console.log); // "Promise Rejected" fn 以回调函数作为第一个参数和 args 作为其余参数进行调用。在回调函数的第二个参数中，接受一个错误消息，因此当调用 fn 时，Promise 被拒绝并携带回调函数中提供的错误消息。请注意，不管将什么作为回调函数的第一个参数传递都无关紧要。 提示： 1 <= args.length <= 100 0 <= args[i] <= 104 ``` 实现 ```ts type CallbackFn = ( next: (data: number, error: string) => void, ...args: number[] ) => void type Promisified = (...args: number[]) => Promise<number> function promisify(fn: CallbackFn): Promisified { return async function(...args) { return new Promise((resolve, reject) => { fn((data: number, error: string) => { if (error) reject(error); resolve(data); }, ...args); }); }; }; ```',link:"/frontend/Promise常见面试题#_5-转换回调函数为-promise-函数",textType:"code",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:'给定一个数组 functions，返回一个 promise 对象 promise。functions 是一个返回多个 promise 对象 fnPromise 的函数数组。每个 fnPromise 可以被解析（resolved）或拒绝（rejected）。 ``` 如果 fnPromise 被解析： obj = { status: "fulfilled", value: resolved value} 如果 fnPromise 被拒绝： obj = { status: "rejected", reason: 拒绝的原因（捕获的错误消息）} 该 promise 应该返回一个包含这些对象 obj 的数组。数组中的每个 obj 应该对应原始函数数组中的多个 promise 对象，并保持相同的顺序。 请在不使用内置方法 Promise.allSettled() 的情况下实现它。 示例 1： 输入：functions = [ () => new Promise(resolve => setTimeout(() => resolve(15), 100)) ] 输出：{"t":100,"values":[{"status":"fulfilled","value":15}]} 解释： const time = performance.now() const promise = promiseAllSettled(functions); promise.then(res => { const out = {t: Math.floor(performance.now() - time), values: res} console.log(out) // {"t":100,"values":[{"status":"fulfilled","value":15}]} }) 返回的 promise 在 100 毫秒内解析。由于函数数组中的 promise 被解析，返回的 promise 的解析值设置为[{"status":"fulfilled","value":15}]。 示例 2： 输入：functions = [ () => new Promise(resolve => setTimeout(() => resolve(20), 100)), () => new Promise(resolve => setTimeout(() => resolve(15), 100)) ] 输出： { "t":100, "values": [ {"status":"fulfilled","value":20}, {"status":"fulfilled","value":15} ] } 解释：返回的 promise 在 100 毫秒内解析，因为解析时间取决于需要最长时间来解析的 promise。由于函数数组中的 promises 被解析，返回的 promise 的解析值设置为[{"status":"fulfilled","value":20},{"status":"fulfilled","value":15}]。 示例 3： 输入：functions = [ () => new Promise(resolve => setTimeout(() => resolve(30), 200)), () => new Promise((resolve, reject) => setTimeout(() => reject("Error"), 100)) ] 输出： { "t":200, "values": [ {"status":"fulfilled","value":30}, {"status":"rejected","reason":"Error"} ] } 解释：返回的 promise 在 200 毫秒内解析，因为解析时间取决于需要最长时间来解析的 promise。由于函数数组中的一个 promise 被解析，另一个被拒绝，返回的 promise 的解析值设置为[{"status":"fulfilled","value":30},{"status":"rejected","reason":"Error"}]。数组中的每个对象对应原始函数数组中的 promise，并保持相同的顺序。 提示： 1 <= functions.length <= 10 ``` 实现 ```ts type FulfilledObj = { status: \'fulfilled\'; value: string; } type RejectedObj = { status: \'rejected\'; reason: string; } type Obj = FulfilledObj | RejectedObj; function promiseAllSettled(functions: Function[]): Promise<Obj[]> { return new Promise((resolve) => { const resultArray = []; let completedCount = 0; for (let i = 0; i < functions.length; i++) { const fnPromise = functions[i](); fnPromise .then((value) => { resultArray[i] = { status: "fulfilled", value }; }) .catch((reason) => { resultArray[i] = { status: "rejected", reason }; }) .finally(() => { completedCount++; if (completedCount === functions.length) { resolve(resultArray); } }); } }); }; /** * const functions = [ * () => new Promise(resolve => setTimeout(() => resolve(15), 100)) * ] * const time = performance.now() * * const promise = promiseAllSettled(functions); * * promise.then(res => { * const out = {t: Math.floor(performance.now() - time), values: res} * console.log(out) // {"t":100,"values":[{"status":"fulfilled","value":15}]} * }) */ ```',link:"/frontend/Promise常见面试题#_6-并行执行-promise-以获取独有的结果",textType:"code",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:'给定一个异步函数数组 functions，返回一个新的 promise 对象 promise。数组中的每个函数都不接受参数并返回一个 promise。所有的 promise 都应该并行执行。 promise resolve 条件： 当所有从 functions 返回的 promise 都成功的并行解析时。promise 的解析值应该是一个按照它们在 functions 中的顺序排列的 promise 的解析值数组。promise 应该在数组中的所有异步函数并行执行完成时解析。 promise reject 条件： 当任何从 functions 返回的 promise 被拒绝时。promise 也会被拒绝，并返回第一个拒绝的原因。 请在不使用内置的 Promise.all 函数的情况下解决。 ``` 示例 1： 输入：functions = [ () => new Promise(resolve => setTimeout(() => resolve(5), 200)) ] 输出：{"t": 200, "resolved": [5]} 解释： promiseAll(functions).then(console.log); // [5] 单个函数在 200 毫秒后以值 5 成功解析。 示例 2： 输入：functions = [ () => new Promise(resolve => setTimeout(() => resolve(1), 200)), () => new Promise((resolve, reject) => setTimeout(() => reject("Error"), 100)) ] 输出：{"t": 100, "rejected": "Error"} 解释：由于其中一个 promise 被拒绝，返回的 promise 也在同一时间被拒绝并返回相同的错误。 示例 3： 输入：functions = [ () => new Promise(resolve => setTimeout(() => resolve(4), 50)), () => new Promise(resolve => setTimeout(() => resolve(10), 150)), () => new Promise(resolve => setTimeout(() => resolve(16), 100)) ] 输出：{"t": 150, "resolved": [4, 10, 16]} 解释：所有的 promise 都成功执行。当最后一个 promise 被解析时，返回的 promise 也被解析了。 提示： 函数 functions 是一个返回 promise 的函数数组 1 <= functions.length <= 10 ``` 实现 ```ts type Fn<T> = () => Promise<T> async function promiseAll<T>(functions: (() => Promise<T>)[]): Promise<T[]> { return new Promise<T[]>((resolve, reject) => { if(functions.length === 0) { resolve([]); return; } const res: T[] = new Array(functions.length).fill(null); let resolvedCount = 0; functions.forEach(async (el, idx) => { try { const subResult = await el(); res[idx] = subResult; resolvedCount++; if(resolvedCount === functions.length) { resolve(res); } } catch(err) { reject(err); } }); }); }; /** * const promise = promiseAll([() => new Promise(res => res(42))]) * promise.then(console.log); // [42] */ ```',link:"/frontend/Promise常见面试题#_7-并行执行异步函数",textType:"code",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:"``` 请你编写一个异步函数，它接收一个正整数参数 millis ，并休眠 millis 毫秒。要求此函数可以解析任何值。 示例 1： 输入：millis = 100 输出：100 解释： 在 100ms 后此异步函数执行完时返回一个 Promise 对象 let t = Date.now(); sleep(100).then(() => { console.log(Date.now() - t); // 100 }); 示例 2： 输入：millis = 200 输出：200 解释：在 200ms 后函数执行完时返回一个 Promise 对象 提示： 1 <= millis <= 1000 ``` 实现 ```ts async function sleep(millis: number): Promise<void> { return new Promise<void>(resolve => { setTimeout(resolve, millis); }); } ```",link:"/frontend/Promise常见面试题#_8-睡眠函数",textType:"code",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:"描述：实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有 limit 个。 实现 ```ts type PromiseCreator = () => Promise<void>; class Scheduler { private queue: PromiseCreator[]; // 用队列保存正在执行的任务 private runCount: number; // 计数正在执行的任务个数 private maxCount: number; // 允许并发的最大个数 constructor(limit: number) { this.queue = []; this.runCount = 0; this.maxCount = limit; } add(time: number, data: string) { const promiseCreator: PromiseCreator = () => { return new Promise<void>((resolve) => { setTimeout(() => { console.log(data); resolve(); }, time); }); } this.queue.push(promiseCreator); // 每次添加的时候都会尝试去执行任务 this.request(); } private request() { // 队列中还有任务才会被执行 if (this.queue.length && this.runCount < this.maxCount) { this.runCount++; // 执行先加入队列的函数 this.queue.shift()!().then(() => { this.runCount--; // 尝试进行下一次任务 this.request(); }); } } } // 测试 const scheduler = new Scheduler(2); const addTask = (time: number, data: string) => { scheduler.add(time, data); } addTask(1000, '1'); addTask(500, '2'); addTask(300, '3'); addTask(400, '4'); // 输出结果 2 3 1 4 ```",link:"/frontend/Promise常见面试题#_9-异步任务调度器",textType:"code",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:'实现 ```ts type CancellablePromise<T> = [Promise<T>, () => void]; function makeCancellable<T>(promise: Promise<T>): CancellablePromise<T> { let rejectFn: (reason?: any) => void; const wrappedPromise = new Promise<T>((resolve, reject) => { rejectFn = reject; // 保存 reject 函数引用以便后续调用 promise.then( (value) => { if (rejectFn !== null) { // 如果没有被取消，那么解决 wrappedPromise resolve(value); rejectFn = null; // 清除 rejectFn 引用，避免内存泄漏 } }, (error) => { if (rejectFn !== null) { // 如果没有被取消，那么拒绝 wrappedPromise reject(error); rejectFn = null; // 清除 rejectFn 引用，避免内存泄漏 } } ); }); const cancel = () => { if (rejectFn !== null) { rejectFn({ cancelled: true }); // 立即拒绝 wrappedPromise rejectFn = null; // 防止内存泄漏，清除 rejectFn 引用 } }; return [wrappedPromise, cancel]; } // 使用示例 const [cancellablePromise, cancel] = makeCancellable(new Promise<string>((resolve) => { setTimeout(() => { resolve("Resolved after 2 seconds"); }, 2000); })); cancellablePromise .then((result) => { console.log(result); }) .catch((error) => { if (error && error.cancelled) { console.log("Promise was cancelled"); } else { console.log("Promise was rejected with error:", error); } }); // 立即取消 Promise cancel(); ```',link:"/frontend/Promise常见面试题#_11-设计可取消-promise",textType:"code",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:'```js // Node.js 风格的 myFunction function myFunction(cb1, cb2, cb3) { // 模拟异步操作，例如 I/O setTimeout(() => cb1(null, "result1"), Math.floor(Math.random() * 1000)); setTimeout(() => cb2(null, "result2"), Math.floor(Math.random() * 1000)); setTimeout(() => cb3(null, "result3"), Math.floor(Math.random() * 1000)); } // 实现 myFunctionPromise，将 myFunction Promise 化。 // cb callback 无 error 时，则为 resolve // 测试用例 test("a", async () => { try { const results = await myFunctionPromise(); console.log(results); // 输出: [\'result1\', \'result2\', \'result3\'] // 这里我们期望返回的 Promise 被成功地 resolve，并且结果按次序排列 expect(results).toEqual(["result1", "result2", "result3"]); } catch (err) { // 这里处理可能出现的错误 console.error(err); } }); ``` 实现 ```js // Promise 包装器，保证次序 function myFunctionPromise() { return new Promise((resolve, reject) => { let results = new Array(3); // 创建一个长度为 3 的数组来存储结果 let count = 0; let hasErrorOccurred = false; function createFinalCallback(index) { return function (err, result) { if (hasErrorOccurred) return; if (err) { hasErrorOccurred = true; return reject(err); } results[index] = result; // 根据回调的标识符存储结果 count++; if (count === 3) { resolve(results); // 当所有回调都执行完毕时，按顺序解决 Promise } }; } myFunction( createFinalCallback(0), createFinalCallback(1), createFinalCallback(2) ); }); } ```',link:"/frontend/Promise常见面试题#_10-多个-callback-函数-promise-化的测试用例",textType:"code",routeTitle:"frontend > Promise常见面试题",groupType:0},{text:"",link:"/frontend/react#做react需要会什么",textType:"text",routeTitle:"frontend > react",groupType:0},{text:"",link:"/frontend/sentry异常监控#",textType:"text",routeTitle:"frontend > sentry异常监控",groupType:0},{text:"- 前端异常监控平台之Sentry落地",link:"/frontend/sentry异常监控#参考",textType:"text",routeTitle:"frontend > sentry异常监控",groupType:0},{text:"",link:"/frontend/vue3#",textType:"text",routeTitle:"frontend > vue3",groupType:0},{text:"",link:"/frontend/vue3_refs#",textType:"text",routeTitle:"frontend > vue3_refs",groupType:0},{text:"1.slot语法更简短",link:"/frontend/vue3_refs#_1-slot语法更简短",textType:"text",routeTitle:"frontend > vue3_refs",groupType:0},{text:'```html <foo> <template v-slot:header="{ msg }"> {{ msg }} </template> </foo> ```',link:"/frontend/vue3_refs#统一成v-slot-包括局部作用域",textType:"code",routeTitle:"frontend > vue3_refs",groupType:0},{text:'```html <foo> <template #header="{ msg }"> Message from header: {{ msg }} </template> <template #footer> A static footer </template> </foo> ```',link:"/frontend/vue3_refs#号简写",textType:"code",routeTitle:"frontend > vue3_refs",groupType:0},{text:'```html <div :[key]="value"></div> <div @[event]="handler"></div> ```',link:"/frontend/vue3_refs#_2-动态指令参数",textType:"code",routeTitle:"frontend > vue3_refs",groupType:0},{text:"",link:"/frontend/vue3_refs#_3-树摇",textType:"text",routeTitle:"frontend > vue3_refs",groupType:0},{text:"Currently in 2.x, all global APIs are exposed on the single Vue object: ```js import Vue from 'vue' Vue.nextTick(() => {}) const obj = Vue.observable({}) ``` In 3.x, they can only be accessed as named imports: ```js import Vue, { nextTick, observable } from 'vue' Vue.nextTick // undefined nextTick(() => {}) const obj = observable({}) ```",link:"/frontend/vue3_refs#变化",textType:"code",routeTitle:"frontend > vue3_refs",groupType:0},{text:"- `Vue.nextTick` - `Vue.observable` - `Vue.version` - `Vue.compile` (only in full builds) - `Vue.set` (only in compat builds) - `Vue.delete` (only in compat builds)",link:"/frontend/vue3_refs#affected-2-x-apis",textType:"text",routeTitle:"frontend > vue3_refs",groupType:0},{text:'Instead of: ```html <MyComponent v-bind:title.sync="title" /> ``` the syntax would be: ```html <MyComponent v-model:title="title" /> ```',link:"/frontend/vue3_refs#_4-增强v-model",textType:"code",routeTitle:"frontend > vue3_refs",groupType:0},{text:"5.全局方法改成实例方法",link:"/frontend/vue3_refs#_5-全局方法改成实例方法",textType:"text",routeTitle:"frontend > vue3_refs",groupType:0},{text:"```javascript import Vue from 'vue' import App from './App.vue' Vue.config.ignoredElements = [/^app-/] Vue.use(/* ... */) Vue.mixin(/* ... */) Vue.component(/* ... */) Vue.directive(/* ... */) Vue.prototype.customProperty = () => {} new Vue({ render: h => h(App) }).$mount('#app') ```",link:"/frontend/vue3_refs#before",textType:"code",routeTitle:"frontend > vue3_refs",groupType:0},{text:"```javascript import { createApp } from 'vue' import App from './App.vue' const app = createApp(App) app.config.isCustomElement = tag => tag.startsWith('app-') app.use(/* ... */) app.mixin(/* ... */) app.component(/* ... */) app.directive(/* ... */) app.config.globalProperties.customProperty = () => {} app.mount(App, '#app') ```",link:"/frontend/vue3_refs#after",textType:"code",routeTitle:"frontend > vue3_refs",groupType:0},{text:"",link:"/frontend/vue3_refs#_6-自定义指令",textType:"text",routeTitle:"frontend > vue3_refs",groupType:0},{text:"自定义指令钩子名称和组件生命周期钩子名称一致",link:"/frontend/vue3_refs#动机",textType:"text",routeTitle:"frontend > vue3_refs",groupType:0},{text:"``` const MyDirective = { bind(el, binding, vnode, prevVnode) {}, inserted() {}, update() {}, componentUpdated() {}, unbind() {} } ```",link:"/frontend/vue3_refs#before-1",textType:"code",routeTitle:"frontend > vue3_refs",groupType:0},{text:"``` const MyDirective = { beforeMount(el, binding, vnode, prevVnode) {}, mounted() {}, beforeUpdate() {}, updated() {}, beforeUnmount() {}, // new unmounted() {} } ```",link:"/frontend/vue3_refs#after-1",textType:"code",routeTitle:"frontend > vue3_refs",groupType:0},{text:"```html <template> <button @click=\"increment\"> Count is: {{ state.count }}, double is: {{ state.double }} </button> </template> <script> import { reactive, computed } from 'vue' export default { setup() { const state = reactive({ count: 0, double: computed(() => state.count * 2) }) function increment() { state.count++ } return { state, increment } } } <\/script> ```",link:"/frontend/vue3_refs#_7-composition-api",textType:"code",routeTitle:"frontend > vue3_refs",groupType:0},{text:"8.移除filter",link:"/frontend/vue3_refs#_8-移除filter",textType:"text",routeTitle:"frontend > vue3_refs",groupType:0},{text:"- filter操作符|和逻辑或冲突 - 创造了js不支持的新语法 - 可以被方法和计算属性代替 - 增加实现成本和框架复杂度 ```html {{ msg | format }} {{ format(msg) }} ```",link:"/frontend/vue3_refs#移除动机",textType:"code",routeTitle:"frontend > vue3_refs",groupType:0},{text:"9.移除keycode",link:"/frontend/vue3_refs#_9-移除keycode",textType:"text",routeTitle:"frontend > vue3_refs",groupType:0},{text:'- KeyboardEvent.keyCode可以用KeyboardEvent.key替代 ```html <input @keyup.page-down="onArrowUp"> ```',link:"/frontend/vue3_refs#移除动机-1",textType:"code",routeTitle:"frontend > vue3_refs",groupType:0},{text:"10.移除inline-template",link:"/frontend/vue3_refs#_10-移除inline-template",textType:"text",routeTitle:"frontend > vue3_refs",groupType:0},{text:'- inline-template让模板作用域不一致 ```html <my-comp inline-template :msg="parentMsg"> {{ msg }} {{ childState }} </my-comp> <my-comp v-slot="{ childState }"> {{ parentMsg }} {{ childState }} </my-comp> ```',link:"/frontend/vue3_refs#移除动机-2",textType:"code",routeTitle:"frontend > vue3_refs",groupType:0},{text:"Remove $on, $off and $once instance methods.",link:"/frontend/vue3_refs#_11-vue实例上移除事件方法",textType:"text",routeTitle:"frontend > vue3_refs",groupType:0},{text:"- event emitter API不是组件数据流的一部分",link:"/frontend/vue3_refs#移除动机-3",textType:"text",routeTitle:"frontend > vue3_refs",groupType:0},{text:"Remove $on, $off and $once instance methods.",link:"/frontend/vue3_refs#_12-移除inline-template",textType:"text",routeTitle:"frontend > vue3_refs",groupType:0},{text:"- 保持和css命令一致 ```html <style scoped> /* deep selectors */ ::v-deep(.foo) {} /* shorthand */ :deep(.foo) {} /* targeting slot content */ ::v-slotted(.foo) {} /* shorthand */ :slotted(.foo) {} /* one-off global rule */ ::v-global(.foo) {} /* shorthand */ :global(.foo) {} </style> ```",link:"/frontend/vue3_refs#移除动机-4",textType:"code",routeTitle:"frontend > vue3_refs",groupType:0},{text:"```javascript import { createApp, h } from 'vue' createApp().mount({ // 这里只能用函数 data() { return { counter: 1, } } }) ```",link:"/frontend/vue3_refs#_13-data对象声明",textType:"code",routeTitle:"frontend > vue3_refs",groupType:0},{text:"- rfcs",link:"/frontend/vue3_refs#参考",textType:"text",routeTitle:"frontend > vue3_refs",groupType:0},{text:"",link:"/frontend/其他#",textType:"text",routeTitle:"frontend > 其他",groupType:0},{text:"html需要关注 link用来做资源的加载，需要了解prefetch preload dns-prefetch meta元数据 script脚本插件 - 前端特效搜索前端小智 https://github.com/husky-dot/xiaozhi",link:"/frontend/其他#其他",textType:"text",routeTitle:"frontend > 其他",groupType:0},{text:"# 国内高速前端 Unpkg CDN 替代方案",link:"/frontend/国内高速前端 Unpkg CDN 替代方案#国内高速前端-unpkg-cdn-替代方案",textType:"text",routeTitle:"frontend > 国内高速前端 Unpkg CDN 替代方案",groupType:0},{text:"目前国内有很多 NPM 的 CDN，可以高速支持相关包文件的访问下载，如： - BootCDN: www.bootcdn.cn - 七牛云: www.staticfile.org - 360: cdn.baomitu.com - 字节跳动: cdn.bytedance.com 但这些 CDN 并不全，很多 NPM 上的包 在这些 CDN 上是找不到的。原因是，它们都是从 CDNJS 上同步的数据，CDNJS 并不会把所有的 NPM 包进行同步，所以当你需要的一些 NPM 包没有在 CDNJS 上面，你就用不了上面这些国内 CDN 了。 解决可以访问所有 NPM 包的问题，可以使用 unpkg，但它的访问速度在国内并不佳： 和它相同功能的 jsdelivr，在国内的速度也不佳： 于是就整理了下，国内的 Unpkg 替代品。",link:"/frontend/国内高速前端 Unpkg CDN 替代方案#_1-背景",textType:"text",routeTitle:"frontend > 国内高速前端 Unpkg CDN 替代方案",groupType:0},{text:"目前找了对外的国内 Unpkg 有两个： - 饿了么：github.elemecdn.com、npm.elemecdn.com - 知乎：unpkg.zhimg.com 都是部署在国内阿里云的 CDN 上，速度都还不错，如下图所示： 可以放心使用。",link:"/frontend/国内高速前端 Unpkg CDN 替代方案#_2-国内-unpkg",textType:"text",routeTitle:"frontend > 国内高速前端 Unpkg CDN 替代方案",groupType:0},{text:"# 坐标位置",link:"/frontend/坐标位置#坐标位置",textType:"text",routeTitle:"frontend > 坐标位置",groupType:0},{text:"- ClientWidth",link:"/frontend/坐标位置#元素宽高",textType:"text",routeTitle:"frontend > 坐标位置",groupType:0},{text:"- getBoundingClientRect",link:"/frontend/坐标位置#元素坐标位置",textType:"text",routeTitle:"frontend > 坐标位置",groupType:0},{text:"",link:"/frontend/坐标位置#整体坐标位置",textType:"text",routeTitle:"frontend > 坐标位置",groupType:0},{text:"- 浏览器视口相关属性",link:"/frontend/坐标位置#参考",textType:"text",routeTitle:"frontend > 坐标位置",groupType:0},{text:"",link:"/frontend/布局#css布局",textType:"text",routeTitle:"frontend > 布局",groupType:0},{text:"- grid-cheatSheet - grid-MDN",link:"/frontend/布局#grid",textType:"text",routeTitle:"frontend > 布局",groupType:0},{text:"- flex-cheatSheet - flex",link:"/frontend/布局#flex",textType:"text",routeTitle:"frontend > 布局",groupType:0},{text:"# 常用注入 Script 方法",link:"/frontend/常用注入 Script 方法#常用注入-script-方法",textType:"text",routeTitle:"frontend > 常用注入 Script 方法",groupType:0},{text:"- 如果你想在当前的页面，试一下某个 JS 工具库，而这个工具库恰好你没安装。（如 lodash） - 如果你想分享一段脚本给别人，而又不希望别人在执行的过程太过麻烦。（如你写了一段恢复复制和右键功能的脚本） 那下面的方法你可以尝试一下。",link:"/frontend/常用注入 Script 方法#_1-背景",textType:"text",routeTitle:"frontend > 常用注入 Script 方法",groupType:0},{text:"主要方法有如下。",link:"/frontend/常用注入 Script 方法#_2-常用方法",textType:"text",routeTitle:"frontend > 常用注入 Script 方法",groupType:0},{text:'复制如下代码，在 DevTools 中执行就可以了： ```javascript function ls(src, callback, prefix = "https://unpkg.com/") { var _script = document.createElement("script"); _script.src = prefix + src; _script.onload = (e) => { console.log("===> 加载完成", src); callback && callback(); }; document.head.appendChild(_script); } ls("工具包名"); ``` 如 lodash、jquery、dayjs： ```javascript ls("lodash", () => { console.log(\'load:\', _) }); ls("jquery", () => { console.log(\'load:\', $) }); ls("dayjs", () => { console.log(\'load:\', dayjs) }); ``` 使用其他源： ```javascript ls("react/umd/react.production.min.js", () => { console.log(\'load:\', React) }, \'https://unpkg.zhimg.com/\'); ls("xstate@4/dist/xstate.js", () => { console.log(\'load:\', XState) }, \'https://cdn.jsdelivr.net/npm/\'); ```',link:"/frontend/常用注入 Script 方法#_2-1-工具包的注入",textType:"code",routeTitle:"frontend > 常用注入 Script 方法",groupType:0},{text:'如下面这段清除水印及恢复右键、选取的脚本： ```javascript [document, ...document.getElementsByTagName("*")].map((item) => { if (item.style) { item.style.cssText += "user-select:auto!important;"; if (item.style.cssText.indexOf("url(") >= 0) { item.style.cssText += "background:unset!important;"; } } item.oncontextmenu = item.oncopy = item.onselectstart = item.οnpaste = item.oncut = item.onmousedown = function (e) { e.stopPropagation(); return true; }; }); ``` 如果想分享给其他人使用，有如下方法：',link:"/frontend/常用注入 Script 方法#_2-2-脚本的注入",textType:"code",routeTitle:"frontend > 常用注入 Script 方法",groupType:0},{text:"就是直接粘贴到 DevTools 的 Console 下，直接执行就可以了。 但这个比较麻烦，每次都要打开 DevTools 和 复制。",link:"/frontend/常用注入 Script 方法#_2-2-1-直接-devtools-执行",textType:"text",routeTitle:"frontend > 常用注入 Script 方法",groupType:0},{text:"在脚本前面加上 `javascript:`，然后直接粘贴在地址栏中，回车即可执行。 比 2.2.1 少了一步打开 DevTools 的过程，但还是需要复制，且如果复制的内容包含 `javascript:`，地址拦会自动给你清除掉，除非你手动再输入一遍。",link:"/frontend/常用注入 Script 方法#_2-2-2-直接在地址栏执行",textType:"text",routeTitle:"frontend > 常用注入 Script 方法",groupType:0},{text:"地址栏执行的优化版。不过 只需要复制一次就可以了，后面不用再去复制。 1. 打开浏览器的书签管理：右上角设置 -> 书签 -> 书签管理器 （或者直接在地址栏中输入 `chrome://bookmarks/` 进行打开） 2. 点击 添加新书签 ，打开弹窗 3. `名称` 自行输入，`网址` 就是那段 `javascript:` 拼合的代码，保存。 然后，每次需要的时候，只需要点击一下书签就可以了：",link:"/frontend/常用注入 Script 方法#_2-2-3-书签执行",textType:"text",routeTitle:"frontend > 常用注入 Script 方法",groupType:0},{text:"# 断点调试",link:"/frontend/断点调试#断点调试",textType:"text",routeTitle:"frontend > 断点调试",groupType:0},{text:"1. 直接在源代码中打断点",link:"/frontend/断点调试#_1-直接在源代码中打断点",textType:"text",routeTitle:"frontend > 断点调试",groupType:0},{text:"",link:"/frontend/断点调试#_2-通过元素事件找到源代码打断点",textType:"text",routeTitle:"frontend > 断点调试",groupType:0},{text:"",link:"/frontend/断点调试#_3-找到元素打dom断点",textType:"text",routeTitle:"frontend > 断点调试",groupType:0},{text:"```javascript //要观察的节点 let node = document.querySelector('#select'); let observer = new MutationObserver((...args) => { debugger; console.log(args); }); observer.observe(node, { childList: true, // 观察目标子节点的变化，是否有添加或者删除 attributes: true, // 观察属性变动 subtree: true, // 观察后代节点，默认为 false }); ```",link:"/frontend/断点调试#_4-通过mutationobserver打断点-查看调用栈",textType:"code",routeTitle:"frontend > 断点调试",groupType:0},{text:"",link:"/frontend/设计模式#设计模式",textType:"text",routeTitle:"frontend > 设计模式",groupType:0},{text:"- 答案",link:"/frontend/面试#问题",textType:"text",routeTitle:"frontend > 面试",groupType:0},{text:"",link:"/interview/index#面试",textType:"text",routeTitle:"interview > index",groupType:0},{text:"",link:"/interview/字符串问号排序#字符串问号排序",textType:"text",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"给定一个字符串，其中仅包含，大小写字母，数字和问号。要求对该字符串内部字符排序，满足以下要求： 1. 问号的占用的位置不变 2. 数字占用的位置不变，数字之间由大到小排序 3. 字母占用的位置不变，字母之间按字典序排序 具体请配合样例理解",link:"/interview/字符串问号排序#题目",textType:"text",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"",link:"/interview/字符串问号排序#样例",textType:"text",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"12A?zc",link:"/interview/字符串问号排序#输入",textType:"text",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"21A?cz",link:"/interview/字符串问号排序#输出",textType:"text",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"1Ad?z?t24",link:"/interview/字符串问号排序#输入-1",textType:"text",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"4Ad?t?z21",link:"/interview/字符串问号排序#输出-1",textType:"text",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"???123??zxy?",link:"/interview/字符串问号排序#输入-2",textType:"text",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"???321??xyz?",link:"/interview/字符串问号排序#输出-2",textType:"text",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"```javascript function solution(inp) { // Edit your code here const cArr = [] const dataArr = [] for(let c of inp){ if(c<='9'&&c>='0'){ cArr.push(c) } if(c>='A'&&c<='z'){ dataArr.push(c) } } cArr.sort((a,b)=>b-a) dataArr.sort() const input = inp.split('') for(let i=0;i<input.length;i++){ const c = input[i] if(c<='9'&&c>='0'){ input[i] = cArr.shift() } if(c>='A'&&c<='z'){ input[i] = dataArr.shift() } } return input.join(''); } function main() { // Add your test cases here console.log(solution(\"12A?zc\") === \"21A?cz\"); console.log(solution(\"1Ad?z?t24\") === \"4Ad?t?z21\"); console.log(solution(\"???123??zxy?\") === \"???321??xyz?\"); } main(); ```",link:"/interview/字符串问号排序#代码实现",textType:"code",routeTitle:"interview > 字符串问号排序",groupType:0},{text:"",link:"/interview/实现一个代理服务器#实现一个代理服务器",textType:"text",routeTitle:"interview > 实现一个代理服务器",groupType:0},{text:"要实现一个类似 whistle 的代理服务器，你需要使用 JavaScript 和一些网络编程的知识。以下是一个简单的示例，展示了如何使用 Node.js 创建一个基本的 HTTP 代理服务器。这个代理服务器将监听来自客户端的 HTTP 请求，并将请求转发到目标服务器，然后将响应返回给客户端。",link:"/interview/实现一个代理服务器#问题描述",textType:"text",routeTitle:"interview > 实现一个代理服务器",groupType:0},{text:"```javascript const http = require('http'); const url = require('url'); const httpProxy = require('http-proxy'); // 创建一个代理服务器实例 const proxy = httpProxy.createProxyServer(); // 创建一个 HTTP 服务器来处理客户端请求 const server = http.createServer((req, res) => { // 解析请求的 URL const parsedUrl = url.parse(req.url); // 设置代理服务器的目标地址 proxy.web(req, res, { target: `http://${parsedUrl.hostname}` }); }); // 监听指定的端口 server.listen(8080, () => { console.log('代理服务器正在监听 8080 端口'); }); ```",link:"/interview/实现一个代理服务器#代码实现",textType:"code",routeTitle:"interview > 实现一个代理服务器",groupType:0},{text:"",link:"/interview/找单独的数#找单独的数",textType:"text",routeTitle:"interview > 找单独的数",groupType:0},{text:"有一堆数字，除了一个数字，其它的数字都是成对出现。班上的每个同学拿一个数字，正好将这些数字全部拿完，问如何快速找到拿了单独数字的同学？",link:"/interview/找单独的数#问题描述",textType:"text",routeTitle:"interview > 找单独的数",groupType:0},{text:"- 空格分隔输入所有的数字",link:"/interview/找单独的数#输入格式",textType:"text",routeTitle:"interview > 找单独的数",groupType:0},{text:"- 单独的那个数字",link:"/interview/找单独的数#输出格式",textType:"text",routeTitle:"interview > 找单独的数",groupType:0},{text:"``` 1 1 2 2 3 3 4 5 5 ```",link:"/interview/找单独的数#输入样例-1",textType:"code",routeTitle:"interview > 找单独的数",groupType:0},{text:"4",link:"/interview/找单独的数#输出样例-1",textType:"text",routeTitle:"interview > 找单独的数",groupType:0},{text:"``` 0 1 0 1 2 ```",link:"/interview/找单独的数#输入样例-2",textType:"code",routeTitle:"interview > 找单独的数",groupType:0},{text:"2",link:"/interview/找单独的数#输出样例-2",textType:"text",routeTitle:"interview > 找单独的数",groupType:0},{text:"```javascript function solution(inp) { // Edit your code here const map = new Map() let res for(let num of inp){ if(map.get(num)){ map.set(num,map.get(num)+1) }else{ map.set(num,1) } } map.forEach((value,key)=>{ if(value===1){ res = key } }) return res; } function main() { // Add your test cases here console.log(solution([1, 1, 2, 2, 3, 3, 4, 5, 5]) === 4); console.log(solution([0, 1, 0, 1, 2]) === 2); } main(); ```",link:"/interview/找单独的数#代码实现",textType:"code",routeTitle:"interview > 找单独的数",groupType:0},{text:"",link:"/interview/查找热点数据#查找热点数据",textType:"text",routeTitle:"interview > 查找热点数据",groupType:0},{text:"给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按任意顺序返回答案。 - 1 <= nums.length <= 10^5 - k 的取值范围是 [1, 数组中不相同的元素的个数] - 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 你所设计算法的时间复杂度必须优于 O(n log n) ，其中 n 是数组大小。 **示例 1** 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] **示例 2** 输入: nums = [1], k = 1 输出: [1]",link:"/interview/查找热点数据#问题描述",textType:"text",routeTitle:"interview > 查找热点数据",groupType:0},{text:'```javascript function solution(nums, k) { // Please write your code here let map = {} const arr = [] for (let num of nums) { if (map[num]) { map[num] = map[num] + 1 } else { map[num] = 1 } } for (let num in map) { arr.push([num, map[num]]) } const res = arr.sort((a, b) => b[1] - a[1]).slice(0, k); console.log(res) return res.map(i => i[0]).join(\',\') } function main() { // You can add more test cases here console.log(solution([1, 1, 1, 2, 2, 3], 2) === "1,2"); console.log(solution([1], 1) === "1"); } main(); ```',link:"/interview/查找热点数据#代码实现",textType:"code",routeTitle:"interview > 查找热点数据",groupType:0},{text:"",link:"/tools/curl#curl",textType:"text",routeTitle:"tools > curl",groupType:0},{text:"和服务器进行传输数据的工具，支持的协议有： - DICT, FILE, FTP, FTPS, GOPHER, - HTTP, HTTPS, IMAP, IMAPS, LDAP, - LDAPS, MQTT, POP3, POP3S, RTMP, - RTMPS, RTSP, SCP, SFTP, SMB, - SMBS, SMTP, SMTPS, TELNET and TFTP",link:"/tools/curl#curl-1",textType:"text",routeTitle:"tools > curl",groupType:0},{text:"```shell script curl --location --request GET '127.0.0.1:3000/v3/util/userInfo?phone=15271854275' \\ --header 'session: abcd' ```",link:"/tools/curl#get请求",textType:"code",routeTitle:"tools > curl",groupType:0},{text:"```shell script curl --location --request GET '127.0.0.1:3000/v3/util/userInfo?page=1&pageSize=10' \\ --header 'session: abcd' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"phone\":15271854275 }' ```",link:"/tools/curl#post-json请求",textType:"code",routeTitle:"tools > curl",groupType:0},{text:"```shell script curl --location --request POST '127.0.0.1:3000/v3/util/userInfo' \\ --header 'session: abcd' \\ --header 'Content-Type: application/x-www-form-urlencoded' \\ --data-urlencode 'name=feng' \\ --data-urlencode 'age=10' ```",link:"/tools/curl#post-application-x-www-form-urlencoded请求",textType:"code",routeTitle:"tools > curl",groupType:0},{text:"```shell script curl --location --request POST 'http://127.0.0.1:3000/v3/public/upload_file' \\ --form 'img=@\"/Users/zego/Pictures/11.png\"' \\ --form 'moduleName=\"room\"' ```",link:"/tools/curl#post-formdata请求",textType:"code",routeTitle:"tools > curl",groupType:0},{text:"```shell script curl --location --request PUT '127.0.0.1:3000/v3/util/userInfo' ```",link:"/tools/curl#put请求",textType:"code",routeTitle:"tools > curl",groupType:0},{text:"```shell script curl --location --request DELETE '127.0.0.1:3000/v3/util/userInfo' ```",link:"/tools/curl#delete请求",textType:"code",routeTitle:"tools > curl",groupType:0},{text:"- chrome devtool - postman",link:"/tools/curl#生成curl工具",textType:"text",routeTitle:"tools > curl",groupType:0},{text:"- curl tutorial - curl docs - curl everything",link:"/tools/curl#参考",textType:"text",routeTitle:"tools > curl",groupType:0},{text:"",link:"/tools/postman#postman",textType:"text",routeTitle:"tools > postman",groupType:0},{text:"比较简单略",link:"/tools/postman#管理接口文档",textType:"text",routeTitle:"tools > postman",groupType:0},{text:"- 全局变量 - 环境变量 - 取值{{url}}",link:"/tools/postman#设置环境变量",textType:"text",routeTitle:"tools > postman",groupType:0},{text:"- Get - Post - Put - Delete",link:"/tools/postman#发请求",textType:"text",routeTitle:"tools > postman",groupType:0},{text:"- 创建mock服务器 - 拿到服务器地址 https://424d6056-10c3-41ae-9534-3f7bdc49a5f1.mock.pstmn.io - 设置请求响应内容",link:"/tools/postman#mock服务器",textType:"text",routeTitle:"tools > postman",groupType:0},{text:"自动化测试",link:"/tools/postman#自动化测试",textType:"text",routeTitle:"tools > postman",groupType:0},{text:'执行顺序： pre-request->request->test - pre-request scripts pm.body={ "id": 1, "content": "content", "pushType": 2, "displayType": 1, "isPush": true } - request - test pm.test("Status code name has string", function () { console.log(pm.response) pm.expect(pm.response.code).to.be.eq(200,\'!=200\') pm.response.to.have.status("OK"); }); pm.test("Response time is less than 200ms", function () { pm.expect(pm.response.responseTime).to.be.below(200); });',link:"/tools/postman#单个接口测试",textType:"text",routeTitle:"tools > postman",groupType:0},{text:"排序顺序:接口排列顺序，由上往下执行",link:"/tools/postman#集合测试",textType:"text",routeTitle:"tools > postman",groupType:0},{text:"",link:"/tools/postman#查看http报文",textType:"text",routeTitle:"tools > postman",groupType:0},{text:"查看各语言版的请求",link:"/tools/postman#查看各语言版的请求",textType:"text",routeTitle:"tools > postman",groupType:0},{text:"",link:"/tools/postman#不会查帮助",textType:"text",routeTitle:"tools > postman",groupType:0},{text:"官方文档",link:"/tools/postman#参考",textType:"text",routeTitle:"tools > postman",groupType:0},{text:"",link:"/tools/webstorm#webstorm",textType:"text",routeTitle:"tools > webstorm",groupType:0},{text:"- .prettier.js文件如下 ```js module.exports = { $schema: 'https://json.schemastore.org/prettierrc', semi: true, tabWidth: 2, singleQuote: true, printWidth: 100, trailingComma: 'none' } ``` 注意webstorm启用保存运行prettier需要restart重启webstorm来加载配置 ```bash",link:"/tools/webstorm#prettier",textType:"code",routeTitle:"tools > webstorm",groupType:0},{text:"prettier --write src/main.ts ```",link:"/tools/webstorm#验证-prettier规则",textType:"code",routeTitle:"tools > webstorm",groupType:0},{text:"",link:"/tools/代码风格#代码风格",textType:"text",routeTitle:"tools > 代码风格",groupType:0},{text:"",link:"/tools/代码风格#设置webstorm代码风格",textType:"text",routeTitle:"tools > 代码风格",groupType:0},{text:"- 文档 - .editorconfig文件 ```editorconfig",link:"/tools/代码风格#editorconfig",textType:"code",routeTitle:"tools > 代码风格",groupType:0},{text:"root = true",link:"/tools/代码风格#http-editorconfig-org",textType:"text",routeTitle:"tools > 代码风格",groupType:0},{text:"说明",link:"/tools/代码风格#说明",textType:"text",routeTitle:"tools > 代码风格",groupType:0},{text:"设置文件编码为 UTF-8；",link:"/tools/代码风格#设置文件编码为-utf-8",textType:"text",routeTitle:"tools > 代码风格",groupType:0},{text:"用两个空格代替制表符；",link:"/tools/代码风格#用两个空格代替制表符",textType:"text",routeTitle:"tools > 代码风格",groupType:0},{text:"在保存时删除尾部的空白字符；",link:"/tools/代码风格#在保存时删除尾部的空白字符",textType:"text",routeTitle:"tools > 代码风格",groupType:0},{text:"[*] indent_style = space indent_size = 2 end_of_line = lf charset = utf-8 trim_trailing_whitespace = true insert_final_newline = true [*.md] trim_trailing_whitespace = false [Makefile] indent_style = tab ```",link:"/tools/代码风格#在文件结尾添加一个空白行",textType:"code",routeTitle:"tools > 代码风格",groupType:0},{text:"",link:"/tools/代码风格#eslint",textType:"text",routeTitle:"tools > 代码风格",groupType:0},{text:'``` "rules": { "no-debugger": "off", "quotes": ["error", "double"] }, ``` rules配置 off/0 warn/1 error/2 - 文档 - 有多个配置文件时的优先级 ``` 1 .eslintrc.js 2 .eslintrc.yaml 3 .eslintrc.yml 4 .eslintrc.json 5 .eslintrc 6 package.json ``` - .eslintrc.js ```js module.exports = { parser: \'@typescript-eslint/parser\', plugins: [\'react\',\'@typescript-eslint\'], rules: { // 禁止使用 var \'no-var\': "error", // 优先使用 interface 而不是 type \'@typescript-eslint/consistent-type-definitions\': [ "error", "interface" ] } } ```',link:"/tools/代码风格#配置规则",textType:"code",routeTitle:"tools > 代码风格",groupType:0},{text:'- 文档 - .prettierrc ```prettier { // 设置强制单引号 "singleQuote": true, // 为多行数组的非末尾行添加逗号 es5的对象，数组等 "trailingComma": "es5", // 每行最大宽度 100 "printWidth": 100, // 设置语句末尾不加分号 "semi": false, // jsx中使用单引号 "jsxSingleQuote": true, } ```',link:"/tools/代码风格#prettier",textType:"code",routeTitle:"tools > 代码风格",groupType:0},{text:"- 最强代码规范之-理解ESLint、Prettier、EditorConfig",link:"/tools/代码风格#参考",textType:"text",routeTitle:"tools > 代码风格",groupType:0},{text:"",link:"/tools/提效工具#提效工具",textType:"text",routeTitle:"tools > 提效工具",groupType:0},{text:"- 打开(command+option+I)chrome开发者工具，进入命令行页面(command+P)输入screenshot - 截取指定node图，先用开发者工具选中节点node，然后点击 Capture node screenshot",link:"/tools/提效工具#截长图",textType:"text",routeTitle:"tools > 提效工具",groupType:0},{text:"",link:"/tools/谷歌开发者工具#chrome开发工具",textType:"text",routeTitle:"tools > 谷歌开发者工具",groupType:0},{text:"红色的表示没有覆盖到的，点击文件进去可以查看详情，查看哪些代码没被覆盖到。",link:"/tools/谷歌开发者工具#代码覆盖率-show-coverage",textType:"text",routeTitle:"tools > 谷歌开发者工具",groupType:0},{text:"拍下两个时间的内存快照，比对看Delta的变化，若Delta数字明显增加则有存储溢出。",link:"/tools/谷歌开发者工具#查看内存溢出",textType:"text",routeTitle:"tools > 谷歌开发者工具",groupType:0},{text:"技术总结主要解决快速上手、快速查文档，从而快速解决问题，而不是不明方向地去试错 - 查代码 - 查书籍 - 更新博客",link:"/index#技术总结",textType:"text",routeTitle:"index > 首页",groupType:0},{text:"",link:"/index#常用网站导航",textType:"text",routeTitle:"index > 首页",groupType:0},{text:"- vue - pinia - vuex - antDesign - axios - vite - GitHub - 掘金",link:"/index#vue",textType:"text",routeTitle:"index > 首页",groupType:0},{text:"- react",link:"/index#react",textType:"text",routeTitle:"index > 首页",groupType:0},{text:"- 大佬博客",link:"/index#blog",textType:"text",routeTitle:"index > 首页",groupType:0},{text:"- 可维护 可读性、易扩展",link:"/index#代码衡量指标",textType:"text",routeTitle:"index > 首页",groupType:0},{text:"- **工程化** 脚手架 打包工具 调试 - 跨端 - 可视化",link:"/index#前端学习方向",textType:"text",routeTitle:"index > 首页",groupType:0},{text:"- 业务博客 - 优秀文档",link:"/index#学习资源",textType:"text",routeTitle:"index > 首页",groupType:0},{text:"nginx mysql 面试",link:"/index#后端文档",textType:"text",routeTitle:"index > 首页",groupType:0},{text:"Ecma WhatWg W3C http rfc 文件格式",link:"/index#进阶标准规范",textType:"text",routeTitle:"index > 首页",groupType:0}];export{e as default};
