import{_ as s,c as n,b as a,o as p}from"./chunks/framework.CUf7xJpa.js";const l=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. Promise 对象池","slug":"_1-promise-对象池","link":"#_1-promise-对象池","children":[]},{"level":2,"title":"2. 两个 Promise 对象相加","slug":"_2-两个-promise-对象相加","link":"#_2-两个-promise-对象相加","children":[]},{"level":2,"title":"3. 有时间限制的 Promise 对象","slug":"_3-有时间限制的-promise-对象","link":"#_3-有时间限制的-promise-对象","children":[]},{"level":2,"title":"4. 延迟每个 Promise 对象的解析","slug":"_4-延迟每个-promise-对象的解析","link":"#_4-延迟每个-promise-对象的解析","children":[]},{"level":2,"title":"5. 转换回调函数为 Promise 函数","slug":"_5-转换回调函数为-promise-函数","link":"#_5-转换回调函数为-promise-函数","children":[]},{"level":2,"title":"6. 并行执行 Promise 以获取独有的结果","slug":"_6-并行执行-promise-以获取独有的结果","link":"#_6-并行执行-promise-以获取独有的结果","children":[]},{"level":2,"title":"7. 并行执行异步函数","slug":"_7-并行执行异步函数","link":"#_7-并行执行异步函数","children":[]},{"level":2,"title":"8. 睡眠函数","slug":"_8-睡眠函数","link":"#_8-睡眠函数","children":[]},{"level":2,"title":"9. 异步任务调度器","slug":"_9-异步任务调度器","link":"#_9-异步任务调度器","children":[]},{"level":2,"title":"11. 设计可取消 Promise","slug":"_11-设计可取消-promise","link":"#_11-设计可取消-promise","children":[]},{"level":2,"title":"10. 多个 Callback 函数 Promise 化的测试用例","slug":"_10-多个-callback-函数-promise-化的测试用例","link":"#_10-多个-callback-函数-promise-化的测试用例","children":[]}],"relativePath":"frontend/Promise常见面试题.md","filePath":"frontend/Promise常见面试题.md"}');const o=s({name:"frontend/Promise常见面试题.md"},[["render",function(s,l,o,e,t,c){return p(),n("div",null,l[0]||(l[0]=[a('<p><img src="https://github.com/lecepin/blog/assets/11046969/6d063971-d2b7-466c-b012-38a60b783496" alt="image"></p><h2 id="_1-promise-对象池" tabindex="-1">1. Promise 对象池 <a class="header-anchor" href="#_1-promise-对象池" aria-label="Permalink to &quot;1\\. Promise 对象池&quot;">​</a></h2><p>请你编写一个异步函数 <code>promisePool</code> ，它接收一个异步函数数组 <code>functions</code> 和 池限制 <code>n</code>。它应该返回一个 <code>promise</code> 对象，当所有输入函数都执行完毕后，<code>promise</code> 对象就执行完毕。</p><p>池限制 定义是一次可以挂起的最多 <code>promise</code> 对象的数量。<code>promisePool</code> 应该开始执行尽可能多的函数，并在旧的 <code>promise</code> 执行完毕后继续执行新函数。<code>promisePool</code> 应该先执行 <code>functions[i]</code>，再执行 <code>functions[i + 1]</code>，然后执行 <code>functions[i + 2]</code>，等等。当最后一个 <code>promise</code> 执行完毕时，<code>promisePool</code> 也应该执行完毕。</p><p>例如，如果 <code>n = 1</code> , <code>promisePool</code> 在序列中每次执行一个函数。然而，如果 <code>n = 2</code> ，它首先执行两个函数。当两个函数中的任何一个执行完毕后，再执行第三个函数(如果它是可用的)，依此类推，直到没有函数要执行为止。</p><p>你可以假设所有的 <code>functions</code> 都不会被拒绝。对于 <code>promisePool</code> 来说，返回一个可以解析任何值的 <code>promise</code> 都是可以接受的。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>示例 1：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：</span></span>\n<span class="line"><span>functions = [</span></span>\n<span class="line"><span>  () =&gt; new Promise(res =&gt; setTimeout(res, 300)),</span></span>\n<span class="line"><span>  () =&gt; new Promise(res =&gt; setTimeout(res, 400)),</span></span>\n<span class="line"><span>  () =&gt; new Promise(res =&gt; setTimeout(res, 200))</span></span>\n<span class="line"><span>]</span></span>\n<span class="line"><span>n = 2</span></span>\n<span class="line"><span>输出：[[300,400,500],500]</span></span>\n<span class="line"><span>解释</span></span>\n<span class="line"><span>传递了三个函数。它们的睡眠时间分别为 300ms、 400ms 和 200ms。</span></span>\n<span class="line"><span>在 t=0 时，执行前两个函数。池大小限制达到 2。</span></span>\n<span class="line"><span>当 t=300 时，第一个函数执行完毕后，执行第3个函数。池大小为 2。</span></span>\n<span class="line"><span>在 t=400 时，第二个函数执行完毕后。没有什么可执行的了。池大小为 1。</span></span>\n<span class="line"><span>在 t=500 时，第三个函数执行完毕后。池大小为 0，因此返回的 promise 也执行完成。</span></span>\n<span class="line"><span>示例 2：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：</span></span>\n<span class="line"><span>functions = [</span></span>\n<span class="line"><span>  () =&gt; new Promise(res =&gt; setTimeout(res, 300)),</span></span>\n<span class="line"><span>  () =&gt; new Promise(res =&gt; setTimeout(res, 400)),</span></span>\n<span class="line"><span>  () =&gt; new Promise(res =&gt; setTimeout(res, 200))</span></span>\n<span class="line"><span>]</span></span>\n<span class="line"><span>n = 5</span></span>\n<span class="line"><span>输出：[[300,400,200],400]</span></span>\n<span class="line"><span>解释：</span></span>\n<span class="line"><span>在 t=0 时，所有3个函数都被执行。池的限制大小 5 永远不会满足。</span></span>\n<span class="line"><span>在 t=200 时，第三个函数执行完毕后。池大小为 2。</span></span>\n<span class="line"><span>在 t=300 时，第一个函数执行完毕后。池大小为 1。</span></span>\n<span class="line"><span>在 t=400 时，第二个函数执行完毕后。池大小为 0，因此返回的 promise 也执行完成。</span></span>\n<span class="line"><span>示例 3：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：</span></span>\n<span class="line"><span>functions = [</span></span>\n<span class="line"><span>  () =&gt; new Promise(res =&gt; setTimeout(res, 300)),</span></span>\n<span class="line"><span>  () =&gt; new Promise(res =&gt; setTimeout(res, 400)),</span></span>\n<span class="line"><span>  () =&gt; new Promise(res =&gt; setTimeout(res, 200))</span></span>\n<span class="line"><span>]</span></span>\n<span class="line"><span>n = 1</span></span>\n<span class="line"><span>输出：[[300,700,900],900]</span></span>\n<span class="line"><span>解释：</span></span>\n<span class="line"><span>在 t=0 时，执行第一个函数。池大小为1。</span></span>\n<span class="line"><span>当 t=300 时，第一个函数执行完毕后，执行第二个函数。池大小为 1。</span></span>\n<span class="line"><span>当 t=700 时，第二个函数执行完毕后，执行第三个函数。池大小为 1。</span></span>\n<span class="line"><span>在 t=900 时，第三个函数执行完毕后。池大小为 0，因此返回的 Promise 也执行完成。</span></span></code></pre></div><p>实现</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> F</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">any</span><span style="color:#E1E4E8;">&gt;;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> promisePool</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">functions</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> F</span><span style="color:#E1E4E8;">[], </span><span style="color:#FFAB70;">n</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> number</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">any</span><span style="color:#E1E4E8;">[]&gt; {</span></span>\n<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> fNext </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 下一个要执行的函数的索引</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">    // 递归调用该函数以依次执行下一个函数</span></span>\n<span class="line"><span style="color:#F97583;">    const</span><span style="color:#B392F0;"> evaluateNext</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> async</span><span style="color:#E1E4E8;"> ()</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">void</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (fNext </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> functions.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#6A737D;">            // 如果所有函数都已执行，则退出</span></span>\n<span class="line"><span style="color:#F97583;">            return</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#E1E4E8;">        }</span></span>\n<span class="line"><span style="color:#F97583;">        const</span><span style="color:#79B8FF;"> fn</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> functions[fNext</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">]; </span><span style="color:#6A737D;">// 获取下一个要执行的函数</span></span>\n<span class="line"><span style="color:#F97583;">        await</span><span style="color:#B392F0;"> fn</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 执行函数并等待其完成</span></span>\n<span class="line"><span style="color:#F97583;">        await</span><span style="color:#B392F0;"> evaluateNext</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 递归调用 evaluateNext，继续执行下一个函数</span></span>\n<span class="line"><span style="color:#E1E4E8;">    };</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">    // 同时启动 n 个 evaluateNext()调用来保持 n 个异步任务并发</span></span>\n<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> runners</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Array</span><span style="color:#E1E4E8;">(n).</span><span style="color:#B392F0;">fill</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">map</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> evaluateNext</span><span style="color:#E1E4E8;">());</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">    // 等待所有启动的任务完成</span></span>\n<span class="line"><span style="color:#F97583;">    return</span><span style="color:#79B8FF;"> Promise</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">all</span><span style="color:#E1E4E8;">(runners)</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="_2-两个-promise-对象相加" tabindex="-1">2. 两个 Promise 对象相加 <a class="header-anchor" href="#_2-两个-promise-对象相加" aria-label="Permalink to &quot;2\\. 两个 Promise 对象相加&quot;">​</a></h2><p>给定两个 promise 对象 promise1 和 promise2，返回一个新的 promise。promise1 和 promise2 都会被解析为一个数字。返回的 Promise 应该解析为这两个数字的和。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>示例 1：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：</span></span>\n<span class="line"><span>promise1 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(2), 20)),</span></span>\n<span class="line"><span>promise2 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(5), 60))</span></span>\n<span class="line"><span>输出：7</span></span>\n<span class="line"><span>解释：两个输入的 Promise 分别解析为值 2 和 5。返回的 Promise 应该解析为 2 + 5 = 7。返回的 Promise 解析的时间不作为判断条件。</span></span>\n<span class="line"><span>示例 2：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：</span></span>\n<span class="line"><span>promise1 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(10), 50)),</span></span>\n<span class="line"><span>promise2 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(-12), 30))</span></span>\n<span class="line"><span>输出：-2</span></span>\n<span class="line"><span>解释：两个输入的 Promise 分别解析为值 10 和 -12。返回的 Promise 应该解析为 10 + -12 = -2。</span></span></code></pre></div><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> P</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">async</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> addTwoPromises</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">promise1</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> P</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">promise2</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> P</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> P</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#E1E4E8;">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">/**</span></span>\n<span class="line"><span style="color:#6A737D;"> * addTwoPromises(Promise.resolve(2), Promise.resolve(2))</span></span>\n<span class="line"><span style="color:#6A737D;"> *   .then(console.log); // 4</span></span>\n<span class="line"><span style="color:#6A737D;"> */</span></span></code></pre></div><p>实现</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">async</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> addTwoPromises</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">promise1</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt;, </span><span style="color:#FFAB70;">promise2</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt;)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt; {</span></span>\n<span class="line"><span style="color:#F97583;">   return</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> promise1 </span><span style="color:#F97583;">+</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> promise2</span></span>\n<span class="line"><span style="color:#E1E4E8;">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">async</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> addTwoPromises</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">promise1</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt;, </span><span style="color:#FFAB70;">promise2</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt;)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt; {</span></span>\n<span class="line"><span style="color:#F97583;">   return</span><span style="color:#F97583;"> await</span><span style="color:#79B8FF;"> Promise</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">all</span><span style="color:#E1E4E8;">([promise1, promise2]).</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(([</span><span style="color:#FFAB70;">a</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">b</span><span style="color:#E1E4E8;">]) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> b)</span></span>\n<span class="line"><span style="color:#E1E4E8;">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">async</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> addTwoPromises</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">promise1</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt;, </span><span style="color:#FFAB70;">promise2</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt;)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt; {</span></span>\n<span class="line"><span style="color:#F97583;">   const</span><span style="color:#E1E4E8;"> [</span><span style="color:#79B8FF;">a</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">b</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> await</span><span style="color:#79B8FF;"> Promise</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">all</span><span style="color:#E1E4E8;">([promise1, promise2])</span></span>\n<span class="line"><span style="color:#F97583;">   return</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> b</span></span>\n<span class="line"><span style="color:#E1E4E8;">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">async</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> addTwoPromises</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">promise1</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt;, </span><span style="color:#FFAB70;">promise2</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt;)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt; {</span></span>\n<span class="line"><span style="color:#F97583;">   return</span><span style="color:#F97583;"> new</span><span style="color:#79B8FF;"> Promise</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">resolve</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">reject</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#79B8FF;">       Promise</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">all</span><span style="color:#E1E4E8;">([promise1, promise2]).</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(([</span><span style="color:#FFAB70;">a</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">b</span><span style="color:#E1E4E8;">]) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#B392F0;">           resolve</span><span style="color:#E1E4E8;">(a </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> b)</span></span>\n<span class="line"><span style="color:#E1E4E8;">       }).</span><span style="color:#B392F0;">catch</span><span style="color:#E1E4E8;">(reject)</span></span>\n<span class="line"><span style="color:#E1E4E8;">   })</span></span>\n<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre></div><h2 id="_3-有时间限制的-promise-对象" tabindex="-1">3. 有时间限制的 Promise 对象 <a class="header-anchor" href="#_3-有时间限制的-promise-对象" aria-label="Permalink to &quot;3\\. 有时间限制的 Promise 对象&quot;">​</a></h2><p>请你编写一个函数，它接受一个异步函数 fn 和一个以毫秒为单位的时间 t。它应根据限时函数返回一个有 限时 效果的函数。函数 fn 接受提供给 限时 函数的参数。</p><p>限时 函数应遵循以下规则：</p><p>如果 fn 在 t 毫秒的时间限制内完成，限时 函数应返回结果。 如果 fn 的执行超过时间限制，限时 函数应拒绝并返回字符串 &quot;Time Limit Exceeded&quot; 。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>示例 1：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：</span></span>\n<span class="line"><span>fn = async (n) =&gt; {</span></span>\n<span class="line"><span>  await new Promise(res =&gt; setTimeout(res, 100));</span></span>\n<span class="line"><span>  return n * n;</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>inputs = [5]</span></span>\n<span class="line"><span>t = 50</span></span>\n<span class="line"><span>输出：{&quot;rejected&quot;:&quot;Time Limit Exceeded&quot;,&quot;time&quot;:50}</span></span>\n<span class="line"><span>解释：</span></span>\n<span class="line"><span>const limited = timeLimit(fn, t)</span></span>\n<span class="line"><span>const start = performance.now()</span></span>\n<span class="line"><span>let result;</span></span>\n<span class="line"><span>try {</span></span>\n<span class="line"><span>   const res = await limited(...inputs)</span></span>\n<span class="line"><span>   result = {&quot;resolved&quot;: res, &quot;time&quot;: Math.floor(performance.now() - start)};</span></span>\n<span class="line"><span>} catch (err) {</span></span>\n<span class="line"><span>   result = {&quot;rejected&quot;: err, &quot;time&quot;: Math.floor(performance.now() - start)};</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>console.log(result) // 输出结果</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>提供的函数设置在 100ms 后执行完成，但是设置的超时时间为 50ms，所以在 t=50ms 时拒绝因为达到了超时时间。</span></span>\n<span class="line"><span>示例 2：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：</span></span>\n<span class="line"><span>fn = async (n) =&gt; {</span></span>\n<span class="line"><span>  await new Promise(res =&gt; setTimeout(res, 100));</span></span>\n<span class="line"><span>  return n * n;</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>inputs = [5]</span></span>\n<span class="line"><span>t = 150</span></span>\n<span class="line"><span>输出：{&quot;resolved&quot;:25,&quot;time&quot;:100}</span></span>\n<span class="line"><span>解释：</span></span>\n<span class="line"><span>在 t=100ms 时执行 5*5=25 ，没有达到超时时间。</span></span>\n<span class="line"><span>示例 3：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：</span></span>\n<span class="line"><span>fn = async (a, b) =&gt; {</span></span>\n<span class="line"><span>  await new Promise(res =&gt; setTimeout(res, 120));</span></span>\n<span class="line"><span>  return a + b;</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>inputs = [5,10]</span></span>\n<span class="line"><span>t = 150</span></span>\n<span class="line"><span>输出：{&quot;resolved&quot;:15,&quot;time&quot;:120}</span></span>\n<span class="line"><span>解释：</span></span>\n<span class="line"><span>在 t=120ms 时执行 5+10=15，没有达到超时时间。</span></span>\n<span class="line"><span>示例 4：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：</span></span>\n<span class="line"><span>fn = async () =&gt; {</span></span>\n<span class="line"><span>  throw &quot;Error&quot;;</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>inputs = []</span></span>\n<span class="line"><span>t = 1000</span></span>\n<span class="line"><span>输出：{&quot;rejected&quot;:&quot;Error&quot;,&quot;time&quot;:0}</span></span>\n<span class="line"><span>解释：</span></span>\n<span class="line"><span>此函数始终丢出 Error</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>提示：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>0 &lt;= inputs.length &lt;= 10</span></span>\n<span class="line"><span>0 &lt;= t &lt;= 1000</span></span>\n<span class="line"><span>fn 返回一个 Promise 对象</span></span></code></pre></div><p>实现</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> Fn</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">...</span><span style="color:#FFAB70;">params</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> any</span><span style="color:#E1E4E8;">[]) </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">any</span><span style="color:#E1E4E8;">&gt;;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> timeLimit</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">fn</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Fn</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">t</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> number</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Fn</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">  return</span><span style="color:#F97583;"> async</span><span style="color:#F97583;"> function</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">...</span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#F97583;">    return</span><span style="color:#F97583;"> new</span><span style="color:#79B8FF;"> Promise</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">resolve</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">reject</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">      const</span><span style="color:#79B8FF;"> timeout</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#B392F0;">        reject</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Time Limit Exceeded&quot;</span><span style="color:#E1E4E8;">);</span></span>\n<span class="line"><span style="color:#E1E4E8;">      }, t);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">      try</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">        const</span><span style="color:#79B8FF;"> result</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fn</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">args);</span></span>\n<span class="line"><span style="color:#B392F0;">        resolve</span><span style="color:#E1E4E8;">(result);</span></span>\n<span class="line"><span style="color:#E1E4E8;">      } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;">(err) {</span></span>\n<span class="line"><span style="color:#B392F0;">        reject</span><span style="color:#E1E4E8;">(err);</span></span>\n<span class="line"><span style="color:#E1E4E8;">      }</span></span>\n<span class="line"><span style="color:#B392F0;">      clearTimeout</span><span style="color:#E1E4E8;">(timeout);</span></span>\n<span class="line"><span style="color:#E1E4E8;">    });</span></span>\n<span class="line"><span style="color:#E1E4E8;">  };</span></span>\n<span class="line"><span style="color:#E1E4E8;">};</span></span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">/**</span></span>\n<span class="line"><span style="color:#6A737D;"> * const limited = timeLimit((t) =&gt; new Promise(res =&gt; setTimeout(res, t)), 100);</span></span>\n<span class="line"><span style="color:#6A737D;"> * limited(150).catch(console.log) // &quot;Time Limit Exceeded&quot; at t=100ms</span></span>\n<span class="line"><span style="color:#6A737D;"> */</span></span></code></pre></div><h2 id="_4-延迟每个-promise-对象的解析" tabindex="-1">4. 延迟每个 Promise 对象的解析 <a class="header-anchor" href="#_4-延迟每个-promise-对象的解析" aria-label="Permalink to &quot;4\\. 延迟每个 Promise 对象的解析&quot;">​</a></h2><p>给定一个函数数组 functions 和一个数字 ms，返回一个新的函数数组。</p><p>functions 是一个返回 Promise 对象的函数数组。 ms 表示延迟的时间，以毫秒为单位。它决定了在新数组中的每个函数返回的 Promise 在解析之前等待的时间。 新数组中的每个函数应该返回一个 Promise 对象，在延迟了 ms 毫秒后解析，保持原始 functions 数组中的顺序。delayAll 函数应确保从 functions 中的每个 Promise 都被延迟执行，形成返回延迟的 Promise 的函数的新数组。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>示例 1：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：</span></span>\n<span class="line"><span>functions = [</span></span>\n<span class="line"><span>   () =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 30))</span></span>\n<span class="line"><span>],</span></span>\n<span class="line"><span>ms = 50</span></span>\n<span class="line"><span>输出：[80]</span></span>\n<span class="line"><span>解释：数组中的 Promise 在 30 毫秒后解析，但被延迟了 50 毫秒，所以总共延迟了 30 毫秒 + 50 毫秒 = 80 毫秒。</span></span>\n<span class="line"><span>示例 2：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：</span></span>\n<span class="line"><span>functions = [</span></span>\n<span class="line"><span>    () =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 50)),</span></span>\n<span class="line"><span>    () =&gt; new Promise((resolve) =&gt; setTimeout(resolve, 80))</span></span>\n<span class="line"><span>],</span></span>\n<span class="line"><span>ms = 70</span></span>\n<span class="line"><span>输出：[120,150]</span></span>\n<span class="line"><span>解释：数组中的 Promise 在 50 毫秒和 80 毫秒后解析，但它们被延迟了 70 毫秒，所以总共延迟了 50 毫秒 + 70 毫秒 = 120 毫秒 和 80 毫秒 + 70 毫秒 = 150 毫秒。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>提示：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>functions 是一个返回 Promise 对象的函数数组</span></span>\n<span class="line"><span>10 &lt;= ms &lt;= 500</span></span>\n<span class="line"><span>1 &lt;= functions.length &lt;= 10</span></span></code></pre></div><p>实现</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> Fn</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">any</span><span style="color:#E1E4E8;">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> delayAll</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">functions</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Fn</span><span style="color:#E1E4E8;">[], </span><span style="color:#FFAB70;">ms</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> number</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Fn</span><span style="color:#E1E4E8;">[] {</span></span>\n<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> functions.</span><span style="color:#B392F0;">map</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">fn</span><span style="color:#F97583;"> =&gt;</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#F97583;"> new</span><span style="color:#79B8FF;"> Promise</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">res</span><span style="color:#F97583;"> =&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#B392F0;">        setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#B392F0;">            res</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">fn</span><span style="color:#E1E4E8;">())</span></span>\n<span class="line"><span style="color:#E1E4E8;">        }, ms)</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }))</span></span>\n<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre></div><h2 id="_5-转换回调函数为-promise-函数" tabindex="-1">5. 转换回调函数为 Promise 函数 <a class="header-anchor" href="#_5-转换回调函数为-promise-函数" aria-label="Permalink to &quot;5\\. 转换回调函数为 Promise 函数&quot;">​</a></h2><p>编写一个函数，接受另一个函数 fn ，并将基于回调函数的函数转换为基于 Promise 的函数。</p><p>promisify 函数接受一个函数 fn ，fn 将回调函数作为其第一个参数，并且还可以接受其他额外的参数。</p><p>promisfy 返回一个新函数，新函数会返回一个 Promise 对象。当回调函数被成功调用时，新函数返回的 Promise 对象应该使用原始函数的结果进行解析；当回调函数被调用出现错误时，返回的 Promise 对象应该被拒绝并携带错误信息。最终返回的基于 Promise 的函数应该接受额外的参数作为输入。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>以下是一个可以传递给 promisify 的函数示例：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>function sum(callback, a, b) {</span></span>\n<span class="line"><span>  if (a &lt; 0 || b &lt; 0) {</span></span>\n<span class="line"><span>    const err = Error(&#39;a and b must be positive&#39;);</span></span>\n<span class="line"><span>    callback(undefined, err);</span></span>\n<span class="line"><span>  } else {</span></span>\n<span class="line"><span>    callback(a + b);</span></span>\n<span class="line"><span>  }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>这是基于 Promise 的等效代码：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>async function sum(a, b) {</span></span>\n<span class="line"><span>  if (a &lt; 0 || b &lt; 0) {</span></span>\n<span class="line"><span>    throw Error(&#39;a and b must be positive&#39;);</span></span>\n<span class="line"><span>  } else {</span></span>\n<span class="line"><span>    return a + b;</span></span>\n<span class="line"><span>  }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>示例 1：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：</span></span>\n<span class="line"><span>fn = (callback, a, b, c) =&gt; {</span></span>\n<span class="line"><span>  return callback(a * b * c);</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>args = [1, 2, 3]</span></span>\n<span class="line"><span>输出：{&quot;resolved&quot;: 6}</span></span>\n<span class="line"><span>解释：</span></span>\n<span class="line"><span>const asyncFunc = promisify(fn);</span></span>\n<span class="line"><span>asyncFunc(1, 2, 3).then(console.log); // 6</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>fn 以回调函数作为第一个参数和 args 作为其余参数进行调用。当使用 (1, 2, 3) 调用时，基于 Promise 的 fn 将解析为值 6。</span></span>\n<span class="line"><span>示例 2：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：</span></span>\n<span class="line"><span>fn = (callback, a, b, c) =&gt; {</span></span>\n<span class="line"><span>  callback(a * b * c, &quot;Promise Rejected&quot;);</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>args = [4, 5, 6]</span></span>\n<span class="line"><span>输出：{&quot;rejected&quot;: &quot;Promise Rejected&quot;}</span></span>\n<span class="line"><span>解释：</span></span>\n<span class="line"><span>const asyncFunc = promisify(fn);</span></span>\n<span class="line"><span>asyncFunc(4, 5, 6).catch(console.log); // &quot;Promise Rejected&quot;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>fn 以回调函数作为第一个参数和 args 作为其余参数进行调用。在回调函数的第二个参数中，接受一个错误消息，因此当调用 fn 时，Promise 被拒绝并携带回调函数中提供的错误消息。请注意，不管将什么作为回调函数的第一个参数传递都无关紧要。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>提示：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>1 &lt;= args.length &lt;= 100</span></span>\n<span class="line"><span>0 &lt;= args[i] &lt;= 104</span></span></code></pre></div><p>实现</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> CallbackFn</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> (</span></span>\n<span class="line"><span style="color:#B392F0;">    next</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">data</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> number</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">error</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> string</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span><span style="color:#E1E4E8;">,</span></span>\n<span class="line"><span style="color:#F97583;">    ...</span><span style="color:#FFAB70;">args</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> number</span><span style="color:#E1E4E8;">[]</span></span>\n<span class="line"><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>\n<span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> Promisified</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">...</span><span style="color:#FFAB70;">args</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> number</span><span style="color:#E1E4E8;">[]) </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> promisify</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">fn</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> CallbackFn</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promisified</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">  return</span><span style="color:#F97583;"> async</span><span style="color:#F97583;"> function</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">...</span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#F97583;">    return</span><span style="color:#F97583;"> new</span><span style="color:#79B8FF;"> Promise</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">resolve</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">reject</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#B392F0;">      fn</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">data</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> number</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">error</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> string</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (error) </span><span style="color:#B392F0;">reject</span><span style="color:#E1E4E8;">(error);</span></span>\n<span class="line"><span style="color:#B392F0;">        resolve</span><span style="color:#E1E4E8;">(data);</span></span>\n<span class="line"><span style="color:#E1E4E8;">      }, </span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">args);</span></span>\n<span class="line"><span style="color:#E1E4E8;">    });</span></span>\n<span class="line"><span style="color:#E1E4E8;">  };</span></span>\n<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre></div><h2 id="_6-并行执行-promise-以获取独有的结果" tabindex="-1">6. 并行执行 Promise 以获取独有的结果 <a class="header-anchor" href="#_6-并行执行-promise-以获取独有的结果" aria-label="Permalink to &quot;6\\. 并行执行 Promise 以获取独有的结果&quot;">​</a></h2><p>给定一个数组 functions，返回一个 promise 对象 promise。functions 是一个返回多个 promise 对象 fnPromise 的函数数组。每个 fnPromise 可以被解析（resolved）或拒绝（rejected）。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>如果 fnPromise 被解析：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    obj = { status: &quot;fulfilled&quot;, value: resolved value}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>如果 fnPromise 被拒绝：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    obj = { status: &quot;rejected&quot;, reason: 拒绝的原因（捕获的错误消息）}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>该 promise 应该返回一个包含这些对象 obj 的数组。数组中的每个 obj 应该对应原始函数数组中的多个 promise 对象，并保持相同的顺序。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>请在不使用内置方法 Promise.allSettled() 的情况下实现它。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>示例 1：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：functions = [</span></span>\n<span class="line"><span>    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(15), 100))</span></span>\n<span class="line"><span>]</span></span>\n<span class="line"><span>输出：{&quot;t&quot;:100,&quot;values&quot;:[{&quot;status&quot;:&quot;fulfilled&quot;,&quot;value&quot;:15}]}</span></span>\n<span class="line"><span>解释：</span></span>\n<span class="line"><span>const time = performance.now()</span></span>\n<span class="line"><span>const promise = promiseAllSettled(functions);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>promise.then(res =&gt; {</span></span>\n<span class="line"><span>    const out = {t: Math.floor(performance.now() - time), values: res}</span></span>\n<span class="line"><span>    console.log(out) // {&quot;t&quot;:100,&quot;values&quot;:[{&quot;status&quot;:&quot;fulfilled&quot;,&quot;value&quot;:15}]}</span></span>\n<span class="line"><span>})</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>返回的 promise 在 100 毫秒内解析。由于函数数组中的 promise 被解析，返回的 promise 的解析值设置为[{&quot;status&quot;:&quot;fulfilled&quot;,&quot;value&quot;:15}]。</span></span>\n<span class="line"><span>示例 2：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：functions = [</span></span>\n<span class="line"><span>    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(20), 100)),</span></span>\n<span class="line"><span>    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(15), 100))</span></span>\n<span class="line"><span>]</span></span>\n<span class="line"><span>输出：</span></span>\n<span class="line"><span>{</span></span>\n<span class="line"><span>    &quot;t&quot;:100,</span></span>\n<span class="line"><span>    &quot;values&quot;: [</span></span>\n<span class="line"><span>        {&quot;status&quot;:&quot;fulfilled&quot;,&quot;value&quot;:20},</span></span>\n<span class="line"><span>        {&quot;status&quot;:&quot;fulfilled&quot;,&quot;value&quot;:15}</span></span>\n<span class="line"><span>    ]</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>解释：返回的 promise 在 100 毫秒内解析，因为解析时间取决于需要最长时间来解析的 promise。由于函数数组中的 promises 被解析，返回的 promise 的解析值设置为[{&quot;status&quot;:&quot;fulfilled&quot;,&quot;value&quot;:20},{&quot;status&quot;:&quot;fulfilled&quot;,&quot;value&quot;:15}]。</span></span>\n<span class="line"><span>示例 3：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：functions = [</span></span>\n<span class="line"><span>    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(30), 200)),</span></span>\n<span class="line"><span>    () =&gt; new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(&quot;Error&quot;), 100))</span></span>\n<span class="line"><span>]</span></span>\n<span class="line"><span>输出：</span></span>\n<span class="line"><span>{</span></span>\n<span class="line"><span>    &quot;t&quot;:200,</span></span>\n<span class="line"><span>    &quot;values&quot;: [</span></span>\n<span class="line"><span>        {&quot;status&quot;:&quot;fulfilled&quot;,&quot;value&quot;:30},</span></span>\n<span class="line"><span>        {&quot;status&quot;:&quot;rejected&quot;,&quot;reason&quot;:&quot;Error&quot;}</span></span>\n<span class="line"><span>    ]</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>解释：返回的 promise 在 200 毫秒内解析，因为解析时间取决于需要最长时间来解析的 promise。由于函数数组中的一个 promise 被解析，另一个被拒绝，返回的 promise 的解析值设置为[{&quot;status&quot;:&quot;fulfilled&quot;,&quot;value&quot;:30},{&quot;status&quot;:&quot;rejected&quot;,&quot;reason&quot;:&quot;Error&quot;}]。数组中的每个对象对应原始函数数组中的 promise，并保持相同的顺序。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>提示：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>1 &lt;= functions.length &lt;= 10</span></span></code></pre></div><p>实现</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> FulfilledObj</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#FFAB70;">    status</span><span style="color:#F97583;">:</span><span style="color:#9ECBFF;"> &#39;fulfilled&#39;</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#FFAB70;">    value</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> string</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span>\n<span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> RejectedObj</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#FFAB70;">    status</span><span style="color:#F97583;">:</span><span style="color:#9ECBFF;"> &#39;rejected&#39;</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#FFAB70;">    reason</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> string</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span>\n<span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> Obj</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> FulfilledObj</span><span style="color:#F97583;"> |</span><span style="color:#B392F0;"> RejectedObj</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> promiseAllSettled</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">functions</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Function</span><span style="color:#E1E4E8;">[])</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">Obj</span><span style="color:#E1E4E8;">[]&gt; {</span></span>\n<span class="line"><span style="color:#F97583;">    return</span><span style="color:#F97583;"> new</span><span style="color:#79B8FF;"> Promise</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">resolve</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> resultArray</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> [];</span></span>\n<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> completedCount </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> functions.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#F97583;">      const</span><span style="color:#79B8FF;"> fnPromise</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> functions[i]();</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#E1E4E8;">      fnPromise</span></span>\n<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">          resultArray[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { status: </span><span style="color:#9ECBFF;">&quot;fulfilled&quot;</span><span style="color:#E1E4E8;">, value };</span></span>\n<span class="line"><span style="color:#E1E4E8;">        })</span></span>\n<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">catch</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">reason</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">          resultArray[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { status: </span><span style="color:#9ECBFF;">&quot;rejected&quot;</span><span style="color:#E1E4E8;">, reason };</span></span>\n<span class="line"><span style="color:#E1E4E8;">        })</span></span>\n<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">finally</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">          completedCount</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#F97583;">         if</span><span style="color:#E1E4E8;"> (completedCount </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> functions.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#B392F0;">            resolve</span><span style="color:#E1E4E8;">(resultArray);</span></span>\n<span class="line"><span style="color:#E1E4E8;">          }</span></span>\n<span class="line"><span style="color:#E1E4E8;">        });</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  });</span></span>\n<span class="line"><span style="color:#E1E4E8;">};</span></span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">/**</span></span>\n<span class="line"><span style="color:#6A737D;"> * const functions = [</span></span>\n<span class="line"><span style="color:#6A737D;"> *    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(15), 100))</span></span>\n<span class="line"><span style="color:#6A737D;"> * ]</span></span>\n<span class="line"><span style="color:#6A737D;"> * const time = performance.now()</span></span>\n<span class="line"><span style="color:#6A737D;"> *</span></span>\n<span class="line"><span style="color:#6A737D;"> * const promise = promiseAllSettled(functions);</span></span>\n<span class="line"><span style="color:#6A737D;"> *</span></span>\n<span class="line"><span style="color:#6A737D;"> * promise.then(res =&gt; {</span></span>\n<span class="line"><span style="color:#6A737D;"> *     const out = {t: Math.floor(performance.now() - time), values: res}</span></span>\n<span class="line"><span style="color:#6A737D;"> *     console.log(out) // {&quot;t&quot;:100,&quot;values&quot;:[{&quot;status&quot;:&quot;fulfilled&quot;,&quot;value&quot;:15}]}</span></span>\n<span class="line"><span style="color:#6A737D;"> * })</span></span>\n<span class="line"><span style="color:#6A737D;"> */</span></span></code></pre></div><h2 id="_7-并行执行异步函数" tabindex="-1">7. 并行执行异步函数 <a class="header-anchor" href="#_7-并行执行异步函数" aria-label="Permalink to &quot;7\\. 并行执行异步函数&quot;">​</a></h2><p>给定一个异步函数数组 functions，返回一个新的 promise 对象 promise。数组中的每个函数都不接受参数并返回一个 promise。所有的 promise 都应该并行执行。</p><p>promise resolve 条件：</p><p>当所有从 functions 返回的 promise 都成功的并行解析时。promise 的解析值应该是一个按照它们在 functions 中的顺序排列的 promise 的解析值数组。promise 应该在数组中的所有异步函数并行执行完成时解析。 promise reject 条件：</p><p>当任何从 functions 返回的 promise 被拒绝时。promise 也会被拒绝，并返回第一个拒绝的原因。 请在不使用内置的 Promise.all 函数的情况下解决。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>示例 1：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：functions = [</span></span>\n<span class="line"><span>  () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(5), 200))</span></span>\n<span class="line"><span>]</span></span>\n<span class="line"><span>输出：{&quot;t&quot;: 200, &quot;resolved&quot;: [5]}</span></span>\n<span class="line"><span>解释：</span></span>\n<span class="line"><span>promiseAll(functions).then(console.log); // [5]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>单个函数在 200 毫秒后以值 5 成功解析。</span></span>\n<span class="line"><span>示例 2：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：functions = [</span></span>\n<span class="line"><span>    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(1), 200)),</span></span>\n<span class="line"><span>    () =&gt; new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(&quot;Error&quot;), 100))</span></span>\n<span class="line"><span>]</span></span>\n<span class="line"><span>输出：{&quot;t&quot;: 100, &quot;rejected&quot;: &quot;Error&quot;}</span></span>\n<span class="line"><span>解释：由于其中一个 promise 被拒绝，返回的 promise 也在同一时间被拒绝并返回相同的错误。</span></span>\n<span class="line"><span>示例 3：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：functions = [</span></span>\n<span class="line"><span>    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(4), 50)),</span></span>\n<span class="line"><span>    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(10), 150)),</span></span>\n<span class="line"><span>    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(16), 100))</span></span>\n<span class="line"><span>]</span></span>\n<span class="line"><span>输出：{&quot;t&quot;: 150, &quot;resolved&quot;: [4, 10, 16]}</span></span>\n<span class="line"><span>解释：所有的 promise 都成功执行。当最后一个 promise 被解析时，返回的 promise 也被解析了。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>提示：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>函数 functions 是一个返回 promise 的函数数组</span></span>\n<span class="line"><span>1 &lt;= functions.length &lt;= 10</span></span></code></pre></div><p>实现</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> Fn</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">async</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> promiseAll</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">functions</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> (() </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;)[])</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">[]&gt; {</span></span>\n<span class="line"><span style="color:#F97583;">  return</span><span style="color:#F97583;"> new</span><span style="color:#79B8FF;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">[]&gt;((</span><span style="color:#FFAB70;">resolve</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">reject</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;">(functions.</span><span style="color:#79B8FF;">length</span><span style="color:#F97583;"> ===</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#B392F0;">      resolve</span><span style="color:#E1E4E8;">([]);</span></span>\n<span class="line"><span style="color:#F97583;">      return</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> res</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">[] </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Array</span><span style="color:#E1E4E8;">(functions.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">fill</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> resolvedCount </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#E1E4E8;">    functions.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">el</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">idx</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">      try</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">        const</span><span style="color:#79B8FF;"> subResult</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> el</span><span style="color:#E1E4E8;">();</span></span>\n<span class="line"><span style="color:#E1E4E8;">        res[idx] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> subResult;</span></span>\n<span class="line"><span style="color:#E1E4E8;">        resolvedCount</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;">(resolvedCount </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> functions.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#B392F0;">          resolve</span><span style="color:#E1E4E8;">(res);</span></span>\n<span class="line"><span style="color:#E1E4E8;">        }</span></span>\n<span class="line"><span style="color:#E1E4E8;">      } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;">(err) {</span></span>\n<span class="line"><span style="color:#B392F0;">        reject</span><span style="color:#E1E4E8;">(err);</span></span>\n<span class="line"><span style="color:#E1E4E8;">      }</span></span>\n<span class="line"><span style="color:#E1E4E8;">    });</span></span>\n<span class="line"><span style="color:#E1E4E8;">  });</span></span>\n<span class="line"><span style="color:#E1E4E8;">};</span></span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">/**</span></span>\n<span class="line"><span style="color:#6A737D;"> * const promise = promiseAll([() =&gt; new Promise(res =&gt; res(42))])</span></span>\n<span class="line"><span style="color:#6A737D;"> * promise.then(console.log); // [42]</span></span>\n<span class="line"><span style="color:#6A737D;"> */</span></span></code></pre></div><h2 id="_8-睡眠函数" tabindex="-1">8. 睡眠函数 <a class="header-anchor" href="#_8-睡眠函数" aria-label="Permalink to &quot;8\\. 睡眠函数&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>请你编写一个异步函数，它接收一个正整数参数 millis ，并休眠 millis 毫秒。要求此函数可以解析任何值。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>示例 1：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：millis = 100</span></span>\n<span class="line"><span>输出：100</span></span>\n<span class="line"><span>解释：</span></span>\n<span class="line"><span>在 100ms 后此异步函数执行完时返回一个 Promise 对象</span></span>\n<span class="line"><span>let t = Date.now();</span></span>\n<span class="line"><span>sleep(100).then(() =&gt; {</span></span>\n<span class="line"><span> console.log(Date.now() - t); // 100</span></span>\n<span class="line"><span>});</span></span>\n<span class="line"><span>示例 2：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>输入：millis = 200</span></span>\n<span class="line"><span>输出：200</span></span>\n<span class="line"><span>解释：在 200ms 后函数执行完时返回一个 Promise 对象</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>提示：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>1 &lt;= millis &lt;= 1000</span></span></code></pre></div><p>实现</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">async</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">millis</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> number</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">void</span><span style="color:#E1E4E8;">&gt; {</span></span>\n<span class="line"><span style="color:#F97583;">    return</span><span style="color:#F97583;"> new</span><span style="color:#79B8FF;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">void</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">resolve</span><span style="color:#F97583;"> =&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#B392F0;">        setTimeout</span><span style="color:#E1E4E8;">(resolve, millis);</span></span>\n<span class="line"><span style="color:#E1E4E8;">    });</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="_9-异步任务调度器" tabindex="-1">9. 异步任务调度器 <a class="header-anchor" href="#_9-异步任务调度器" aria-label="Permalink to &quot;9\\. 异步任务调度器&quot;">​</a></h2><p>描述：实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有 limit 个。</p><p>实现</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> PromiseCreator</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">void</span><span style="color:#E1E4E8;">&gt;;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">class</span><span style="color:#B392F0;"> Scheduler</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">    private</span><span style="color:#FFAB70;"> queue</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> PromiseCreator</span><span style="color:#E1E4E8;">[];  </span><span style="color:#6A737D;">// 用队列保存正在执行的任务</span></span>\n<span class="line"><span style="color:#F97583;">    private</span><span style="color:#FFAB70;"> runCount</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> number</span><span style="color:#E1E4E8;">;        </span><span style="color:#6A737D;">// 计数正在执行的任务个数</span></span>\n<span class="line"><span style="color:#F97583;">    private</span><span style="color:#FFAB70;"> maxCount</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> number</span><span style="color:#E1E4E8;">;        </span><span style="color:#6A737D;">// 允许并发的最大个数</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">    constructor</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">limit</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> number</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#79B8FF;">        this</span><span style="color:#E1E4E8;">.queue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [];</span></span>\n<span class="line"><span style="color:#79B8FF;">        this</span><span style="color:#E1E4E8;">.runCount </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#79B8FF;">        this</span><span style="color:#E1E4E8;">.maxCount </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> limit;</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#B392F0;">    add</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">time</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> number</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">data</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> string</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#F97583;">        const</span><span style="color:#B392F0;"> promiseCreator</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> PromiseCreator</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">            return</span><span style="color:#F97583;"> new</span><span style="color:#79B8FF;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">void</span><span style="color:#E1E4E8;">&gt;((</span><span style="color:#FFAB70;">resolve</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#B392F0;">                setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">                    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(data);</span></span>\n<span class="line"><span style="color:#B392F0;">                    resolve</span><span style="color:#E1E4E8;">();</span></span>\n<span class="line"><span style="color:#E1E4E8;">                }, time);</span></span>\n<span class="line"><span style="color:#E1E4E8;">            });</span></span>\n<span class="line"><span style="color:#E1E4E8;">        }</span></span>\n<span class="line"><span style="color:#79B8FF;">        this</span><span style="color:#E1E4E8;">.queue.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(promiseCreator);</span></span>\n<span class="line"><span style="color:#6A737D;">        // 每次添加的时候都会尝试去执行任务</span></span>\n<span class="line"><span style="color:#79B8FF;">        this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">request</span><span style="color:#E1E4E8;">();</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">    private</span><span style="color:#B392F0;"> request</span><span style="color:#E1E4E8;">() {</span></span>\n<span class="line"><span style="color:#6A737D;">        // 队列中还有任务才会被执行</span></span>\n<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.queue.</span><span style="color:#79B8FF;">length</span><span style="color:#F97583;"> &amp;&amp;</span><span style="color:#79B8FF;"> this</span><span style="color:#E1E4E8;">.runCount </span><span style="color:#F97583;">&lt;</span><span style="color:#79B8FF;"> this</span><span style="color:#E1E4E8;">.maxCount) {</span></span>\n<span class="line"><span style="color:#79B8FF;">            this</span><span style="color:#E1E4E8;">.runCount</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#6A737D;">            // 执行先加入队列的函数</span></span>\n<span class="line"><span style="color:#79B8FF;">            this</span><span style="color:#E1E4E8;">.queue.</span><span style="color:#B392F0;">shift</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#79B8FF;">                this</span><span style="color:#E1E4E8;">.runCount</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#6A737D;">                // 尝试进行下一次任务</span></span>\n<span class="line"><span style="color:#79B8FF;">                this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">request</span><span style="color:#E1E4E8;">();</span></span>\n<span class="line"><span style="color:#E1E4E8;">            });</span></span>\n<span class="line"><span style="color:#E1E4E8;">        }</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// 测试</span></span>\n<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> scheduler</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Scheduler</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">const</span><span style="color:#B392F0;"> addTask</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">time</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> number</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">data</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> string</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    scheduler.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(time, data);</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#B392F0;">addTask</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1000</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;1&#39;</span><span style="color:#E1E4E8;">);</span></span>\n<span class="line"><span style="color:#B392F0;">addTask</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">500</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;2&#39;</span><span style="color:#E1E4E8;">);</span></span>\n<span class="line"><span style="color:#B392F0;">addTask</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">300</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;3&#39;</span><span style="color:#E1E4E8;">);</span></span>\n<span class="line"><span style="color:#B392F0;">addTask</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">400</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;4&#39;</span><span style="color:#E1E4E8;">);</span></span>\n<span class="line"><span style="color:#6A737D;">// 输出结果 2 3 1 4</span></span></code></pre></div><h2 id="_11-设计可取消-promise" tabindex="-1">11. 设计可取消 Promise <a class="header-anchor" href="#_11-设计可取消-promise" aria-label="Permalink to &quot;11\\. 设计可取消 Promise&quot;">​</a></h2><p>实现</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> CancellablePromise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [</span><span style="color:#B392F0;">Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;, () </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span><span style="color:#E1E4E8;">];</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> makeCancellable</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">promise</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> CancellablePromise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; {</span></span>\n<span class="line"><span style="color:#F97583;">  let</span><span style="color:#B392F0;"> rejectFn</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">reason</span><span style="color:#F97583;">?:</span><span style="color:#79B8FF;"> any</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> wrappedPromise</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> new</span><span style="color:#79B8FF;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;((</span><span style="color:#FFAB70;">resolve</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">reject</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    rejectFn </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> reject; </span><span style="color:#6A737D;">// 保存 reject 函数引用以便后续调用</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#E1E4E8;">    promise.</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(</span></span>\n<span class="line"><span style="color:#E1E4E8;">      (</span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (rejectFn </span><span style="color:#F97583;">!==</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 如果没有被取消，那么解决 wrappedPromise</span></span>\n<span class="line"><span style="color:#B392F0;">          resolve</span><span style="color:#E1E4E8;">(value);</span></span>\n<span class="line"><span style="color:#E1E4E8;">          rejectFn </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 清除 rejectFn 引用，避免内存泄漏</span></span>\n<span class="line"><span style="color:#E1E4E8;">        }</span></span>\n<span class="line"><span style="color:#E1E4E8;">      },</span></span>\n<span class="line"><span style="color:#E1E4E8;">      (</span><span style="color:#FFAB70;">error</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (rejectFn </span><span style="color:#F97583;">!==</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 如果没有被取消，那么拒绝 wrappedPromise</span></span>\n<span class="line"><span style="color:#B392F0;">          reject</span><span style="color:#E1E4E8;">(error);</span></span>\n<span class="line"><span style="color:#E1E4E8;">          rejectFn </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 清除 rejectFn 引用，避免内存泄漏</span></span>\n<span class="line"><span style="color:#E1E4E8;">        }</span></span>\n<span class="line"><span style="color:#E1E4E8;">      }</span></span>\n<span class="line"><span style="color:#E1E4E8;">    );</span></span>\n<span class="line"><span style="color:#E1E4E8;">  });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">  const</span><span style="color:#B392F0;"> cancel</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (rejectFn </span><span style="color:#F97583;">!==</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#B392F0;">      rejectFn</span><span style="color:#E1E4E8;">({ cancelled: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;"> }); </span><span style="color:#6A737D;">// 立即拒绝 wrappedPromise</span></span>\n<span class="line"><span style="color:#E1E4E8;">      rejectFn </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 防止内存泄漏，清除 rejectFn 引用</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  };</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">  return</span><span style="color:#E1E4E8;"> [wrappedPromise, cancel];</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// 使用示例</span></span>\n<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> [</span><span style="color:#79B8FF;">cancellablePromise</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">cancel</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> makeCancellable</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#79B8FF;"> Promise</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;">&gt;((</span><span style="color:#FFAB70;">resolve</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#B392F0;">  setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#B392F0;">    resolve</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Resolved after 2 seconds&quot;</span><span style="color:#E1E4E8;">);</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }, </span><span style="color:#79B8FF;">2000</span><span style="color:#E1E4E8;">);</span></span>\n<span class="line"><span style="color:#E1E4E8;">}));</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#E1E4E8;">cancellablePromise</span></span>\n<span class="line"><span style="color:#E1E4E8;">  .</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">result</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(result);</span></span>\n<span class="line"><span style="color:#E1E4E8;">  })</span></span>\n<span class="line"><span style="color:#E1E4E8;">  .</span><span style="color:#B392F0;">catch</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">error</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (error </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> error.cancelled) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">      console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Promise was cancelled&quot;</span><span style="color:#E1E4E8;">);</span></span>\n<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">      console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Promise was rejected with error:&quot;</span><span style="color:#E1E4E8;">, error);</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  });</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// 立即取消 Promise</span></span>\n<span class="line"><span style="color:#B392F0;">cancel</span><span style="color:#E1E4E8;">();</span></span></code></pre></div><h2 id="_10-多个-callback-函数-promise-化的测试用例" tabindex="-1">10. 多个 Callback 函数 Promise 化的测试用例 <a class="header-anchor" href="#_10-多个-callback-函数-promise-化的测试用例" aria-label="Permalink to &quot;10\\. 多个 Callback 函数 Promise 化的测试用例&quot;">​</a></h2><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// Node.js 风格的 myFunction</span></span>\n<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> myFunction</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">cb1</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">cb2</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">cb3</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#6A737D;">  // 模拟异步操作，例如 I/O</span></span>\n<span class="line"><span style="color:#B392F0;">  setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> cb1</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;result1&quot;</span><span style="color:#E1E4E8;">), Math.</span><span style="color:#B392F0;">floor</span><span style="color:#E1E4E8;">(Math.</span><span style="color:#B392F0;">random</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">*</span><span style="color:#79B8FF;"> 1000</span><span style="color:#E1E4E8;">));</span></span>\n<span class="line"><span style="color:#B392F0;">  setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> cb2</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;result2&quot;</span><span style="color:#E1E4E8;">), Math.</span><span style="color:#B392F0;">floor</span><span style="color:#E1E4E8;">(Math.</span><span style="color:#B392F0;">random</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">*</span><span style="color:#79B8FF;"> 1000</span><span style="color:#E1E4E8;">));</span></span>\n<span class="line"><span style="color:#B392F0;">  setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> cb3</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;result3&quot;</span><span style="color:#E1E4E8;">), Math.</span><span style="color:#B392F0;">floor</span><span style="color:#E1E4E8;">(Math.</span><span style="color:#B392F0;">random</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">*</span><span style="color:#79B8FF;"> 1000</span><span style="color:#E1E4E8;">));</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// 实现 myFunctionPromise，将 myFunction Promise 化。</span></span>\n<span class="line"><span style="color:#6A737D;">// cb callback 无 error 时，则为 resolve</span></span>\n<span class="line"><span style="color:#6A737D;">// 测试用例</span></span>\n<span class="line"><span style="color:#B392F0;">test</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;a&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">  try</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> results</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> myFunctionPromise</span><span style="color:#E1E4E8;">();</span></span>\n<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(results); </span><span style="color:#6A737D;">// 输出: [&#39;result1&#39;, &#39;result2&#39;, &#39;result3&#39;]</span></span>\n<span class="line"><span style="color:#6A737D;">    // 这里我们期望返回的 Promise 被成功地 resolve，并且结果按次序排列</span></span>\n<span class="line"><span style="color:#B392F0;">    expect</span><span style="color:#E1E4E8;">(results).</span><span style="color:#B392F0;">toEqual</span><span style="color:#E1E4E8;">([</span><span style="color:#9ECBFF;">&quot;result1&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;result2&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;result3&quot;</span><span style="color:#E1E4E8;">]);</span></span>\n<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (err) {</span></span>\n<span class="line"><span style="color:#6A737D;">    // 这里处理可能出现的错误</span></span>\n<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">error</span><span style="color:#E1E4E8;">(err);</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><p>实现</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// Promise 包装器，保证次序</span></span>\n<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> myFunctionPromise</span><span style="color:#E1E4E8;">() {</span></span>\n<span class="line"><span style="color:#F97583;">  return</span><span style="color:#F97583;"> new</span><span style="color:#79B8FF;"> Promise</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">resolve</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">reject</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> results </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Array</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 创建一个长度为 3 的数组来存储结果</span></span>\n<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> count </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> hasErrorOccurred </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> false</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">    function</span><span style="color:#B392F0;"> createFinalCallback</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">index</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#F97583;">      return</span><span style="color:#F97583;"> function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">err</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">result</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (hasErrorOccurred) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (err) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">          hasErrorOccurred </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> true</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#F97583;">          return</span><span style="color:#B392F0;"> reject</span><span style="color:#E1E4E8;">(err);</span></span>\n<span class="line"><span style="color:#E1E4E8;">        }</span></span>\n<span class="line"><span style="color:#E1E4E8;">        results[index] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> result; </span><span style="color:#6A737D;">// 根据回调的标识符存储结果</span></span>\n<span class="line"><span style="color:#E1E4E8;">        count</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (count </span><span style="color:#F97583;">===</span><span style="color:#79B8FF;"> 3</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#B392F0;">          resolve</span><span style="color:#E1E4E8;">(results); </span><span style="color:#6A737D;">// 当所有回调都执行完毕时，按顺序解决 Promise</span></span>\n<span class="line"><span style="color:#E1E4E8;">        }</span></span>\n<span class="line"><span style="color:#E1E4E8;">      };</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#B392F0;">    myFunction</span><span style="color:#E1E4E8;">(</span></span>\n<span class="line"><span style="color:#B392F0;">      createFinalCallback</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">),</span></span>\n<span class="line"><span style="color:#B392F0;">      createFinalCallback</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">),</span></span>\n<span class="line"><span style="color:#B392F0;">      createFinalCallback</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"><span style="color:#E1E4E8;">    );</span></span>\n<span class="line"><span style="color:#E1E4E8;">  });</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div>',63)]))}]]);export{l as __pageData,o as default};
